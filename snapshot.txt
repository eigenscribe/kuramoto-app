# Repository Snapshot

## Repo Intent (author-provided)

[No repo intent provided]

## Directory Tree

.replit
.streamlit
  config.toml
app.py
attached_assets
  Pasted--Kuramoto-Model-Simulator-Network-Distributions-Animation-Interactive-Animation-Simulation-1745649535047.txt
  Pasted--Main-styling-for-the-entire-application-body-font-family-Aclonica-sans-serif-ma-1744622504278.txt
  Pasted--box-sizing-border-box-body-font-family-Aclonica-serif-margin-0-paddi-1744621860792.txt
  Pasted-Connection-error-Connection-failed-with-status-502-and-response-DOCTYPE-html-html-lang-en--1745651772588.txt
  Pasted-TypeError-Cannot-cast-scalar-from-dtype-float64-to-dtype-int64-according-to-the-rule-safe-T-1745197673005.txt
  Pasted-with-col2-st-subheader-Initial-Oscillator-Positions-fig-plot-initial-positions-system--1744623511889.txt
  wisp.jpg
backups
  app.py.backup_working
  checkpoint_before_refactor
    app.py
    app_original_1971_lines.py
    database.py
    kuramoto_model.py
  ml_removal
    database.py.original
    database.py.with_ml
kuramoto_simulations.db
pyproject.toml
replit.nix
repo-summary.py
snapshot.txt
src
  __init__.py
  database
    __init__.py
    database.py
  models
    __init__.py
    kuramoto_model.py
  styles
    main.css
    orange_pink_gradient.css
    styles.css
static
  images
    wisp.base64
    wisp.jpg
  json
    default_config.json
    kuramoto_config.json
uv.lock

## Files



=== .streamlit/config.toml ===

[server]
headless = true
address = "0.0.0.0"
port = 5000

[theme]
base = "dark"
primaryColor = "#27aaff"
backgroundColor = "#121212"
secondaryBackgroundColor = "#1f1f1f"
textColor = "#ffffff"

=== app.py ===

import streamlit as st

# Set page config must be the first Streamlit command
st.set_page_config(
    page_title="Kuramoto Model Simulator",
    page_icon="ðŸ”„",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Let's strip down all CSS in the app to the minimum needed
st.markdown("""
<style>
    /* No special styling - let Streamlit's defaults handle alignment */
</style>
""", unsafe_allow_html=True)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors
from matplotlib.colors import LinearSegmentedColormap
import json
from src.models.kuramoto_model import KuramotoModel
from src.database.database import save_configuration
import time

# Initialize refresh state for network refresh button
if 'refresh_network' not in st.session_state:
    st.session_state.refresh_network = False

# Function to parse JSON parameters input
def parse_json_parameters(json_string):
    """
    Parse a JSON string containing Kuramoto simulation parameters.
    
    Expected format:
    {
        "n_oscillators": 10,
        "coupling_strength": 1.0,
        "network_type": "All-to-All", 
        "simulation_time": 10.0,
        "time_step": 0.1,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.2
        },
        "adjacency_matrix": [[0,1,1,...], [1,0,1,...], ...] (optional)
    }
    
    Returns:
    dict: Parameters dictionary containing all parsed values, or error message
    """
    try:
        # Parse the JSON string
        params = json.loads(json_string)
        
        # Initialize the result dictionary with default values
        result = {
            "n_oscillators": 10,
            "coupling_strength": 1.0,
            "network_type": "All-to-All",
            "simulation_time": 10.0,
            "time_step": 0.1,
            "random_seed": 42,
            "frequency_distribution": "Normal",
            "frequency_parameters": {
                "mean": 0.0,
                "std": 0.2
            },
            "adjacency_matrix": None
        }
        
        # Update with values from the JSON
        if "n_oscillators" in params:
            result["n_oscillators"] = int(params["n_oscillators"])
            
        if "coupling_strength" in params:
            result["coupling_strength"] = float(params["coupling_strength"])
            
        if "network_type" in params:
            valid_types = ["All-to-All", "Nearest Neighbor", "Random", "Custom Adjacency Matrix"]
            if params["network_type"] in valid_types:
                result["network_type"] = params["network_type"]
            
        if "simulation_time" in params:
            result["simulation_time"] = float(params["simulation_time"])
            
        # time_step is now automatically calculated based on oscillator frequencies
        # We keep this for backward compatibility with existing JSON configs
        if "time_step" in params:
            # We acknowledge the parameter but don't use it directly
            pass
            
        if "random_seed" in params:
            result["random_seed"] = int(params["random_seed"])
            
        if "frequency_distribution" in params:
            valid_distributions = ["Normal", "Uniform", "Custom", "Golden Ratio", "Bimodal"]
            if params["frequency_distribution"] in valid_distributions:
                result["frequency_distribution"] = params["frequency_distribution"]
            
        if "frequency_parameters" in params:
            fp = params["frequency_parameters"]
            if "mean" in fp and result["frequency_distribution"] == "Normal":
                result["frequency_parameters"]["mean"] = float(fp["mean"])
            if "std" in fp and result["frequency_distribution"] == "Normal":
                result["frequency_parameters"]["std"] = float(fp["std"])
            if "min" in fp and result["frequency_distribution"] == "Uniform":
                result["frequency_parameters"]["min"] = float(fp["min"])
            if "max" in fp and result["frequency_distribution"] == "Uniform":
                result["frequency_parameters"]["max"] = float(fp["max"])
            if "custom_values" in fp and result["frequency_distribution"] == "Custom":
                # Convert custom frequency values to floats
                result["frequency_parameters"]["custom_values"] = [float(x) for x in fp["custom_values"]]
        
        # Process the adjacency matrix if provided
        if "adjacency_matrix" in params:
            matrix_data = params["adjacency_matrix"]
            if isinstance(matrix_data, list) and len(matrix_data) > 0:
                try:
                    # Convert to numpy array and validate
                    adj_matrix = np.array(matrix_data, dtype=float)
                    
                    # Check if the matrix is square
                    if adj_matrix.shape[0] == adj_matrix.shape[1]:
                        result["adjacency_matrix"] = adj_matrix
                        # If adjacency matrix is provided, force network type to Custom
                        result["network_type"] = "Custom Adjacency Matrix"
                    else:
                        return None, f"Adjacency matrix must be square. Current shape: {adj_matrix.shape}"
                except Exception as e:
                    return None, f"Error processing adjacency matrix: {str(e)}"
        
        return result, None
        
    except Exception as e:
        # Return error message if parsing fails
        return None, str(e)

# Initialize session state for configuration loading
if 'loaded_config' not in st.session_state:
    st.session_state.loaded_config = None

# Check for temp imported parameters and apply them
# This handles imports from the JSON Parameter Import Section
if 'temp_imported_params' in st.session_state:
    params = st.session_state.temp_imported_params
    
    # Update session state with the parsed parameters
    st.session_state.n_oscillators = params["n_oscillators"]
    st.session_state.coupling_strength = params["coupling_strength"]
    st.session_state.network_type = params["network_type"]
    st.session_state.simulation_time = params["simulation_time"]
    # time_step is no longer used, it's automatically calculated
    st.session_state.random_seed = params["random_seed"]
    st.session_state.freq_type = params["frequency_distribution"]
    
    # Update frequency parameters based on distribution type
    if params["frequency_distribution"] == "Normal":
        st.session_state.freq_mean = params["frequency_parameters"]["mean"]
        st.session_state.freq_std = params["frequency_parameters"]["std"]
    elif params["frequency_distribution"] == "Uniform":
        st.session_state.freq_min = params["frequency_parameters"]["min"]
        st.session_state.freq_max = params["frequency_parameters"]["max"]
    elif params["frequency_distribution"] == "Custom" and "custom_values" in params["frequency_parameters"]:
        st.session_state.custom_freqs = ", ".join(str(x) for x in params["frequency_parameters"]["custom_values"])
    
    # Handle custom adjacency matrix if present
    if params["adjacency_matrix"] is not None:
        matrix = params["adjacency_matrix"]
        
        # Convert matrix to string representation for the text area
        matrix_str = ""
        for row in matrix:
            matrix_str += ", ".join(str(val) for val in row) + "\n"
        
        # Update session state for adjacency matrix
        st.session_state.adj_matrix_input = matrix_str.strip()
        st.session_state.loaded_adj_matrix = matrix
    
    # Clear the temp parameters to avoid reapplying
    del st.session_state.temp_imported_params

# Apply loaded configuration if available
if st.session_state.loaded_config is not None:
    config = st.session_state.loaded_config
    
    # Update session state with configuration values
    st.session_state.n_oscillators = config['n_oscillators']
    st.session_state.coupling_strength = config['coupling_strength']
    st.session_state.simulation_time = config['simulation_time']
    # time_step is no longer needed - it's automatically calculated
    st.session_state.random_seed = int(config['random_seed']) # Ensure it's an integer
    st.session_state.network_type = config['network_type']
    st.session_state.freq_type = config['frequency_distribution']
    
    # Update frequency distribution parameters based on type
    freq_params = config.get('frequency_params', {})
    if freq_params:
        try:
            freq_params = json.loads(freq_params)
        except:
            # It's already a dictionary
            pass
            
        if config['frequency_distribution'] == "Normal":
            st.session_state.freq_mean = freq_params.get('mean', 0.0)
            st.session_state.freq_std = freq_params.get('std', 1.0)
        elif config['frequency_distribution'] == "Uniform":
            st.session_state.freq_min = freq_params.get('min', -1.0)
            st.session_state.freq_max = freq_params.get('max', 1.0)
        elif config['frequency_distribution'] == "Bimodal":
            st.session_state.peak1 = freq_params.get('peak1', -1.0)
            st.session_state.peak2 = freq_params.get('peak2', 1.0)
        elif config['frequency_distribution'] == "Custom":
            if 'custom_values' in freq_params and isinstance(freq_params['custom_values'], list):
                st.session_state.custom_freqs = ', '.join(map(str, freq_params['custom_values']))
            elif 'values' in freq_params and isinstance(freq_params['values'], list):
                st.session_state.custom_freqs = ', '.join(map(str, freq_params['values']))
    
    # Handle custom adjacency matrix if present
    if config['network_type'] == "Custom Adjacency Matrix" and config.get('adjacency_matrix') is not None:
        try:
            matrix = config['adjacency_matrix']
            if isinstance(matrix, bytes):
                import pickle
                matrix = pickle.loads(matrix)
            elif isinstance(matrix, list):
                # Convert list to numpy array if it's still a list
                matrix = np.array(matrix)
            
            # Make sure no self-loops (diagonal elements should be zero)
            # This is important to ensure consistent visualization
            if hasattr(matrix, 'shape') and matrix.shape[0] == matrix.shape[1]:
                np.fill_diagonal(matrix, 0)
                
            # Print debug info
            print(f"Loading adjacency matrix: type={type(matrix)}, shape={matrix.shape if hasattr(matrix, 'shape') else 'unknown'}")
            
            if hasattr(matrix, 'shape'):
                print(f"Matrix sum: {np.sum(matrix)}, non-zeros: {np.count_nonzero(matrix)}")
                if matrix.shape[0] >= 3:
                    print("Sample (top-left 3x3):")
                    print(matrix[:3, :3])
                
            # Convert matrix to string representation for the text area
            matrix_str = ""
            for row in matrix:
                matrix_str += ", ".join(str(val) for val in row) + "\n"
            st.session_state.adj_matrix_input = matrix_str.strip()
            
            # Store the matrix for later use in this session
            # This ensures the matrix is properly passed to the simulation
            # Always update the matrix in session state - force overwrite to ensure latest is used
            st.session_state.loaded_adj_matrix = matrix
            print(f"Stored adjacency matrix in session state with shape {matrix.shape}")
                
        except Exception as e:
            st.warning(f"Could not load custom adjacency matrix: {str(e)}")
    
    # Clear the loaded config to prevent reapplying it on next rerun
    st.session_state.loaded_config = None

# Set up Matplotlib style for dark theme plots
plt.style.use('dark_background')
plt.rcParams.update({
    'axes.facecolor': '#1e1e1e',
    'figure.facecolor': '#1e1e1e',
    'savefig.facecolor': '#1e1e1e',
    'axes.grid': True,
    'grid.color': '#444444',
    'grid.alpha': 0.3,
    'grid.linestyle': '--',
    'axes.edgecolor': '#444444',
    'xtick.color': '#888888',
    'ytick.color': '#888888',
    'text.color': '#ffffff',
    'axes.labelcolor': '#ffffff',
    'axes.titlecolor': '#ffffff',
    'lines.linewidth': 2,
})

# Page config is now at the top of the file
# This comment is kept to maintain file structure

# Import Aclonica font from Google Fonts
st.markdown("""
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Aclonica&display=swap" rel="stylesheet">
""", unsafe_allow_html=True)

# Load custom CSS
with open("src/styles/styles.css") as f:
    st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)

# Get the base64 encoded image
with open("static/images/wisp.base64", "r") as f:
    encoded_image = f.read()

# Add custom background and custom font
st.markdown(f"""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Aclonica&display=swap');
    
    .stApp {{
        background-image: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), 
                         url('data:image/jpeg;base64,{encoded_image}');
        background-size: cover;
        background-repeat: no-repeat;
        background-attachment: fixed;
    }}
    
    /* Ensure Aclonica font is applied everywhere */
    body, div, p, h1, h2, h3, h4, h5, h6, li, span, label, button, .sidebar .sidebar-content {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Fix Streamlit buttons to use Aclonica */
    button, .stButton button, .stDownloadButton button {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Fix Streamlit widgets text */
    .stSlider label, .stSelectbox label, .stNumberInput label {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Apply gradient_text1 to sidebar labels */
    .sidebar .sidebar-content label {{
        background: -webkit-linear-gradient(#14a5ff, #8138ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: bold;
    }}
</style>
""", unsafe_allow_html=True)

# Title
st.markdown("<h1 class='gradient_text1'>Kuramoto Model Simulator</h1>", unsafe_allow_html=True)

# Let Streamlit handle the styling
# No custom CSS needed here

# Create main sidebar parameters header at the top
st.sidebar.markdown("<h2 class='gradient_text1'>Simulation Parameters</h2>", unsafe_allow_html=True)

# Add Time Controls Section first
st.sidebar.markdown("<h3 class='gradient_text1'>Time Controls</h3>", unsafe_allow_html=True)

# Simulation time parameters
simulation_time = st.sidebar.slider(
    "Simulation Time",
    min_value=1.0,
    max_value=200.0,
    value=100.0,  # Set default value to 100.0
    step=1.0,
    help="Total simulation time",
    key="simulation_time"
)

# Time step is now automatically calculated based on oscillator frequencies and doesn't need a UI control
# Default value maintained for backward compatibility with database functions
time_step = 0.01

# Add separator before individual parameters
st.sidebar.markdown("<hr style='margin: 15px 0px; border-color: rgba(255,255,255,0.2);'>", unsafe_allow_html=True)

# Create subheading for manual parameters
st.sidebar.markdown("<h3 class='gradient_text1'>Manual Configuration</h3>", unsafe_allow_html=True)

# Initialize session state for parameters if they don't exist
if 'n_oscillators' not in st.session_state:
    st.session_state.n_oscillators = 10
if 'coupling_strength' not in st.session_state:
    st.session_state.coupling_strength = 1.0
if 'freq_type' not in st.session_state:
    st.session_state.freq_type = "Normal"
if 'freq_mean' not in st.session_state:
    st.session_state.freq_mean = 0.0
if 'freq_std' not in st.session_state:
    st.session_state.freq_std = 1.0
if 'freq_min' not in st.session_state:
    st.session_state.freq_min = -1.0
if 'freq_max' not in st.session_state:
    st.session_state.freq_max = 1.0
if 'peak1' not in st.session_state:
    st.session_state.peak1 = -1.0
if 'peak2' not in st.session_state:
    st.session_state.peak2 = 1.0
if 'custom_freqs' not in st.session_state:
    st.session_state.custom_freqs = "0.5, 1.0, 1.5, 2.0, 2.5, 3.0, -0.5, -1.0, -1.5, -2.0"
if 'simulation_time' not in st.session_state:
    st.session_state.simulation_time = 100.0
# Default time_step value maintained for backward compatibility
time_step = 0.01
# network_type is now initialized in the network connectivity section
if 'adj_matrix_input' not in st.session_state:
    # Create a default example matrix for a 5x5 ring topology
    default_matrix = "0, 1, 0, 0, 1\n1, 0, 1, 0, 0\n0, 1, 0, 1, 0\n0, 0, 1, 0, 1\n1, 0, 0, 1, 0"
    st.session_state.adj_matrix_input = default_matrix

# For auto-adjusting oscillator count based on matrix dimensions
if 'next_n_oscillators' not in st.session_state:
    st.session_state.next_n_oscillators = None
    
# If we have a pending oscillator count update from the previous run, apply it now
if st.session_state.next_n_oscillators is not None:
    print(f"Updating oscillator count from {st.session_state.n_oscillators} to {st.session_state.next_n_oscillators}")
    st.session_state.n_oscillators = st.session_state.next_n_oscillators
    st.session_state.next_n_oscillators = None  # Clear the pending update

# Number of oscillators slider
n_oscillators = st.sidebar.slider(
    "Number of Oscillators",
    min_value=2,
    max_value=50,
    step=1,
    help="Number of oscillators in the system",
    key="n_oscillators"
)

# Coupling strength slider
coupling_strength = st.sidebar.slider(
    "Coupling Strength (K)",
    min_value=0.0,
    max_value=10.0,
    step=0.1,
    help="Strength of coupling between oscillators",
    key="coupling_strength"
)

# Frequency distribution type
freq_type = st.sidebar.selectbox(
    "Frequency Distribution",
    ["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"],
    index=["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"].index(st.session_state.freq_type) if st.session_state.freq_type in ["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"] else 0,
    help="Distribution of natural frequencies",
    key="freq_type"
)

# Parameters for frequency distribution
if freq_type == "Normal":
    freq_mean = st.sidebar.slider("Mean", -2.0, 2.0, step=0.1, key="freq_mean")
    freq_std = st.sidebar.slider("Standard Deviation", 0.1, 3.0, step=0.1, key="freq_std")
    frequencies = np.random.normal(freq_mean, freq_std, n_oscillators)
    
elif freq_type == "Uniform":
    freq_min = st.sidebar.slider("Minimum", -5.0, 0.0, step=0.1, key="freq_min")
    freq_max = st.sidebar.slider("Maximum", 0.0, 5.0, step=0.1, key="freq_max")
    frequencies = np.random.uniform(freq_min, freq_max, n_oscillators)
    
elif freq_type == "Bimodal":
    peak1 = st.sidebar.slider("Peak 1", -5.0, 0.0, step=0.1, key="peak1")
    peak2 = st.sidebar.slider("Peak 2", 0.0, 5.0, step=0.1, key="peak2")
    mix = np.random.choice([0, 1], size=n_oscillators)
    freq1 = np.random.normal(peak1, 0.3, n_oscillators)
    freq2 = np.random.normal(peak2, 0.3, n_oscillators)
    frequencies = mix * freq1 + (1 - mix) * freq2

elif freq_type == "Golden Ratio":
    # The golden ratio (phi) â‰ˆ 1.618033988749895
    phi = (1 + 5**0.5) / 2
    
    # Create a golden ratio sequence starting at -3
    golden_ratio_start = -3.0
    st.sidebar.markdown(f"""
    <div style="background-color: rgba(255,200,0,0.15); padding: 10px; border-radius: 5px;">
    <p><b>Golden Ratio Distribution</b></p>
    <p>This creates a sequence where each frequency follows the golden ratio (Ï† â‰ˆ 1.618), 
    starting from {golden_ratio_start}.</p>
    <p>Each oscillator's frequency is: {golden_ratio_start} + iÂ·Ï†</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Generate frequencies that follow the golden ratio in sequence
    frequencies = np.array([golden_ratio_start + i * phi for i in range(n_oscillators)])
    
else:  # Custom
    custom_freqs = st.sidebar.text_area(
        "Enter custom frequencies (comma-separated)",
        value=st.session_state.custom_freqs,
        height=150,
        key="custom_freqs"
    )
    try:
        frequencies = np.array([float(x.strip()) for x in custom_freqs.split(',')])
        # Ensure we have the right number of frequencies
        if len(frequencies) < n_oscillators:
            # Repeat the pattern if not enough values
            frequencies = np.tile(frequencies, int(np.ceil(n_oscillators / len(frequencies))))
        frequencies = frequencies[:n_oscillators]  # Trim if too many
    except:
        st.sidebar.error("Invalid frequency input. Using normal distribution instead.")
        frequencies = np.random.normal(0, 1, n_oscillators)

# Random seed setting
if "random_seed" not in st.session_state:
    st.session_state.random_seed = 42

random_seed = int(st.sidebar.number_input(
    "Random Seed", 
    min_value=0,
    step=1,
    help="Seed for reproducibility",
    key="random_seed"
))

# Network Connectivity Configuration
st.sidebar.markdown("<h3 class='gradient_text1'>Network Connectivity</h3>", unsafe_allow_html=True)

# Add a refresh button at the top of the Network Connectivity section
if st.sidebar.button("ðŸ”„ Refresh Simulation", key="refresh_btn"):
    st.session_state.refresh_network = True
    print("Network refresh requested via main refresh button")
    st.rerun()

# Create radio button for network type without specifying both index and session state key
# This fixes the warning: "widget created with default value but also had value set via Session State API"
options = ["All-to-All", "Nearest Neighbor", "Random", "Custom Adjacency Matrix"]
if "network_type" not in st.session_state:
    # Only set this if it's not already in session state
    st.session_state.network_type = "Random"

# Get current index
current_index = options.index(st.session_state.network_type)

# Create the radio button
network_type = st.sidebar.radio(
    "Network Type",
    options=options,
    index=current_index,
    help="Define how oscillators are connected to each other"
)

# Update session state if changed
if network_type != st.session_state.network_type:
    st.session_state.network_type = network_type

# Custom adjacency matrix input
adj_matrix = None
# Check if we have a loaded adjacency matrix from a configuration
if 'loaded_adj_matrix' in st.session_state:
    adj_matrix = st.session_state.loaded_adj_matrix
    print(f"Retrieved adjacency matrix from session state with shape {adj_matrix.shape if hasattr(adj_matrix, 'shape') else 'unknown'}")
    
    # Safety check to ensure matrix is valid
    if hasattr(adj_matrix, 'shape') and adj_matrix.shape[0] > 0:
        print(f"Matrix looks valid: shape={adj_matrix.shape}, sum={np.sum(adj_matrix)}, non-zeros={np.count_nonzero(adj_matrix)}")
        
        # CRITICAL: We need to force the correct network type
        # This needs to take precedence over what's selected in the UI radio button
        if network_type != "Custom Adjacency Matrix":
            print("Detected loaded matrix with network type that doesn't match 'Custom Adjacency Matrix'.")
            print(f"Current network_type is '{network_type}' but will use matrix internally")
    else:
        print("Warning: Found loaded_adj_matrix in session state but it appears invalid:")
        print(f"Matrix type: {type(adj_matrix)}")
        if hasattr(adj_matrix, 'shape'):
            print(f"Shape: {adj_matrix.shape}")
        adj_matrix = None  # Reset to None if invalid matrix

if network_type == "Custom Adjacency Matrix":
    st.sidebar.markdown("""
    <div style="font-size: 0.85em;">
    Enter your adjacency matrix as comma-separated values. Each row should be on a new line.
    <br>Example for 3 oscillators:
    <pre style="background-color: #222; padding: 5px; border-radius: 3px;">
0, 1, 0.5
1, 0, 0.8
0.5, 0.8, 0</pre>
    </div>
    """, unsafe_allow_html=True)
    
    # Create a default example matrix if no prior matrix exists
    if not st.session_state.adj_matrix_input:
        # Create a simple default example for smaller number of oscillators
        default_matrix = ""
        for i in range(min(5, n_oscillators)):
            row = []
            for j in range(min(5, n_oscillators)):
                if i == j:
                    row.append("0")  # No self-connections
                elif abs(i-j) == 1 or abs(i-j) == min(5, n_oscillators)-1:  # Ring-neighbors
                    row.append("1")  # Connected
                else:
                    row.append("0")  # Not connected
            default_matrix += ", ".join(row) + "\n"
                
    # Make sure we have a non-empty value for the text area
    if network_type == "Custom Adjacency Matrix" and not st.session_state.adj_matrix_input:
        print("Custom matrix selected but no existing input - initializing default")
        st.session_state.adj_matrix_input = default_matrix
        
    adj_matrix_input = st.sidebar.text_area(
        "Adjacency Matrix",
        value=st.session_state.adj_matrix_input,
        height=200,
        help="Enter the adjacency matrix as comma-separated values, each row on a new line",
        key="adj_matrix_input"
    )
    
    # Process the input adjacency matrix
    if adj_matrix_input:
        try:
            # Parse the input text into a numpy array
            rows = adj_matrix_input.strip().split('\n')
            
            # Ensure we have at least one row
            if len(rows) == 0:
                raise ValueError("No data found in matrix input")
                
            # Process each row, removing extra spaces and parsing values
            adj_matrix = []
            for row in rows:
                # Skip empty rows
                if not row.strip():
                    continue
                    
                # Process values in this row
                values = []
                for val in row.split(','):
                    # Convert to float, handling extra whitespace
                    cleaned_val = val.strip()
                    if cleaned_val:  # Skip empty entries
                        values.append(float(cleaned_val))
                
                # Ensure row has data
                if values:
                    adj_matrix.append(values)
            
            # Make sure we have a valid matrix with data
            if not adj_matrix:
                raise ValueError("Could not find valid numeric data in input")
                
            # Convert to numpy array for faster processing
            adj_matrix = np.array(adj_matrix)
            
            # Validate the adjacency matrix
            if adj_matrix.shape[0] != adj_matrix.shape[1]:
                st.sidebar.error(f"The adjacency matrix must be square. Current shape: {adj_matrix.shape}")
            elif adj_matrix.shape[0] != n_oscillators:
                # We can't modify widget session state once widgets are created,
                # so we'll save the desired dimension in a different session state variable
                matrix_dim = adj_matrix.shape[0]
                
                # Log information
                print(f"Matrix dimensions ({matrix_dim}) don't match current oscillator count ({n_oscillators})")
                
                # Store the matrix as is, don't try to resize it
                st.session_state.next_n_oscillators = matrix_dim
                
                # Show message explaining what's happening
                st.sidebar.info(f"""
                Matrix size ({matrix_dim}Ã—{matrix_dim}) differs from current oscillator count ({n_oscillators}).
                The matrix will be used as-is for this simulation. Next time you interact with the UI, 
                the oscillator count will automatically update to match your matrix dimensions.
                """)
                
                # Keep local variable as is, use adj_matrix without modification
            else:
                st.sidebar.success("Adjacency matrix validated successfully!")
                
                # Add a dedicated button to force network visualization refresh
                if st.sidebar.button("ðŸ”„ Refresh", key="force_refresh_btn"):
                    st.session_state.refresh_network = True
                    print("Network refresh requested via button")
                    st.rerun()
                
                # Add save preset button and input field
                with st.sidebar.expander("Save as Preset"):
                    preset_name = st.text_input("Preset Name", key="preset_name", 
                                             placeholder="Enter a name for this matrix")
                    if st.button("ðŸ’¾ Save Preset", key="save_preset_btn"):
                        if preset_name:
                            # Save the configuration with current parameters
                            config_id = save_configuration(
                                name=preset_name,
                                n_oscillators=adj_matrix.shape[0],
                                coupling_strength=coupling_strength,
                                simulation_time=simulation_time,
                                time_step=0.01,  # Default value for backward compatibility
                                random_seed=random_seed,  # Use the UI's random_seed
                                network_type="Custom Adjacency Matrix",
                                frequency_distribution=freq_type,
                                frequency_params=json.dumps({
                                    "mean": float(freq_mean) if 'freq_mean' in locals() else 0.0,
                                    "std": float(freq_std) if 'freq_std' in locals() else 1.0,
                                    "min": float(freq_min) if 'freq_min' in locals() else -1.0,
                                    "max": float(freq_max) if 'freq_max' in locals() else 1.0
                                }),
                                adjacency_matrix=adj_matrix
                            )
                            st.success(f"Saved preset '{preset_name}' successfully!")
                            print(f"Saved matrix preset: '{preset_name}' with shape {adj_matrix.shape}")
                        else:
                            st.error("Please enter a preset name")
                
            # Store in session state for persistence
            st.session_state.loaded_adj_matrix = adj_matrix
            print(f"Updated adjacency matrix in session state with shape {adj_matrix.shape}")
                
        except Exception as e:
            st.sidebar.error(f"Error parsing matrix: {str(e)}")
            print(f"Matrix parsing error: {str(e)}")
            print(f"Input was: '{adj_matrix_input}'")
            adj_matrix = None


# Add JSON Configuration section at the bottom of the sidebar
st.sidebar.markdown("<hr style='margin: 15px 0px; border-color: rgba(255,255,255,0.2);'>", unsafe_allow_html=True)
st.sidebar.markdown("<h3 class='gradient_text1'>JSON Configuration</h3>", unsafe_allow_html=True)

# Initialize session state for JSON example if not present
if 'json_example' not in st.session_state:
    st.session_state.json_example = ""

# Display text area for JSON input (larger and left-aligned)
json_input = st.sidebar.text_area(
    "Import/Export Parameters",
    value=st.session_state.json_example,
    height=200,
    placeholder='Paste your JSON configuration here...',
    help="Enter a valid JSON configuration for the Kuramoto simulation"
)

# Add a collapsible section with examples but without parameter details
with st.sidebar.expander("Examples", expanded=False):
    example_json = {
        "n_oscillators": 10,
        "coupling_strength": 1.0,
        "network_type": "All-to-All", 
        "simulation_time": 100.0,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.2
        }
    }
    
    st.code(json.dumps(example_json, indent=2), language="json")
    
    # Add small-world network example
    st.markdown("**Small-world network example:**")
    
    # Generate a sample small-world network
    n = 10
    sample_matrix = np.zeros((n, n))
    for i in range(n):
        # Connect to neighbors
        for j in range(1, 3):
            sample_matrix[i, (i+j) % n] = 1
            sample_matrix[i, (i-j) % n] = 1
            
    # Add a few random long-range connections
    np.random.seed(42)
    for _ in range(5):
        i = np.random.randint(0, n)
        j = np.random.randint(0, n)
        if i != j and sample_matrix[i, j] == 0:
            sample_matrix[i, j] = 1
            sample_matrix[j, i] = 1
            
    # Create example with matrix
    complex_example = {
        "n_oscillators": n,
        "coupling_strength": 0.8,
        "network_type": "Custom Adjacency Matrix",
        "simulation_time": 100.0,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.1
        },
        "adjacency_matrix": sample_matrix.tolist()
    }
    
    # Add button to use this example - with smaller text
    if st.button("Use Small-World", key="small_world_btn"):
        st.session_state.json_example = json.dumps(complex_example, indent=2)
        st.rerun()

# Add import button and logic
if st.sidebar.button("Import Parameters", key="sidebar_import_json_button"):
    if json_input.strip():
        try:
            # Parse the JSON input
            params, error = parse_json_parameters(json_input)
            
            if error:
                st.sidebar.error(f"Error parsing JSON: {error}")
            else:
                # Update session state with the parsed parameters
                if params is not None:
                    # Store all parameters in a temporary variable in session state
                    # This is to avoid the error when trying to change widget values after initialization
                    st.session_state.temp_imported_params = params
                    
                    # Show success message
                    st.sidebar.success("Parameters imported successfully! Applying settings...")
                    
                    # Rerun the app to apply the changes
                    st.rerun()
                else:
                    st.sidebar.error("Failed to parse JSON parameters. Please check your input format.")
        except Exception as e:
            st.sidebar.error(f"Error processing parameters: {str(e)}")
    else:
        st.sidebar.warning("Please enter JSON configuration before importing.")


# Create tabs for different visualizations (Network is default tab)
tab1, tab2, tab3, tab4 = st.tabs(["Network", "Distributions", "Animation", "Numerical Considerations"])

# Set a unique key for each tab to force refresh of the Network tab
if 'current_tab' not in st.session_state:
    st.session_state.current_tab = "Network"
    
# Add a hidden button that is programmatically clicked when checking a custom matrix
tab_key = f"tab_refresh_{int(time.time())}"
if st.session_state.current_tab == "Network" and adj_matrix is not None:
    # This ensures the network tab is refreshed when the adjacency matrix changes
    st.session_state.refresh_network = True

# Determine the effective network type for display and matrix creation
# If we have a custom matrix, ALWAYS force the network type to custom
# regardless of what's displayed in the UI
if adj_matrix is not None:
    print("Detected valid adjacency matrix - forcing internal network type to Custom")
    print(f"Matrix shape: {adj_matrix.shape}, sum: {np.sum(adj_matrix)}, non-zeros: {np.count_nonzero(adj_matrix)}")
    
    # Don't change the UI selection, but use Custom type for all internal processing
    network_type_internal = "Custom Adjacency Matrix"
    
    # CRITICAL: We must NOT delete the matrix from session state until we've used it successfully
    # Otherwise, it will be lost on the next rerun when Streamlit rebuilds the application
    
    # Keep a flag to signal we've saved the matrix for this session
    if 'using_loaded_matrix' not in st.session_state:
        st.session_state.using_loaded_matrix = True
        print("First use of loaded matrix - will keep in session state")
else:
    # Use the selected network type
    network_type_internal = network_type
    
    # If we don't have a custom matrix but the UI type is set to custom,
    # we need to ensure this is communicated clearly
    if network_type == "Custom Adjacency Matrix" and adj_matrix is None:
        # Use custom styled message with orange background instead of the default yellow warning
        # This matches the sidebar error messages styling
        st.markdown("""
        <div style="background-color: rgba(255,150,0,0.15); color: #ffaa50; 
                    padding: 10px; border-radius: 15px; border-left: 5px solid #ff8800;">
            <b>Matrix Input:</b> Please enter your custom adjacency matrix in the sidebar.
            The format should be comma-separated values with each row on a new line.
        </div>
        """, unsafe_allow_html=True)
        print("Warning: Custom adjacency matrix selected but no valid matrix found")

# Function to simulate model
@st.cache_data(ttl=300)
def run_simulation(n_oscillators, coupling_strength, frequencies, simulation_time, time_step=None, random_seed=None, 
                  adjacency_matrix=None):
    """
    Run a Kuramoto model simulation with the specified parameters and return the results.
    
    Parameters:
    -----------
    n_oscillators : int
        Number of oscillators
    coupling_strength : float
        Coupling strength parameter K
    frequencies : ndarray
        Natural frequencies of oscillators
    simulation_time : float
        Total simulation time
    time_step : float, optional
        DEPRECATED: This parameter is no longer used. The time step is now automatically calculated
        based on oscillator frequencies to ensure numerical stability and accuracy.
        The parameter is kept for backward compatibility with saved configurations.
    random_seed : int, optional
        Seed for random number generation
    adjacency_matrix : ndarray, optional
        Custom adjacency matrix defining network connectivity
        
    Returns:
    --------
    tuple
        (model, times, phases, order_parameter)
    """
    # Convert random_seed to integer to prevent type errors
    if random_seed is not None:
        random_seed = int(random_seed)
    
    # Initialize the model with given parameters
    model = KuramotoModel(
        n_oscillators=n_oscillators,
        coupling_strength=coupling_strength,
        frequencies=frequencies,
        adjacency_matrix=adjacency_matrix,
        simulation_time=simulation_time,
        random_seed=random_seed
    )
    
    # Run the simulation with automatically calculated time step
    try:
        # Force at least 500 time points for visualization
        times, phases, order_parameter = model.simulate(min_time_points=500)
        print("Simulation successful!")
        print(f"  times shape: {times.shape if hasattr(times, 'shape') else 'N/A'}")
        print(f"  phases shape: {phases.shape if hasattr(phases, 'shape') else 'N/A'}")
        print(f"  order_parameter shape: {order_parameter.shape if hasattr(order_parameter, 'shape') else 'N/A'}")
    except Exception as e:
        print(f"Error in simulation: {str(e)}")
        import traceback
        traceback.print_exc()
        # Return empty arrays for graceful failure
        times = np.linspace(0, simulation_time, 100)
        phases = np.zeros((n_oscillators, 100))
        order_parameter = np.zeros(100)
    
    # Return results
    return model, times, phases, order_parameter

# Run the simulation
# If we have a custom adjacency matrix, adjust the oscillator count to match matrix dimensions
sim_n_oscillators = n_oscillators
if adj_matrix is not None:
    matrix_dim = adj_matrix.shape[0]
    if matrix_dim != n_oscillators:
        print(f"Adjusting simulation oscillator count to match matrix dimensions: {matrix_dim}")
        sim_n_oscillators = matrix_dim
        
        # Also adjust frequencies to match this count
        if len(frequencies) != sim_n_oscillators:
            print(f"Adjusting frequencies array from length {len(frequencies)} to {sim_n_oscillators}")
            if len(frequencies) > sim_n_oscillators:
                # Truncate if too many
                frequencies = frequencies[:sim_n_oscillators]
            else:
                # Extend by cycling through existing values if too few
                frequencies = np.resize(frequencies, sim_n_oscillators)

# Get current random seed from session state
current_random_seed = st.session_state.random_seed if "random_seed" in st.session_state else 42

# Run simulation
model, times, phases, order_parameter = run_simulation(
    n_oscillators=sim_n_oscillators,
    coupling_strength=coupling_strength,
    frequencies=frequencies,
    simulation_time=simulation_time,
    time_step=None,  # Not actually used, time_step is auto-calculated
    random_seed=current_random_seed,
    adjacency_matrix=adj_matrix
)

########################
# TAB 1: NETWORK TAB
########################
with tab1:
    # Update current tab in session state to track which tab is active
    st.session_state.current_tab = "Network"
    
    # Force a reload when we have a custom matrix change
    if 'refresh_network' in st.session_state and st.session_state.refresh_network:
        # Reset the flag to prevent infinite reloads
        st.session_state.refresh_network = False
        # This will cause network visualization to rebuild completely
        st.empty().button("Refresh Network", key=f"network_refresh_{time.time()}", on_click=lambda: None)
    st.markdown("<h2 class='gradient_text2'>Network Structure</h2>", unsafe_allow_html=True)
    
    # Display simulation information
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Create a network visualization
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5), gridspec_kw={'width_ratios': [2, 1]})
    
    # Import networkx for graph visualization
    import networkx as nx
    
    # Make sure adj_matrix is defined for all network types
    if network_type_internal == "All-to-All":
        # For all-to-all, create a fully connected matrix with uniform coupling
        network_adj_matrix = np.ones((n_oscillators, n_oscillators))
        np.fill_diagonal(network_adj_matrix, 0)  # No self-connections
    elif network_type_internal == "Nearest Neighbor":
        # For nearest neighbor, create a ring topology
        network_adj_matrix = np.zeros((n_oscillators, n_oscillators))
        for i in range(n_oscillators):
            # Connect to left and right neighbors on the ring
            network_adj_matrix[i, (i-1) % n_oscillators] = 1
            network_adj_matrix[i, (i+1) % n_oscillators] = 1
    elif network_type_internal == "Random":
        # For random, create random connections with 20% probability
        np.random.seed(current_random_seed)  # Use same seed for reproducibility
        network_adj_matrix = np.random.random((n_oscillators, n_oscillators)) < 0.2
        network_adj_matrix = network_adj_matrix.astype(float)
        np.fill_diagonal(network_adj_matrix, 0)  # No self-connections
    else:  # Custom Adjacency Matrix
        if adj_matrix is not None:
            # Make sure we're using a copy of the matrix to avoid modifying the original
            network_adj_matrix = np.array(adj_matrix, copy=True)
            
            # This section handles the case where network_adj_matrix dimensions
            # don't match n_oscillators, which might happen in rare cases
            if network_adj_matrix.shape[0] != n_oscillators:
                print(f"Network matrix dimensions mismatch: matrix is {network_adj_matrix.shape} but n_oscillators={n_oscillators}")
                
                # Here we directly use the matrix at its current dimensions without changing session state
                # This is safe because we're not modifying widget values, just local processing
                n_oscillators = network_adj_matrix.shape[0]
                print(f"Using matrix at its native dimension: {n_oscillators}x{n_oscillators}")
            
            # Print detailed debug info
            print(f"Using custom adjacency matrix with shape {network_adj_matrix.shape}")
            print(f"Sum of elements: {np.sum(network_adj_matrix)}")
            print(f"Number of non-zero elements: {np.count_nonzero(network_adj_matrix)}")
            if network_adj_matrix.shape[0] >= 3:
                print("Sample (top-left 3x3):")
                print(network_adj_matrix[:3, :3])
        else:
            print("Warning: No custom adjacency matrix provided, using fallback")
            # Create a default matrix but NOT fully connected
            # Use a simple ring structure instead as fallback
            network_adj_matrix = np.zeros((n_oscillators, n_oscillators))
            for i in range(n_oscillators):
                network_adj_matrix[i, (i-1) % n_oscillators] = 1
                network_adj_matrix[i, (i+1) % n_oscillators] = 1
    
    # Create a graph visualization using networkx
    # Ensure the adjacency matrix has no self-loops (diagonal should be zero)
    np.fill_diagonal(network_adj_matrix, 0)
    
    # Print debug info
    if network_type_internal == "Custom Adjacency Matrix":
        print("Network adjacency matrix before creating graph:")
        print(f"Shape: {network_adj_matrix.shape}")
        print(f"Sum of elements: {np.sum(network_adj_matrix)}")
        print(f"Number of non-zero elements: {np.count_nonzero(network_adj_matrix)}")
        print(f"Sample of matrix: {network_adj_matrix[:3, :3] if network_adj_matrix.shape[0] >= 3 else network_adj_matrix}")
        
        # Ensure the adjacency matrix has proper values for building a network
        # Some users might enter very small values (like 0.01) that don't register as edges
        # Convert anything > 0.1 to a definite edge to ensure network is visible
        adj_for_network = network_adj_matrix.copy()
        adj_for_network[adj_for_network > 0.1] = 1.0
        if np.count_nonzero(adj_for_network) != np.count_nonzero(network_adj_matrix):
            print(f"Enhancing {np.count_nonzero(adj_for_network) - np.count_nonzero(network_adj_matrix)} weak connections for visualization")
        
        # Use the enhanced matrix for network visualization only
        G = nx.from_numpy_array(adj_for_network)
    else:
        # Use original matrix for standard network types
        G = nx.from_numpy_array(network_adj_matrix)
    
    # Create custom colormap that matches our gradient_text1 theme for nodes
    custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                ["#9933FF", "#FF33FF", "#FFAA00", "#50FF96"], 
                                                N=256)
    
    # Sort oscillators by their natural frequency for consistent coloring
    # This is the SAME color assignment used throughout all visualizations
    sorted_indices = np.argsort(frequencies)
    color_indices = np.linspace(0, 1, n_oscillators)
    oscillator_colors = np.zeros(n_oscillators, dtype=object)
    
    # Assign colors based on frequency order
    for i, idx in enumerate(sorted_indices):
        oscillator_colors[idx] = custom_cmap(color_indices[i])
    
    # Choose layout based on network type
    if network_type_internal == "Nearest Neighbor":
        # Circular layout for nearest neighbor (ring)
        pos = nx.circular_layout(G)
    # Special case for the Etz Hayim (Tree of Life) matrix - 10x10 matrix with specific structure
    elif network_type_internal == "Custom Adjacency Matrix" and network_adj_matrix.shape[0] == 10 and np.count_nonzero(network_adj_matrix) >= 40:
        # This appears to be our special Etz Hayim matrix - use a custom tree-like layout
        # Create a dictionary with fixed positions for this specific matrix
        # These positions follow a traditional Sephirotic tree arrangement with improved spacing
        fixed_positions = {
            0: (0.0, 1.0),     # Keter (Crown) - top position
            1: (-0.4, 0.8),    # Chokhmah (Wisdom) - upper right
            2: (0.4, 0.8),     # Binah (Understanding) - upper left
            3: (-0.7, 0.4),    # Chesed (Kindness) - middle right
            4: (0.7, 0.4),     # Gevurah (Strength) - middle left
            5: (0.0, 0.4),     # Tiferet (Beauty) - center
            6: (-0.7, 0.0),    # Netzach (Victory) - lower right
            7: (0.7, 0.0),     # Hod (Splendor) - lower left
            8: (0.0, -0.4),    # Yesod (Foundation) - bottom center
            9: (0.0, -0.8)     # Malkhut (Kingdom) - bottom
        }
        pos = fixed_positions
        
        # Add a note that we're using the special layout
        st.info("Using special 'Etz Hayim' (Tree of Life) layout for this adjacency matrix.")
    elif n_oscillators <= 20:
        # Spring layout for smaller networks
        pos = nx.spring_layout(G, seed=current_random_seed)
    else:
        # Circular layout is better for visualization with many nodes
        pos = nx.circular_layout(G)
    
    # Create graph visualization
    ax1.set_facecolor('#121212')
    
    # Debug information about the graph
    print(f"Graph info: nodes={len(G.nodes())}, edges={len(G.edges())}")
    if len(G.edges()) == 0:
        print("WARNING: Graph has no edges! Check adjacency matrix values.")
        # Force at least some edges for visualization by creating a ring
        temp_G = nx.cycle_graph(network_adj_matrix.shape[0])
        pos = nx.circular_layout(temp_G)
        edges = nx.draw_networkx_edges(temp_G, pos, ax=ax1, alpha=0.7,
                                  edge_color='#ff5500', width=1.5, 
                                  style='dashed')  # Use orange dashed lines to indicate fallback
        # Add warning to graph
        ax1.text(0.5, 0.5, "Warning: No edges detected in custom matrix\nShowing placeholder network",
              horizontalalignment='center', verticalalignment='center',
              transform=ax1.transAxes, color='#ff5500', fontsize=14)
    else:
        # Draw the graph with dark blue edges to match adjacency matrix
        edges = nx.draw_networkx_edges(G, pos, ax=ax1, alpha=0.7, 
                                   edge_color='#0070db', width=1.5)
    
    # Convert the RGBA colors to hex for networkx
    node_colors = []
    for c in oscillator_colors:
        # Create hex color from the custom colormap colors
        if hasattr(c, 'tolist'):  # If it's a numpy array
            rgba = c.tolist()
        else:  # If it's already a tuple/list
            rgba = c
        # Format as hex
        node_colors.append(f"#{int(rgba[0]*255):02x}{int(rgba[1]*255):02x}{int(rgba[2]*255):02x}")
    
    # Calculate dynamic node size based on number of nodes
    # Larger size for fewer nodes, smaller size for many nodes
    n_nodes = len(G.nodes)
    # Adjusted node size to be moderately sized - not too big, not too small
    node_size = max(150, int(800 * (1 / (0.12 * n_nodes + 0.6))))  # Balanced node size
    
    # Generate brighter versions of node colors for edges
    bright_node_colors = []
    for color in node_colors:
        # Convert hex to RGB and make it brighter
        r = int(color[1:3], 16)
        g = int(color[3:5], 16)
        b = int(color[5:7], 16)
        # Make RGB values brighter (closer to white)
        r = min(255, int(r * 1.5))
        g = min(255, int(g * 1.5))
        b = min(255, int(b * 1.5))
        bright_node_colors.append(f"#{r:02x}{g:02x}{b:02x}")
    
    # No glow effect for network nodes to keep the visualization clean
    
    # Draw the main nodes on top of glow effects
    nodes = nx.draw_networkx_nodes(G, pos, ax=ax1, 
                               node_color=node_colors, 
                               node_size=node_size, alpha=0.9, 
                               edgecolors=bright_node_colors, linewidths=1.0)
    
    # Add node labels only if there are relatively few nodes
    if n_oscillators <= 15:
        labels = {i: str(i) for i in range(n_oscillators)}
        nx.draw_networkx_labels(G, pos, labels=labels, ax=ax1, 
                           font_color='white', font_weight='bold')
        
    # Add title and styling
    ax1.set_title(f'Oscillator Network Graph ({network_type_internal})', 
               color='white', fontsize=14, pad=15)
    ax1.set_axis_off()
    
    # Add a legend explaining node colors with brighter outline
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.0), 
                markeredgecolor='#ae56ff', markersize=10, label='Lowest frequency (violet)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.33), 
                markeredgecolor='#ff50ff', markersize=10, label='Lower frequency (magenta)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.67), 
                markeredgecolor='#ffc060', markersize=10, label='Higher frequency (orange)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(1.0), 
                markeredgecolor='#70e898', markersize=10, label='Highest frequency (green)')
    ]
    ax1.legend(handles=legend_elements, loc='upper right', 
            frameon=True, framealpha=0.7, facecolor='#121212', 
            edgecolor='#555555', labelcolor='white')
    
    # Create a heatmap of the adjacency matrix using blue gradient
    # Create a custom blue colormap for the adjacency matrix (swapped light/dark and adjusted intensity)
    blue_cmap = LinearSegmentedColormap.from_list("adj_matrix_blue", 
                                             ["#00c2dd", "#109ae8", "#0070db"], 
                                             N=256)
    # Apply custom colormap - dark blue for 0s, light blue for 1s
    # Using binary data without text annotations
    im = ax2.imshow(network_adj_matrix, cmap=blue_cmap, interpolation='nearest')
    plt.colorbar(im, ax=ax2, label='Connection Strength')
    
    # Remove the actual 0/1 text annotations by turning off tick labels
    ax2.set_xticks([])
    ax2.set_yticks([])
    
    # Add labels and styling
    ax2.set_title('Adjacency Matrix', color='white', fontsize=14)
    ax2.set_xlabel('Oscillator Index', color='white')
    ax2.set_ylabel('Oscillator Index', color='white')
    
    # Set background color
    ax2.set_facecolor('#1a1a1a')
    fig.patch.set_facecolor('#121212')
    
    # Add a grid to help distinguish cells
    ax2.grid(False)
    
    # Add text annotations for connection strength (only for matrices smaller than 15x15)
    if n_oscillators <= 12:
        for i in range(network_adj_matrix.shape[0]):
            for j in range(network_adj_matrix.shape[1]):
                if network_adj_matrix[i, j] > 0:
                    ax2.text(j, i, f"{network_adj_matrix[i, j]:.1f}", 
                          ha="center", va="center", 
                          color="white" if network_adj_matrix[i, j] < 0.7 else "black",
                          fontsize=9)
    
    # Adjust spacing between subplots
    plt.tight_layout()
    
    # Display the figure
    st.pyplot(fig)
    
    # Special description for Etz Hayim matrix
    if network_type_internal == "Custom Adjacency Matrix" and network_adj_matrix.shape[0] == 10 and np.count_nonzero(network_adj_matrix) >= 40:
        st.markdown("""
        <div class='section'>
            <p>Figure Description:</p>
            <ul>
                <li><b>Left:</b> Graph representing the ten Sephirot (emanations) in the Kabbalistic Tree of Life, arranged in their traditional positions</li>
                <li><b>Right:</b> Adjacency matrix showing the 22 paths connecting the Sephirot</li>
            </ul>
            <p>The nodes represent (from top to bottom, right to left):</p>
            <ol>
                <li>Keter (Crown) - Will and the origin of divine revelation</li>
                <li>Chokhmah (Wisdom) - Beginning of conscious thought</li>
                <li>Binah (Understanding) - Processing and understanding</li>
                <li>Chesed (Kindness) - Expansion, loving kindness</li>
                <li>Gevurah (Strength) - Restriction, judgment and discipline</li>
                <li>Tiferet (Beauty) - Harmony, balance, integration</li>
                <li>Netzach (Victory) - Endurance and overcoming</li>
                <li>Hod (Splendor) - Surrender, sincerity, and gratitude</li>
                <li>Yesod (Foundation) - Connection and bonding force</li>
                <li>Malkhut (Kingdom) - Physical manifestation and action</li>
            </ol>
            <p>This structure offers a fascinating system to study synchronization patterns across interconnected oscillators.</p>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div class='section'>
            <p>Figure Description:</p>
            <ul>
                <li><b>Left:</b> Graph representation of oscillator connections, with nodes colored by natural frequency</li>
                <li><b>Right:</b> Adjacency matrix representation, where each cell (i,j) represents the connection strength between oscillators</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)

########################
# TAB 2: DISTRIBUTIONS TAB
########################
with tab2:
    # Update current tab in session state
    st.session_state.current_tab = "Distributions"
    st.markdown("<h2 class='gradient_text2'>Initial Distributions</h2>", unsafe_allow_html=True)
    
    # Display simulation information at the top
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Add the distribution histograms
    dist_col1, dist_col2 = st.columns(2)
    
    # Define a consistent figure size for both histograms
    hist_figsize = (4.0, 3.0)
    
    with dist_col1:
        st.markdown("<h4 class='gradient_text2'>Natural Frequency Distribution</h4>", unsafe_allow_html=True)
        
        # Create frequency distribution histogram
        fig_freq, ax_freq = plt.subplots(figsize=hist_figsize)
        
        # Use a gradient colormap for the histogram
        n_bins = 15
        counts, bin_edges = np.histogram(frequencies, bins=n_bins)
        
        # Create custom colormap that matches our gradient theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                ["#00ffff", "#00aaff"], 
                                                N=256)
        
        # Create custom colors with a gradient effect that matches our theme
        colors = custom_cmap(np.linspace(0.1, 0.9, n_bins))
        
        # Plot the histogram with gradient colors and outline
        bars = ax_freq.bar(
            (bin_edges[:-1] + bin_edges[1:]) / 2, 
            counts, 
            width=(bin_edges[1] - bin_edges[0]) * 0.9,
            color=colors, 
            alpha=0.8,
            edgecolor='white',
            linewidth=0.5
        )
        
        # Add a soft glow effect behind bars
        for bar, color in zip(bars, colors):
            x = bar.get_x()
            width = bar.get_width()
            height = bar.get_height()
            glow = plt.Rectangle(
                (x - width * 0.05, 0), 
                width * 1.1, 
                height, 
                color=color,
                alpha=0.3,
                zorder=-1
            )
            ax_freq.add_patch(glow)
        
        # Enhance the axes and labels
        ax_freq.set_facecolor('#1a1a1a')
        ax_freq.set_xlabel('Natural Frequency', fontsize=12, fontweight='bold', color='white')
        ax_freq.set_ylabel('Count', fontsize=12, fontweight='bold', color='white')
        ax_freq.set_title(f'Natural Frequency Distribution ({freq_type})', 
                       fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Add mean frequency marker
        mean_freq = np.mean(frequencies)
        ax_freq.axvline(x=mean_freq, color='#ff5555', linestyle='-', linewidth=2, alpha=0.7,
                      label=f'Mean: {mean_freq:.2f}')
        ax_freq.legend(framealpha=0.7)
        
        # Customize grid
        ax_freq.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add a subtle box around the plot
        for spine in ax_freq.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        st.pyplot(fig_freq)
        
        # Distribution properties description
        st.markdown(f"""
        <div class='section' style='font-size: 0.85em;'>
            <p><b>Mean:</b> {np.mean(frequencies):.4f}</p>
            <p><b>Standard Deviation:</b> {np.std(frequencies):.4f}</p>
            <p><b>Min:</b> {np.min(frequencies):.4f}</p>
            <p><b>Max:</b> {np.max(frequencies):.4f}</p>
        </div>
        """, unsafe_allow_html=True)
    
    with dist_col2:
        st.markdown("<h4 class='gradient_text2'>Initial Phase Distribution</h4>", unsafe_allow_html=True)
        
        # Create initial phase distribution histogram with matching size
        fig_init_phase, ax_init_phase = plt.subplots(figsize=hist_figsize)
        
        initial_phases = phases[:, 0] % (2 * np.pi)
        
        # Use a gradient colormap for the histogram
        n_bins = 15
        counts, bin_edges = np.histogram(initial_phases, bins=n_bins)
        
        # Create custom colors with a gradient effect that matches our theme
        colors = custom_cmap(np.linspace(0.1, 0.9, n_bins))
        
        # Plot the histogram with gradient colors and outline
        bars = ax_init_phase.bar(
            (bin_edges[:-1] + bin_edges[1:]) / 2, 
            counts, 
            width=(bin_edges[1] - bin_edges[0]) * 0.9,
            color=colors, 
            alpha=0.8,
            edgecolor='white',
            linewidth=0.5
        )
        
        # Add a soft glow effect behind bars
        for bar, color in zip(bars, colors):
            x = bar.get_x()
            width = bar.get_width()
            height = bar.get_height()
            glow = plt.Rectangle(
                (x - width * 0.05, 0), 
                width * 1.1, 
                height, 
                color=color,
                alpha=0.3,
                zorder=-1
            )
            ax_init_phase.add_patch(glow)
        
        # Enhance the axes and labels
        ax_init_phase.set_facecolor('#1a1a1a')
        ax_init_phase.set_xlabel('Phase (mod 2Ï€)', fontsize=12, fontweight='bold', color='white')
        ax_init_phase.set_ylabel('Count', fontsize=12, fontweight='bold', color='white')
        ax_init_phase.set_title('Initial Phase Distribution (t=0)', 
                             fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Calculate initial order parameter
        initial_r = order_parameter[0]
        initial_psi = np.angle(np.sum(np.exp(1j * initial_phases))) % (2 * np.pi)
        
        # Always add mean phase marker with red vertical line
        ax_init_phase.axvline(x=initial_psi, color='#ff5555', linestyle='-', linewidth=2, alpha=0.7,
                           label=f'Mean Phase: {initial_psi:.2f}')
        ax_init_phase.legend(framealpha=0.7)
        
        # Customize grid
        ax_init_phase.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add a subtle box around the plot
        for spine in ax_init_phase.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        st.pyplot(fig_init_phase)
        
        # Initial phase properties description
        st.markdown(f"""
        <div class='section' style='font-size: 0.85em;'>
            <p><b>Initial Order Parameter:</b> {initial_r:.4f}</p>
            <p><b>Initial Mean Phase:</b> {initial_psi:.4f}</p>
        </div>
        """, unsafe_allow_html=True)

########################
# TAB 3: ANIMATION TAB
########################
with tab3:
    # Update current tab in session state
    st.session_state.current_tab = "Animation"
    st.markdown("<h2 class='gradient_text2'>Interactive Animation</h2>", unsafe_allow_html=True)
    
    # Display simulation information at the top
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Create oscillator visualization
    
    # Initialize time_index in session state if not present
    if 'time_index' not in st.session_state:
        st.session_state.time_index = 0
        
    # Set time index from session state
    time_index = st.session_state.time_index
    
    # Safety check to prevent index out of bounds errors
    max_valid_index = len(times) - 1
    if time_index > max_valid_index:
        # Reset the time index to a valid value
        time_index = max_valid_index
        st.session_state.time_index = max_valid_index
        st.warning(f"Time index was reset to maximum value ({max_valid_index})")
    
    # Initialize animation variables
    animate = False
    animation_speed = 3.0
    
    # Get time and order parameter values for the current time index (now with bounds checking)
    current_time = times[time_index]
    current_r = order_parameter[time_index]
    
    # Import needed module
    
    # Function to create the phase visualization
    def create_phase_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        # Create visualization with enhanced visuals for dark theme
        fig_circle = plt.figure(figsize=(5, 5))
        ax_circle = fig_circle.add_subplot(111)
        
        # Add background glow effect
        bg_circle = plt.Circle((0, 0), 1.1, fill=True, color='#121a24', alpha=0.6, zorder=1)
        ax_circle.add_patch(bg_circle)
        
        # Add subtle circle rings for reference in white to match unit circle
        for radius in [0.25, 0.5, 0.75]:
            ring = plt.Circle((0, 0), radius, fill=False, color='#ffffff', 
                            linestyle=':', alpha=0.25, zorder=2)
            ax_circle.add_patch(ring)
        
        # Draw unit circle with glow effect - using white
        circle_glow = plt.Circle((0, 0), 1.02, fill=False, color='#ffffff', alpha=0.3, linewidth=3, zorder=3)
        ax_circle.add_patch(circle_glow)
        
        # Main unit circle in white
        circle = plt.Circle((0, 0), 1, fill=False, color='#ffffff', linestyle='-', 
                         linewidth=1.5, alpha=0.8, zorder=4)
        ax_circle.add_patch(circle)
        
        # Plot oscillators - with bounds checking
        # Make sure we're using a valid time index
        safe_time_idx = max_valid_idx
        
        # Safety check for phase data dimensions
        if safe_time_idx < phases.shape[1]:
            phases_at_time = phases[:, safe_time_idx]
            x = np.cos(phases_at_time)
            y = np.sin(phases_at_time)
        else:
            # Fallback to initial phases if time index is beyond data
            initial_phases = phases[:, 0]
            x = np.cos(initial_phases)
            y = np.sin(initial_phases)
            # Show a warning in the plot
            ax_circle.text(0, 0, "Invalid time index", 
                         ha='center', va='center', color='red', fontsize=12)
        
        # Create custom colormap that matches our gradient_text1 theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                     ["#8A2BE2", "#FF00FF", "#FFA500", "#50C878"], 
                                                     N=256)
        
        # Sort oscillators by their natural frequency
        sorted_indices = np.argsort(frequencies)
        # Create colors based on frequency ordering
        color_indices = np.linspace(0, 1, n_oscillators)
        colors = [custom_cmap(idx) for idx in color_indices]
        
        # Map colors to oscillators by frequency order
        oscillator_colors = np.zeros((n_oscillators, 4))  # RGBA colors
        for i, idx in enumerate(sorted_indices):
            oscillator_colors[idx] = colors[i]
        
        # Enhanced scatter plot with oscillator colors - with reduced glow effect
        # Create slightly brighter versions of the colors for outlines and glow
        bright_oscillator_colors = np.copy(oscillator_colors)
        for i in range(len(bright_oscillator_colors)):
            # Make RGB values brighter (closer to white) but preserve alpha - reduced from 1.7 to 1.3
            bright_oscillator_colors[i, :3] = np.minimum(1.0, bright_oscillator_colors[i, :3] * 1.3)  # 30% brighter
        
        # First add a smaller glow effect for each oscillator
        for i in range(n_oscillators):
            # Reduced size from 0.11 to 0.07 and alpha from 0.3 to 0.2
            glow = plt.Circle((x[i], y[i]), 0.07, fill=True, 
                          color=oscillator_colors[i], alpha=0.2, zorder=7)
            ax_circle.add_patch(glow)
            
        # Add a subtle pulse effect with smaller secondary glow (or remove if too much)
        for i in range(n_oscillators):
            # Reduced size from 0.14 to 0.09 and alpha from 0.15 to 0.1
            second_glow = plt.Circle((x[i], y[i]), 0.09, fill=True, 
                               color=bright_oscillator_colors[i], alpha=0.1, zorder=6)
            ax_circle.add_patch(second_glow)
        
        # Use custom edge colors and increased size for main points - slightly smaller
        sc = ax_circle.scatter(x, y, facecolors=oscillator_colors, edgecolors=bright_oscillator_colors, s=180, 
                         alpha=0.9, linewidth=1.3, zorder=10)
        
        # Calculate and show order parameter
        r = order_parameter[time_idx]
        psi = np.angle(np.sum(np.exp(1j * phases_at_time)))
        
        # Draw arrow showing mean field with glow effect - using bright blue color
        # First add glow/shadow
        ax_circle.arrow(0, 0, r * np.cos(psi), r * np.sin(psi), 
                       head_width=0.07, head_length=0.12, fc='#00c2ff', ec='#00c2ff', 
                       width=0.03, alpha=0.3, zorder=5)
        
        # Then add main arrow
        ax_circle.arrow(0, 0, r * np.cos(psi), r * np.sin(psi), 
                       head_width=0.05, head_length=0.1, fc='#00a5ff', ec='#00a5ff', 
                       width=0.02, zorder=6)
        
        # Draw axes
        ax_circle.axhline(y=0, color='#555555', linestyle='-', alpha=0.5, zorder=0)
        ax_circle.axvline(x=0, color='#555555', linestyle='-', alpha=0.5, zorder=0)
        
        ax_circle.set_xlim(-1.2, 1.2)
        ax_circle.set_ylim(-1.2, 1.2)
        ax_circle.set_aspect('equal')
        
        # Add subtle grid
        ax_circle.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Enhance title
        ax_circle.set_title(f'Oscillators at t={times[time_idx]:.2f}', 
                          color='white', fontsize=14, pad=15)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
        
        return fig_circle
    
    # Function to create oscillator phases over time plot (as dots)
    def create_oscillator_phases_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        fig, ax = plt.subplots(figsize=(12, 3.5))
        
        # Add background
        ax.set_facecolor('#1a1a1a')
        
        # Create transparent bands at phase regions
        for y in [0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi]:
            ax.axhspan(y-0.1, y+0.1, color='#222233', alpha=0.4, zorder=0)
        
        # Create custom colormap that matches our gradient_text1 theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                     ["#8A2BE2", "#FF00FF", "#FFA500", "#50C878"], 
                                                     N=256)
        
        # Sort oscillators by their natural frequency for consistent coloring
        sorted_indices = np.argsort(frequencies)
        color_indices = np.linspace(0, 1, n_oscillators)
        oscillator_colors = np.zeros(n_oscillators, dtype=object)
        
        # Assign colors based on frequency order
        for i, idx in enumerate(sorted_indices):
            oscillator_colors[idx] = custom_cmap(color_indices[i])
        
        # Use the safety bounds check variable
        safe_time_idx = max_valid_idx
        
        # Plot all oscillators as dots up to the current time point
        for i in range(n_oscillators):
            color = oscillator_colors[i]
            
            # Create a brighter version of the color for edge
            # Extract RGB values and make them brighter
            rgb = matplotlib.colors.to_rgb(color)
            # Create brighter version (closer to white)
            bright_color = tuple(min(1.0, c * 1.5) for c in rgb)
            
            # Plot oscillator phases as filled dots with color gradient
            ax.scatter(times[:safe_time_idx+1], phases[i, :safe_time_idx+1] % (2 * np.pi), 
                     facecolors=color, edgecolor=bright_color, alpha=0.7, s=50, 
                     linewidth=0.5, zorder=5)
            
            # Add a subtle connecting line with low opacity
            ax.plot(times[:safe_time_idx+1], phases[i, :safe_time_idx+1] % (2 * np.pi), 
                  color=color, alpha=0.2, linewidth=0.8, zorder=2)
            
            # Highlight current position with a larger filled marker
            ax.scatter([times[safe_time_idx]], [phases[i, safe_time_idx] % (2 * np.pi)], 
                     s=140, facecolors=color, edgecolor=bright_color, 
                     linewidth=1.0, zorder=15)
        
        # Add labels for key phase positions
        phase_labels = [(0, '0'), (np.pi/2, 'Ï€/2'), (np.pi, 'Ï€'), (3*np.pi/2, '3Ï€/2'), (2*np.pi, '2Ï€')]
        for y, label in phase_labels:
            ax.annotate(label, xy=(-0.02, y), xycoords=('axes fraction', 'data'),
                      fontsize=11, color='white', ha='center', va='center')
        
        # Plot styling
        ax.set_xlabel('Time', fontsize=13, fontweight='bold', color='white')
        ax.set_ylabel('Phase (mod 2Ï€)', fontsize=13, fontweight='bold', color='white')
        ax.set_title(f'Oscillator Phases at t={times[safe_time_idx]:.2f}', 
                   fontsize=14, fontweight='bold', color='white', pad=15)
        ax.set_ylim(0, 2 * np.pi)
        ax.set_yticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
        ax.set_yticklabels(['0', 'Ï€/2', 'Ï€', '3Ï€/2', '2Ï€'])
        ax.set_xlim(times.min(), times.max())
        
        # Custom grid
        ax.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add box around the plot
        for spine in ax.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
            
        return fig
    
    # Create a function to create order parameter plot over time (as a dot plot)
    def create_order_parameter_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        fig, ax = plt.subplots(figsize=(5, 5))
        
        # Add background gradient
        ax.set_facecolor('#1a1a1a')
        
        # Add subtle horizontal bands for visual reference
        for y in np.linspace(0, 1, 6):
            ax.axhspan(y-0.05, y+0.05, color='#222233', alpha=0.3, zorder=0)
        
        # Create a custom colormap that matches the blue gradient used in the sidebar
        cmap = LinearSegmentedColormap.from_list("order_param", 
                                             ["#00c2dd", "#109ae8", "#0070db"], 
                                             N=256)
        
        # Use the safe index for all references
        safe_time_idx = max_valid_idx
        
        # Plot order parameter with filled gradient dots and brighter outline
        base_colors = [cmap(r) for r in order_parameter[:safe_time_idx+1]]
        edge_colors = []
        
        # Create brighter versions of each color for the outlines
        for color in base_colors:
            rgb = matplotlib.colors.to_rgb(color)
            # Make RGB values brighter but preserve alpha
            bright_color = tuple(min(1.0, c * 1.5) for c in rgb)
            edge_colors.append(bright_color)
        
        scatter = ax.scatter(times[:safe_time_idx+1], order_parameter[:safe_time_idx+1],
                          facecolors=base_colors, edgecolors=edge_colors,
                          s=70, alpha=0.9, linewidth=0.5, zorder=10)
        
        # Removed connecting line as requested
        
        # Highlight current position with a larger filled marker
        if safe_time_idx > 0:
            # Get color and make brighter version for outline
            current_color = cmap(order_parameter[safe_time_idx])
            rgb = matplotlib.colors.to_rgb(current_color)
            bright_current = tuple(min(1.0, c * 1.5) for c in rgb)
            
            ax.scatter([times[safe_time_idx]], [order_parameter[safe_time_idx]], 
                     s=180, facecolors=current_color, 
                     edgecolors=bright_current, 
                     linewidth=1.0, zorder=15)
        
        # Add highlights at important thresholds
        ax.axhline(y=0.5, color='#aaaaaa', linestyle='--', alpha=0.5, zorder=1, 
                 label='Partial Synchronization (r=0.5)')
        ax.axhline(y=0.8, color='#ffffff', linestyle='--', alpha=0.5, zorder=1,
                 label='Strong Synchronization (r=0.8)')
        
        # Enhance the plot appearance
        ax.set_xlim(times.min(), times.max())
        ax.set_ylim(0, 1.05)
        ax.set_xlabel('Time', fontsize=13, fontweight='bold', color='white')
        ax.set_ylabel('Order Parameter r(t)', fontsize=13, fontweight='bold', color='white')
        ax.set_title(f'Phase Synchronization at t={times[safe_time_idx]:.2f}', 
                   fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Create custom grid
        ax.grid(True, color='#333333', alpha=0.5, linestyle=':')
        
        # Legend removed as requested
        
        # Add subtle box around the plot
        for spine in ax.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
            
        return fig
    
    # Create a more space-efficient layout 
    # First row: Oscillator phases plot (wider view)
    phases_plot_placeholder = st.empty()
    phases_plot_placeholder.pyplot(create_oscillator_phases_plot(time_index))
    
    # Second row: Circle plot and order parameter side by side
    col1, col2 = st.columns(2)
    with col1:
        circle_plot_placeholder = st.empty()
        circle_plot_placeholder.pyplot(create_phase_plot(time_index))
    
    with col2:
        order_plot_placeholder = st.empty()
        order_plot_placeholder.pyplot(create_order_parameter_plot(time_index))
    
    # Removed "Current Time" display as requested
    
    # Put animation controls first (at the top) with proper containment
    st.markdown("<h4 style='margin-bottom: 20px;'>Animation Controls</h4>", unsafe_allow_html=True)
    
    # Create a container for the buttons to ensure they stay together
    button_container = st.container()
    
    # Create centered columns for control buttons within the container
    with button_container:
        # Use wider columns for the buttons to center them better
        bcol1, bcol2, bcol3, bcol4, bcol5 = st.columns([1, 3, 3, 3, 1])
    
        # Set a fixed animation speed value for smoother playback
        animation_speed = 5.0  # Faster speed for smoother animation
        
        # Previous frame button
        if bcol2.button("âª Previous", use_container_width=True):
            if st.session_state.time_index > 0:
                st.session_state.time_index -= 1
                st.rerun()
        
        # Simplified Play/Pause button with text inside
        play_button_text = "â¯ï¸ Play"
        if bcol3.button(play_button_text, use_container_width=True):
            # Toggle animation state
            animate = True
            # Let the animation code run
        
        # Next frame button 
        if bcol4.button("â© Next", use_container_width=True):
            if st.session_state.time_index < len(times) - 1:
                st.session_state.time_index += 1
                st.rerun()
    
    # Create a separate container for time step display
    time_info_container = st.container()
    with time_info_container:
        time_col1, time_col2, time_col3 = st.columns([1, 2, 1])
        # Create a placeholder for displaying time step info 
        current_time_placeholder = time_col2.empty()
        
        # Function to update time step display
        def update_time_step_display(time_idx):
            # Calculate the actual time step (difference between consecutive time points)
            if time_idx > 0:
                time_step = times[time_idx] - times[time_idx-1]
            else:
                # Use first difference for the first point
                if len(times) > 1:
                    time_step = times[1] - times[0]
                else:
                    time_step = 0
                    
            current_time = times[time_idx]
            current_percent = (time_idx / (len(times) - 1)) * 100
            
            # Update the placeholder with the time step information
            current_time_placeholder.markdown(f"""
            <div style="padding: 10px; border-radius: 5px; background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(255, 0, 255, 0.2)); 
                        border: 1px solid rgba(255, 255, 255, 0.1); text-align: center;">
                <span style="font-size: 0.85rem; color: white;">Î”t = {time_step:.5f}</span><br>
                <span style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.7);">t = {current_time:.3f}</span>
            </div>
            """, unsafe_allow_html=True)
    
    # Initial display of time step
    update_time_step_display(st.session_state.time_index)
    
    # Add a slider to manually control visualization time point AFTER the buttons
    playback_container = st.container()
    time_index = playback_container.slider(
        "Time Point", 
        min_value=0, 
        max_value=len(times)-1, 
        value=st.session_state.time_index,
        help="Manually select a specific time point to display"
    )
    
    # Update session state when slider is moved
    if st.session_state.time_index != time_index:
        st.session_state.time_index = time_index
            
    # If animation is triggered
    if animate:
        # Get the current time index as the starting point
        start_idx = st.session_state.time_index
        
        # Ensure we're not starting beyond the available data
        max_valid_index = len(times) - 1
        if start_idx > max_valid_index:
            start_idx = 0
            st.session_state.time_index = 0
        
        # Calculate how many frames to skip for smoother animation
        frame_skip = max(1, len(times) // 100)  # Skip more frames for smoother playback
        
        # Set up a progress bar
        progress_bar = st.progress(0)
        
        # Animation loop with bounds checking
        for i in range(start_idx, min(len(times), max_valid_index + 1), frame_skip):
            # Update the session state
            st.session_state.time_index = i
            
            # Update progress bar - with safeguards to prevent division by zero
            denominator = max(1, max_valid_index - start_idx)  # Ensure non-zero denominator
            progress = min(1.0, (i - start_idx) / denominator)
            progress_bar.progress(progress)
            
            # Update all three plots
            # Safety checks for index values
            plot_idx = min(i, max_valid_index)
            circle_plot_placeholder.pyplot(create_phase_plot(plot_idx))
            phases_plot_placeholder.pyplot(create_oscillator_phases_plot(plot_idx))
            order_plot_placeholder.pyplot(create_order_parameter_plot(plot_idx))
            
            # Update the time step display with the current time index
            update_time_step_display(plot_idx)
            
            # Add a short pause to control animation speed
            time.sleep(0.02 / animation_speed)  # Much faster frame updates
        
        # Clear progress bar after animation
        progress_bar.empty()
    
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Visualization Guide</h3>
        <p>The <b>top plot</b> shows oscillator phases over time. Each horizontal trace represents one oscillator's phase trajectory with consistent coloring based on the oscillator's natural frequency.</p>
        <p>The <b>bottom left plot</b> shows oscillators on a unit circle. Each colored dot represents an oscillator at its current phase position. The blue arrow shows the mean field vector, with length equal to the order parameter r.</p>
        <p>The <b>bottom right plot</b> shows the order parameter over time, with color-coded dots showing the synchronization level from 0 (no synchronization) to 1 (complete synchronization).</p>
        <p>Click "â¯ï¸ Play" to watch all three visualizations animate together to see the synchronization process in real-time.</p>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Order Parameter Analysis</h3>
        <p>The order parameter r(t) measures the degree of synchronization among oscillators:</p>
        <ul>
            <li>r = 1: Complete synchronization (all oscillators have the same phase)</li>
            <li>r = 0: Complete desynchronization (phases are uniformly distributed)</li>
        </ul>
        <p>At critical coupling strength (K_c), the system transitions from desynchronized to partially synchronized state.</p>
    </div>
    """, unsafe_allow_html=True)

########################
# TAB 4: NUMERICAL CONSIDERATIONS TAB
########################
with tab4:
    # Update current tab in session state to track which tab is active
    st.session_state.current_tab = "Numerical Considerations"
    st.markdown("""
    <div class='section'>
    <ul>
        <li>The animation uses an explicit RK45 integrator with an adaptive, heuristically chosen maximum step size.</li>
        <li>No formal error or stability bounds are provided, however extreme coupling strengths, highly non-uniform frequency distributions, or large time steps may lead to numerical instability.</li>
        <li>For production-level accuracy, one should compare against sympletic or implicit schemes, tighten tolerances, and perform systematic convergence tests.</li>
        <li>Note that the time step is automatically calculated based on oscillator frequencies to ensure numerical stability and accuracy.</li>
    </ul>
    </div>
    """, unsafe_allow_html=True)

=== attached_assets/Pasted--Kuramoto-Model-Simulator-Network-Distributions-Animation-Interactive-Animation-Simulation-1745649535047.txt ===






Kuramoto Model Simulator

Network


Distributions


Animation

Interactive Animation
Simulation Information
Oscillators: 10 | Coupling Strength: 1.0 | Network Type: Random
0
0
0
Animation Controls



Î”t = 0.05003
t = 0.000
Time Point

0
1999
Visualization Guide
The top plot shows oscillator phases over time. Each horizontal trace represents one oscillator's phase trajectory with consistent coloring based on the oscillator's natural frequency.

The bottom left plot shows oscillators on a unit circle. Each colored dot represents an oscillator at its current phase position. The blue arrow shows the mean field vector, with length equal to the order parameter r.

The bottom right plot shows the order parameter over time, with color-coded dots showing the synchronization level from 0 (no synchronization) to 1 (complete synchronization).

Click "â¯ï¸ Play" to watch all three visualizations animate together to see the synchronization process in real-time.

Order Parameter Analysis
The order parameter r(t) measures the degree of synchronization among oscillators:

r = 1: Complete synchronization (all oscillators have the same phase)
r = 0: Complete desynchronization (phases are uniformly distributed)
At critical coupling strength (K_c), the system transitions from desynchronized to partially synchronized state.

Connection error
Connection failed with status 502, and response "<!DOCTYPE html>

<html lang="en"> <head> <title>Hmm... We couldn&#39;t reach this app</title> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans"> <style> body { margin: 0; height: 100vh; display: flex; justify-content: center; align-items: center; background: #1c2333; font-family: "IBM Plex Sans", "sans"; color: #f5f9fc; }
.title-box {
  font-size: 12px;
  inline-size: max-content;
  max-width: 100%;
}

.description-box {
  font-size: 10px;
  inline-size: max-content;
  max-width: 100%;
}

.err-box {
  padding: 1em;
  width: 100vw;
  max-width: 100vw;
  overflow: hidden;
}

.message {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.ascii {
  font-size: 6px;
  text-align: center;
  opacity: .8;
}

.eval-bot {
  margin: 4em;
}

@media (max-width: 500px) {
  .title-box {
    font-size: 10px;
  }

  .description-box {
    font-size: 8px;
  }

  .eval-bot {
    margin: 1em;
  }

  .eval-bot svg {
    width: 200px;
  }

  .message {
    flex-direction: column;
    align-items: center;
  }

  .repl-links {
    font-size: 14px;
  }
}

.console {
  background-color: #0e1628;
  color: #fff;
  font-family: "IBM Plex Sans", "sans";
  padding: 1em;
  margin: 1em;
}

.footer-item {
  margin: 1em;
  display: flex;
  justify-content: center;
  align-items: center;
}

.link-icon {
  margin-right: 8px;
  margin-top: 4px;
}

a {
  color: #c2c8cc;
}

</style> <script> var reload_timeout = setTimeout(function () { window.location.reload(); }, 60000); </script> </head> <body> <div class="err-box"> <div class="message"> <div class="eval-bot"> <pre class="ascii"> :::. :+++***++:.. :-=+=..:-=+**=======---: -+++****+====-::-=====-::. .. .. :: .=++++++=::----------::-::::::--------===--:.:::::. :--==+++=-::----------======----------:-===-:::::::. ::--==+++-----=+++=+++++====----======--==------:: ::::-====+++++++*************+==========---------::.. ..:::---==++*****************+++++++++=------------:::::.. ....:::-=+**********************++++++=--==========--:..... ..:::-++*********+**************+++++++--+***++++==: .::.. :=+*+=+++****++==+++*+++++++***+++++++++***********+=. .::-====-::--: .:-=++=====+++*++====++++++++++++++++++=+++*************+=======++++==--. .--==-----=====++=============+=+++=====++++****************+=+=========--:. . . :--====------=======--==========+++=====++++****+*****+****++===------====-. ...::::::::---====----------::::::-----========++++++++++***++++++++===--:::::-----. ...::::::..:::::---::::::::::...::::::::-----=++++++++++****+++++++===-:::::::::---: .::::.....:::::::::::................:::::=++++++++++*****++++++=====---:::::---::. ...... ......... ...............::=+==++++++++++++++============-----::...: ........::---===-===============------=---:::::::::... .......................::::::::---------:. .. ....................::::::--:::::. ...........
</pre>
  </div>
  <div class="title-box">
    <h1>Hmm... We couldn&#39;t reach this app</h1>
  </div>
  <div class="description-box">
    <h2>Make sure this app has a port open and is ready to receive HTTP traffic.</h2>
  </div>
</div>

<div>
  <div class="footer-item">
    <div class="link-icon">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          d="M6.66668 8.66666C6.95298 9.04942 7.31825 9.36612 7.73771 9.59529C8.15717 9.82446 8.62102 9.96074 9.09778 9.99489C9.57454 10.029 10.0531 9.96024 10.5009 9.79319C10.9487 9.62613 11.3554 9.36471 11.6933 9.02666L13.6933 7.02666C14.3005 6.39799 14.6365 5.55598 14.6289 4.68199C14.6213 3.808 14.2708 2.97196 13.6527 2.35394C13.0347 1.73591 12.1987 1.38535 11.3247 1.37775C10.4507 1.37016 9.60869 1.70614 8.98001 2.31333L7.83334 3.45333M9.33334 7.33333C9.04704 6.95058 8.68177 6.63388 8.26231 6.4047C7.84285 6.17553 7.37901 6.03925 6.90224 6.00511C6.42548 5.97096 5.94695 6.03975 5.49911 6.20681C5.05128 6.37387 4.6446 6.63528 4.30668 6.97333L2.30668 8.97333C1.69948 9.602 1.3635 10.444 1.3711 11.318C1.37869 12.192 1.72926 13.028 2.34728 13.6461C2.96531 14.2641 3.80135 14.6147 4.67534 14.6222C5.54933 14.6298 6.39134 14.2939 7.02001 13.6867L8.16001 12.5467"
          stroke="#C2C8CC" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </div>
    <div class="repl-links">
      <a href="https://replit.com">Go to Replit</a>
    </div>
  </div>

  <div class="footer-item">
    <div class="link-icon">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          d="M6.66668 8.66666C6.95298 9.04942 7.31825 9.36612 7.73771 9.59529C8.15717 9.82446 8.62102 9.96074 9.09778 9.99489C9.57454 10.029 10.0531 9.96024 10.5009 9.79319C10.9487 9.62613 11.3554 9.36471 11.6933 9.02666L13.6933 7.02666C14.3005 6.39799 14.6365 5.55598 14.6289 4.68199C14.6213 3.808 14.2708 2.97196 13.6527 2.35394C13.0347 1.73591 12.1987 1.38535 11.3247 1.37775C10.4507 1.37016 9.60869 1.70614 8.98001 2.31333L7.83334 3.45333M9.33334 7.33333C9.04704 6.95058 8.68177 6.63388 8.26231 6.4047C7.84285 6.17553 7.37901 6.03925 6.90224 6.00511C6.42548 5.97096 5.94695 6.03975 5.49911 6.20681C5.05128 6.37387 4.6446 6.63528 4.30668 6.97333L2.30668 8.97333C1.69948 9.602 1.3635 10.444 1.3711 11.318C1.37869 12.192 1.72926 13.028 2.34728 13.6461C2.96531 14.2641 3.80135 14.6147 4.67534 14.6222C5.54933 14.6298 6.39134 14.2939 7.02001 13.6867L8.16001 12.5467"
          stroke="#C2C8CC" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </div>
    <div class="repl-links">
      <a href="https://replit.com/site/hosting">Learn more about hosting on Replit</a>
    </div>
  </div>
</div>

</div> </body> </html> ".

=== attached_assets/Pasted--Main-styling-for-the-entire-application-body-font-family-Aclonica-sans-serif-ma-1744622504278.txt ===

/* Main styling for the entire application */
body {
    font-family: 'Aclonica', sans-serif;
    margin: 0;
    padding: 0;
    color: white;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

/* Gradient text styles */
.gradient_text1 {
    font-weight: bold;
    background: -webkit-linear-gradient(#14a5ff, #8138ff);
    -webkit-background-clip: text;
    color: transparent;
    background-clip: text;
    text-align: center;
}

.gradient_text2 {
    font-weight: bold;
    background: linear-gradient(#00ffee, #27aaff);
    color: transparent;
    -webkit-background-clip: text;
    background-clip: text;
}

/* Feature box for projects and resources */
.feature-box {
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 25px; /* Increased from 20px to 25px */
    margin-bottom: 20px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    backdrop-filter: blur(5px);
    display: flex;
    flex-direction: column;
    height: 100%;
}

.feature-box:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.feature-box-content {
    color: white;
    display: flex;
    flex-direction: column;
    height: 100%;
    justify-content: space-between;
    text-align: left; /* Left-align the text content */
    align-items: flex-start; /* Align items to the start (left) */
}

.feature-box-content h3 {
    color: #22f793;
    margin-top: 0;
    font-size: 1.5rem;
    width: 100%; /* Ensure full width */
    text-align: center; /* Keep headings centered */
}

.feature-box-content p {
    margin-bottom: 15px;
    width: 100%; /* Ensure full width */
}

/* Card row layout for horizontal alignment */
.card-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: center; /* Center the cards in their container */
    gap: 20px;
    margin-bottom: 30px;
}

.card-row .feature-box {
    flex: 0 1 400px; /* Increased from 350px to 400px for even wider cards */
    margin: 0 10px 15px 10px; /* Added horizontal margin for better spacing */
}

/* 3 cards per row maximum on large screens */
@media (min-width: 1200px) {
    .card-row .feature-box {
        flex-basis: calc(45% - 30px); /* Increased to 45% for much wider cards */
        max-width: calc(45% - 30px);
    }
}

/* 2 cards per row on medium screens */
@media (max-width: 1199px) and (min-width: 768px) {
    .card-row .feature-box {
        flex-basis: calc(45% - 30px); /* Increased to 45% for wider cards */
        max-width: calc(45% - 30px);
    }
}

/* 2 cards per row on small screens */
@media (max-width: 767px) and (min-width: 480px) {
    .card-row .feature-box {
        flex-basis: calc(80% - 20px); /* Increased from 45% to 80% for wider cards */
        max-width: calc(80% - 20px);
    }
}

/* Single column on very small screens */
@media (max-width: 479px) {
    .card-row {
        flex-direction: column;
        align-items: center; /* Center the cards */
    }
    
    .card-row .feature-box {
        flex-basis: 90%; /* Not full width to keep some margins */
        max-width: 90%;
    }
}

/* Contact links styling */
.contact-links {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 20px 0;
}

.contact-links a {
    color: #22f793;
    text-decoration: none;
    transition: color 0.3s ease;
}

.contact-links a:hover {
    color: #0a95eb;
    text-decoration: underline;
}

/* Project and resource sections */
.projects-section {
    margin: 40px 0;
}

/* Button Styling */
.btn {
    background-image: linear-gradient(to right, #00ffee, #27aaff);
    box-shadow: 0 4px 15px 0 rgba(39, 170, 255, 0.5);
    width: 90%;
    max-width: 200px;
    font-size: 16px;
    font-weight: 600;
    color: white;
    cursor: pointer;
    margin: 10px auto;
    height: 55px;
    text-align: center;
    border: none;
    background-size: 300% 100%;
    border-radius: 50px;
    transition: all .4s ease-in-out;
    font-family: 'Aclonica', sans-serif;
    display: block;
    text-decoration: none;
    line-height: 55px;
}

.btn:hover {
    background-position: 100% 0;
    filter: brightness(1.1);
    transition: all .4s ease-in-out;
}

.feature-box-content .btn {
    width: 100%;
    max-width: none;
    margin-top: auto;
    align-self: center; /* Center the button */
}

/* Typography improvements */
h1, h2, h3, h4, p, div, span, a, button, input, textarea, select {
    font-family: 'Aclonica', sans-serif;
}

/* Links */
a {
    color: #22f793;
    text-decoration: none;
    transition: color 0.3s;
}

a:hover {
    color: #0a95eb;
}

/* Tooltip styles */
.tooltip-container {
    position: relative;
    display: inline-block;
    width: 100%;
}

.tooltip-content {
    visibility: hidden;
    width: 100%;
    background: rgba(10, 10, 20, 0.9);
    color: #fff;
    text-align: left; /* Keep tooltip text left-aligned for readability */
    border-radius: 6px;
    padding: 15px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 0;
    opacity: 0;
    transition: opacity 0.3s, transform 0.3s;
    transform: translateY(10px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
}

.tooltip-container:hover .tooltip-content {
    visibility: visible;
    opacity: 1;
    transform: translateY(0);
}

.tooltip-content::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 15%;
    margin-left: -8px;
    border-width: 8px;
    border-style: solid;
    border-color: rgba(10, 10, 20, 0.9) transparent transparent transparent;
}

.tech-tag {
    display: inline-block;
    background: linear-gradient(130deg, rgba(34, 247, 147, 0.2), rgba(10, 149, 235, 0.2));
    border: 1px solid rgba(34, 247, 147, 0.3);
    border-radius: 15px;
    padding: 3px 10px;
    margin: 3px;
    font-size: 0.8rem;
    color: white;
}

/* Technology Icons Container */
.tech-icons {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 10px;
    gap: 10px;
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.4s ease, transform 0.4s ease;
    position: absolute;
    bottom: -40px;
    left: 0;
    width: 100%;
}

.feature-box:hover .tech-icons {
    opacity: 1;
    transform: translateY(0);
}

/* Technology Icon Style */
.tech-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: linear-gradient(145deg, rgba(34, 247, 147, 0.2), rgba(10, 149, 235, 0.3));
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 1.2rem;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    cursor: default;
}

.tech-icon:hover {
    transform: translateY(-5px) scale(1.1);
    box-shadow: 0 5px 15px rgba(10, 149, 235, 0.3);
    background: linear-gradient(145deg, rgba(34, 247, 147, 0.4), rgba(10, 149, 235, 0.5));
}

/* Make space for icons under feature box */
.feature-box {
    margin-bottom: 50px; /* Increased to make room for the tech icons */
    position: relative; /* Needed for absolute positioning of tech icons */
}

=== attached_assets/Pasted--box-sizing-border-box-body-font-family-Aclonica-serif-margin-0-paddi-1744621860792.txt ===

* {
    box-sizing: border-box;
}

body {
    font-family: Aclonica, serif;
    margin: 0;
    padding: 0;
}

label,
main {
    background: var(--bg, white);
    color: var(--text, black);
}

main {
    --gradDark: hsl(144, 100%, 89%);
    --gradLight: hsl(42, 94%, 76%);
    background-image: url(https://assets.codepen.io/7124932/wispbackground.jpg?format=auto);
    padding: 120px 40px 40px 40px;
    min-height: 100vh;
    text-align: center;
    position: relative;
}

.gradient_text1 {
    font-weight: bold;
    background: -webkit-linear-gradient(#14a5ff, #8138ff);
    -webkit-background-clip: text;
    color: transparent;
    background-clip: text;
    text-align: center;
}

.gradient_text2 {
    font-weight: bold;
    background: linear-gradient(#00ffee, #27aaff);
    color: transparent;
    -webkit-background-clip: text;
}

.wrapper {
    max-width: 700px;
    margin: 0 auto;
}

.theme-switch-container {
    position: absolute;
    top: 20px;
    right: 50px;
    z-index: 1;
}

.theme-switch__input {
    opacity: 0;
    position: absolute;
}

.theme-switch__label {
    display: inline-block;
    padding: 10px;
    transition: background-color 200ms ease-in-out;
    width: 120px;
    height: 50px;
    border-radius: 25px;
    text-align: center;
    background-color: slateGray;
    box-shadow: -4px 4px 15px inset rgba(0, 0, 0, 0.4);
    position: relative;
    cursor: pointer;
}

.theme-switch__label::before,
.theme-switch__label::after {
    font-size: 1.5rem;
    position: absolute;
    transform: translate3d(0, -50%, 0);
    top: 50%;
}

.theme-switch__label::before {
    content: '\263C';
    right: 100%;
    margin-right: 10px;
    color: orange;
}

.theme-switch__label::after {
    content: '\263E';
    left: 100%;
    margin-left: 10px;
    color: lightSlateGray;
}

.theme-switch__label span {
    display: inline-block;
    position: relative;
    color: white;
}

.theme-switch__label span::after {
    position: absolute;
    top: -2px;
    left: -55px;
    width: 40px;
    height: 40px;
    content: '';
    border-radius: 50%;
    background: linear-gradient(135deg, #00ffee, #27aaff);
    transition: transform 200ms, background-color 200ms;
    box-shadow: -3px 3px 8px rgba(0, 0, 0, 0.4);
    transform: translateY(-50%);
}

.theme-switch__input:checked ~ .theme-switch__label {
    background-color: lightSlateGray;
}

.theme-switch__input:checked ~ .theme-switch__label::before {
    color: lightSlateGray;
}

.theme-switch__input:checked ~ .theme-switch__label::after {
    color: turquoise;
}

.theme-switch__input:checked ~ .theme-switch__label span::after {
    transform: translate3d(70px, -50%, 0);
}



.section {
    margin: 40px 0;
    padding: 20px;
    border: 2px solid #ccc;
    border-radius: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.section-content {
    padding: 20px;
}

.section h2 {
    font-size: 2rem;
    margin-bottom: 20px;
}

.project, .resource {
    margin-bottom: 20px;
    padding: 20px;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 8px;
    border: 1px solid #ddd;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

=== attached_assets/Pasted-Connection-error-Connection-failed-with-status-502-and-response-DOCTYPE-html-html-lang-en--1745651772588.txt ===

Connection error
Connection failed with status 502, and response "<!DOCTYPE html>

<html lang="en"> <head> <title>Hmm... We couldn&#39;t reach this app</title> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans"> <style> body { margin: 0; height: 100vh; display: flex; justify-content: center; align-items: center; background: #1c2333; font-family: "IBM Plex Sans", "sans"; color: #f5f9fc; }
.title-box {
  font-size: 12px;
  inline-size: max-content;
  max-width: 100%;
}

.description-box {
  font-size: 10px;
  inline-size: max-content;
  max-width: 100%;
}

.err-box {
  padding: 1em;
  width: 100vw;
  max-width: 100vw;
  overflow: hidden;
}

.message {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.ascii {
  font-size: 6px;
  text-align: center;
  opacity: .8;
}

.eval-bot {
  margin: 4em;
}

@media (max-width: 500px) {
  .title-box {
    font-size: 10px;
  }

  .description-box {
    font-size: 8px;
  }

  .eval-bot {
    margin: 1em;
  }

  .eval-bot svg {
    width: 200px;
  }

  .message {
    flex-direction: column;
    align-items: center;
  }

  .repl-links {
    font-size: 14px;
  }
}

.console {
  background-color: #0e1628;
  color: #fff;
  font-family: "IBM Plex Sans", "sans";
  padding: 1em;
  margin: 1em;
}

.footer-item {
  margin: 1em;
  display: flex;
  justify-content: center;
  align-items: center;
}

.link-icon {
  margin-right: 8px;
  margin-top: 4px;
}

a {
  color: #c2c8cc;
}

</style> <script> var reload_timeout = setTimeout(function () { window.location.reload(); }, 60000); </script> </head> <body> <div class="err-box"> <div class="message"> <div class="eval-bot"> <pre class="ascii"> :::. :+++***++:.. :-=+=..:-=+**=======---: -+++****+====-::-=====-::. .. .. :: .=++++++=::----------::-::::::--------===--:.:::::. :--==+++=-::----------======----------:-===-:::::::. ::--==+++-----=+++=+++++====----======--==------:: ::::-====+++++++*************+==========---------::.. ..:::---==++*****************+++++++++=------------:::::.. ....:::-=+**********************++++++=--==========--:..... ..:::-++*********+**************+++++++--+***++++==: .::.. :=+*+=+++****++==+++*+++++++***+++++++++***********+=. .::-====-::--: .:-=++=====+++*++====++++++++++++++++++=+++*************+=======++++==--. .--==-----=====++=============+=+++=====++++****************+=+=========--:. . . :--====------=======--==========+++=====++++****+*****+****++===------====-. ...::::::::---====----------::::::-----========++++++++++***++++++++===--:::::-----. ...::::::..:::::---::::::::::...::::::::-----=++++++++++****+++++++===-:::::::::---: .::::.....:::::::::::................:::::=++++++++++*****++++++=====---:::::---::. ...... ......... ...............::=+==++++++++++++++============-----::...: ........::---===-===============------=---:::::::::... .......................::::::::---------:. .. ....................::::::--:::::. ...........
</pre>
  </div>
  <div class="title-box">
    <h1>Hmm... We couldn&#39;t reach this app</h1>
  </div>
  <div class="description-box">
    <h2>Make sure this app has a port open and is ready to receive HTTP traffic.</h2>
  </div>
</div>

<div>
  <div class="footer-item">
    <div class="link-icon">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          d="M6.66668 8.66666C6.95298 9.04942 7.31825 9.36612 7.73771 9.59529C8.15717 9.82446 8.62102 9.96074 9.09778 9.99489C9.57454 10.029 10.0531 9.96024 10.5009 9.79319C10.9487 9.62613 11.3554 9.36471 11.6933 9.02666L13.6933 7.02666C14.3005 6.39799 14.6365 5.55598 14.6289 4.68199C14.6213 3.808 14.2708 2.97196 13.6527 2.35394C13.0347 1.73591 12.1987 1.38535 11.3247 1.37775C10.4507 1.37016 9.60869 1.70614 8.98001 2.31333L7.83334 3.45333M9.33334 7.33333C9.04704 6.95058 8.68177 6.63388 8.26231 6.4047C7.84285 6.17553 7.37901 6.03925 6.90224 6.00511C6.42548 5.97096 5.94695 6.03975 5.49911 6.20681C5.05128 6.37387 4.6446 6.63528 4.30668 6.97333L2.30668 8.97333C1.69948 9.602 1.3635 10.444 1.3711 11.318C1.37869 12.192 1.72926 13.028 2.34728 13.6461C2.96531 14.2641 3.80135 14.6147 4.67534 14.6222C5.54933 14.6298 6.39134 14.2939 7.02001 13.6867L8.16001 12.5467"
          stroke="#C2C8CC" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </div>
    <div class="repl-links">
      <a href="https://replit.com">Go to Replit</a>
    </div>
  </div>

  <div class="footer-item">
    <div class="link-icon">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          d="M6.66668 8.66666C6.95298 9.04942 7.31825 9.36612 7.73771 9.59529C8.15717 9.82446 8.62102 9.96074 9.09778 9.99489C9.57454 10.029 10.0531 9.96024 10.5009 9.79319C10.9487 9.62613 11.3554 9.36471 11.6933 9.02666L13.6933 7.02666C14.3005 6.39799 14.6365 5.55598 14.6289 4.68199C14.6213 3.808 14.2708 2.97196 13.6527 2.35394C13.0347 1.73591 12.1987 1.38535 11.3247 1.37775C10.4507 1.37016 9.60869 1.70614 8.98001 2.31333L7.83334 3.45333M9.33334 7.33333C9.04704 6.95058 8.68177 6.63388 8.26231 6.4047C7.84285 6.17553 7.37901 6.03925 6.90224 6.00511C6.42548 5.97096 5.94695 6.03975 5.49911 6.20681C5.05128 6.37387 4.6446 6.63528 4.30668 6.97333L2.30668 8.97333C1.69948 9.602 1.3635 10.444 1.3711 11.318C1.37869 12.192 1.72926 13.028 2.34728 13.6461C2.96531 14.2641 3.80135 14.6147 4.67534 14.6222C5.54933 14.6298 6.39134 14.2939 7.02001 13.6867L8.16001 12.5467"
          stroke="#C2C8CC" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </div>
    <div class="repl-links">
      <a href="https://replit.com/site/hosting">Learn more about hosting on Replit</a>
    </div>
  </div>
</div>

</div> </body> </html> ".

=== attached_assets/Pasted-TypeError-Cannot-cast-scalar-from-dtype-float64-to-dtype-int64-according-to-the-rule-safe-T-1745197673005.txt ===

TypeError: Cannot cast scalar from dtype('float64') to dtype('int64') according to the rule 'safe'
Traceback:
File "/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/exec_code.py", line 121, in exec_func_with_error_handling
    result = func()
             ^^^^^^
File "/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 640, in code_to_exec
    exec(code, module.__dict__)
File "/home/runner/workspace/app.py", line 603, in <module>
    model, times, phases, order_parameter = run_simulation(
                                            ^^^^^^^^^^^^^^^
File "/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 219, in __call__
    return self._get_or_create_cached_value(args, kwargs, spinner_message)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 261, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 320, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "/home/runner/workspace/app.py", line 571, in run_simulation
    model = KuramotoModel(
            ^^^^^^^^^^^^^^
File "/home/runner/workspace/kuramoto_model.py", line 33, in __init__
    np.random.seed(random_seed)
File "numpy/random/mtrand.pyx", line 4829, in numpy.random.mtrand.seed
File "numpy/random/mtrand.pyx", line 254, in numpy.random.mtrand.RandomState.seed
File "_mt19937.pyx", line 168, in numpy.random._mt19937.MT19937._legacy_seeding
File "_mt19937.pyx", line 188, in numpy.random._mt19937.MT19937._legacy_seeding

=== attached_assets/Pasted-with-col2-st-subheader-Initial-Oscillator-Positions-fig-plot-initial-positions-system--1744623511889.txt ===

with col2:
    st.subheader("Initial Oscillator Positions")
    fig = plot_initial_positions(system, sefirot, scale_factor)
    st.pyplot(fig)

# Solve system
if st.button("Run Simulation", use_container_width=True, key='run_sim'):
    # Create placeholder containers
    plot_container = st.empty()
    progress_bar = st.progress(0)
    
    # Solve the system
    t, P = system.solve(tmax)
    r, psi, q_sum = system.compute_order_parameter()
    
    # Create animation figure
    animation_data = create_animation_figure(system, sefirot, scale_factor)
    fig, ax1, ax2, ax3, ax4, scatter1, scatter2, scatter3, scatter4, colors = animation_data
    
    # Initialize frames list for GIF export
    frames = []
    total_frames = len(t)
    
    # Calculate effective frames based on frame_skip
    effective_frames = range(0, total_frames, frame_skip)
    
    for idx, frame in enumerate(effective_frames):
        # Update progress
        progress = frame / total_frames
        progress_bar.progress(progress)
        
        # Update animation frame
        fig = update_animation_frame(
            frame, t, P, q_sum, r, sefirot, 
            fig, ax1, ax2, ax3, ax4, 
            scatter1, scatter2, scatter3, scatter4, colors
        )
        
        # Display the frame
        plot_container.pyplot(fig)
        
        # Capture frame for GIF with improved quality
        fig.canvas.draw()
        
        # Use higher quality buffer conversion for smoother animation
        image = np.frombuffer(fig.canvas.buffer_rgba(), dtype=np.uint8)
        image = image.reshape(fig.canvas.get_width_height()[::-1] + (4,))
        # Preserve alpha channel for better quality
        frames.append(image[:,:,:3])
        
        # Small pause for smoother rendering (uses variable FPS)
        plt.pause(1.0/fps)
    
    # Final cleanup
    progress_bar.progress(1.0)
    
    # Create export directory
    export_dir = create_export_directory()
    
    # Export simulation data
    export_simulation_data(export_dir, system, t, P, r, psi, q_sum, A, selected_preset, sefirot)
    
    # Export visualization
    fig.savefig(f"{export_dir}/final_state.png", dpi=150)
    
    # Export animation with improved settings
    export_animation(export_dir, frames, fps=fps, quality=animation_quality)
    
    st.success(f"Simulation completed and exported to {export_dir}")
    
    # Display network structure visualization
    st.subheader("Network Structure Visualization")
    fig, ax = plt.subplots(figsize=(8, 6))
    
    # Generate a circular layout for the graph
    pos = nx.circular_layout(G)
    
    # Draw the graph with node labels
    nx.draw(G, pos, with_labels=True, node_color='lightblue', 
            node_size=500, edge_color='gray', width=1.5, alpha=0.8,
            labels={i: sefirot[i] for i in range(N)}, font_size=8, font_weight='bold',
            ax=ax)
    
    st.pyplot(fig)
    
    # Display final statistics
    st.subheader("Simulation Statistics")
    final_order = r[-1]
    st.metric("Final Order Parameter", f"{final_order:.4f}", 
             delta=f"{final_order - r[0]:.4f}", 
             delta_color="normal")
    
    # Create rich club metric
    rich_club = rich_club_metric(A, 3)  # Nodes with degree >= 3
    st.metric("Rich Club Coefficient (kâ‰¥3)", f"{rich_club:.4f}")

=== backups/checkpoint_before_refactor/app.py ===

import streamlit as st

# Set page config must be the first Streamlit command
st.set_page_config(
    page_title="Kuramoto Model Simulator",
    page_icon="ðŸ”„",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Let's strip down all CSS in the app to the minimum needed
st.markdown("""
<style>
    /* No special styling - let Streamlit's defaults handle alignment */
</style>
""", unsafe_allow_html=True)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors
from matplotlib.colors import LinearSegmentedColormap
import json
from src.models.kuramoto_model import KuramotoModel
from src.database.database import save_configuration
import time

# Initialize refresh state for network refresh button
if 'refresh_network' not in st.session_state:
    st.session_state.refresh_network = False

# Function to parse JSON parameters input
def parse_json_parameters(json_string):
    """
    Parse a JSON string containing Kuramoto simulation parameters.
    
    Expected format:
    {
        "n_oscillators": 10,
        "coupling_strength": 1.0,
        "network_type": "All-to-All", 
        "simulation_time": 10.0,
        "time_step": 0.1,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.2
        },
        "adjacency_matrix": [[0,1,1,...], [1,0,1,...], ...] (optional)
    }
    
    Returns:
    dict: Parameters dictionary containing all parsed values, or error message
    """
    try:
        # Parse the JSON string
        params = json.loads(json_string)
        
        # Initialize the result dictionary with default values
        result = {
            "n_oscillators": 10,
            "coupling_strength": 1.0,
            "network_type": "All-to-All",
            "simulation_time": 10.0,
            "time_step": 0.1,
            "random_seed": 42,
            "frequency_distribution": "Normal",
            "frequency_parameters": {
                "mean": 0.0,
                "std": 0.2
            },
            "adjacency_matrix": None
        }
        
        # Update with values from the JSON
        if "n_oscillators" in params:
            result["n_oscillators"] = int(params["n_oscillators"])
            
        if "coupling_strength" in params:
            result["coupling_strength"] = float(params["coupling_strength"])
            
        if "network_type" in params:
            valid_types = ["All-to-All", "Nearest Neighbor", "Random", "Custom Adjacency Matrix"]
            if params["network_type"] in valid_types:
                result["network_type"] = params["network_type"]
            
        if "simulation_time" in params:
            result["simulation_time"] = float(params["simulation_time"])
            
        # time_step is now automatically calculated based on oscillator frequencies
        # We keep this for backward compatibility with existing JSON configs
        if "time_step" in params:
            # We acknowledge the parameter but don't use it directly
            pass
            
        if "random_seed" in params:
            result["random_seed"] = int(params["random_seed"])
            
        if "frequency_distribution" in params:
            valid_distributions = ["Normal", "Uniform", "Custom", "Golden Ratio", "Bimodal"]
            if params["frequency_distribution"] in valid_distributions:
                result["frequency_distribution"] = params["frequency_distribution"]
            
        if "frequency_parameters" in params:
            fp = params["frequency_parameters"]
            if "mean" in fp and result["frequency_distribution"] == "Normal":
                result["frequency_parameters"]["mean"] = float(fp["mean"])
            if "std" in fp and result["frequency_distribution"] == "Normal":
                result["frequency_parameters"]["std"] = float(fp["std"])
            if "min" in fp and result["frequency_distribution"] == "Uniform":
                result["frequency_parameters"]["min"] = float(fp["min"])
            if "max" in fp and result["frequency_distribution"] == "Uniform":
                result["frequency_parameters"]["max"] = float(fp["max"])
            if "custom_values" in fp and result["frequency_distribution"] == "Custom":
                # Convert custom frequency values to floats
                result["frequency_parameters"]["custom_values"] = [float(x) for x in fp["custom_values"]]
        
        # Process the adjacency matrix if provided
        if "adjacency_matrix" in params:
            matrix_data = params["adjacency_matrix"]
            if isinstance(matrix_data, list) and len(matrix_data) > 0:
                try:
                    # Convert to numpy array and validate
                    adj_matrix = np.array(matrix_data, dtype=float)
                    
                    # Check if the matrix is square
                    if adj_matrix.shape[0] == adj_matrix.shape[1]:
                        result["adjacency_matrix"] = adj_matrix
                        # If adjacency matrix is provided, force network type to Custom
                        result["network_type"] = "Custom Adjacency Matrix"
                    else:
                        return None, f"Adjacency matrix must be square. Current shape: {adj_matrix.shape}"
                except Exception as e:
                    return None, f"Error processing adjacency matrix: {str(e)}"
        
        return result, None
        
    except Exception as e:
        # Return error message if parsing fails
        return None, str(e)

# Initialize session state for configuration loading
if 'loaded_config' not in st.session_state:
    st.session_state.loaded_config = None

# Check for temp imported parameters and apply them
# This handles imports from the JSON Parameter Import Section
if 'temp_imported_params' in st.session_state:
    params = st.session_state.temp_imported_params
    
    # Update session state with the parsed parameters
    st.session_state.n_oscillators = params["n_oscillators"]
    st.session_state.coupling_strength = params["coupling_strength"]
    st.session_state.network_type = params["network_type"]
    st.session_state.simulation_time = params["simulation_time"]
    # time_step is no longer used, it's automatically calculated
    st.session_state.random_seed = params["random_seed"]
    st.session_state.freq_type = params["frequency_distribution"]
    
    # Update frequency parameters based on distribution type
    if params["frequency_distribution"] == "Normal":
        st.session_state.freq_mean = params["frequency_parameters"]["mean"]
        st.session_state.freq_std = params["frequency_parameters"]["std"]
    elif params["frequency_distribution"] == "Uniform":
        st.session_state.freq_min = params["frequency_parameters"]["min"]
        st.session_state.freq_max = params["frequency_parameters"]["max"]
    elif params["frequency_distribution"] == "Custom" and "custom_values" in params["frequency_parameters"]:
        st.session_state.custom_freqs = ", ".join(str(x) for x in params["frequency_parameters"]["custom_values"])
    
    # Handle custom adjacency matrix if present
    if params["adjacency_matrix"] is not None:
        matrix = params["adjacency_matrix"]
        
        # Convert matrix to string representation for the text area
        matrix_str = ""
        for row in matrix:
            matrix_str += ", ".join(str(val) for val in row) + "\n"
        
        # Update session state for adjacency matrix
        st.session_state.adj_matrix_input = matrix_str.strip()
        st.session_state.loaded_adj_matrix = matrix
    
    # Clear the temp parameters to avoid reapplying
    del st.session_state.temp_imported_params

# Apply loaded configuration if available
if st.session_state.loaded_config is not None:
    config = st.session_state.loaded_config
    
    # Update session state with configuration values
    st.session_state.n_oscillators = config['n_oscillators']
    st.session_state.coupling_strength = config['coupling_strength']
    st.session_state.simulation_time = config['simulation_time']
    # time_step is no longer needed - it's automatically calculated
    st.session_state.random_seed = int(config['random_seed']) # Ensure it's an integer
    st.session_state.network_type = config['network_type']
    st.session_state.freq_type = config['frequency_distribution']
    
    # Update frequency distribution parameters based on type
    freq_params = config.get('frequency_params', {})
    if freq_params:
        try:
            freq_params = json.loads(freq_params)
        except:
            # It's already a dictionary
            pass
            
        if config['frequency_distribution'] == "Normal":
            st.session_state.freq_mean = freq_params.get('mean', 0.0)
            st.session_state.freq_std = freq_params.get('std', 1.0)
        elif config['frequency_distribution'] == "Uniform":
            st.session_state.freq_min = freq_params.get('min', -1.0)
            st.session_state.freq_max = freq_params.get('max', 1.0)
        elif config['frequency_distribution'] == "Bimodal":
            st.session_state.peak1 = freq_params.get('peak1', -1.0)
            st.session_state.peak2 = freq_params.get('peak2', 1.0)
        elif config['frequency_distribution'] == "Custom":
            if 'custom_values' in freq_params and isinstance(freq_params['custom_values'], list):
                st.session_state.custom_freqs = ', '.join(map(str, freq_params['custom_values']))
            elif 'values' in freq_params and isinstance(freq_params['values'], list):
                st.session_state.custom_freqs = ', '.join(map(str, freq_params['values']))
    
    # Handle custom adjacency matrix if present
    if config['network_type'] == "Custom Adjacency Matrix" and config.get('adjacency_matrix') is not None:
        try:
            matrix = config['adjacency_matrix']
            if isinstance(matrix, bytes):
                import pickle
                matrix = pickle.loads(matrix)
            elif isinstance(matrix, list):
                # Convert list to numpy array if it's still a list
                matrix = np.array(matrix)
            
            # Make sure no self-loops (diagonal elements should be zero)
            # This is important to ensure consistent visualization
            if hasattr(matrix, 'shape') and matrix.shape[0] == matrix.shape[1]:
                np.fill_diagonal(matrix, 0)
                
            # Print debug info
            print(f"Loading adjacency matrix: type={type(matrix)}, shape={matrix.shape if hasattr(matrix, 'shape') else 'unknown'}")
            
            if hasattr(matrix, 'shape'):
                print(f"Matrix sum: {np.sum(matrix)}, non-zeros: {np.count_nonzero(matrix)}")
                if matrix.shape[0] >= 3:
                    print("Sample (top-left 3x3):")
                    print(matrix[:3, :3])
                
            # Convert matrix to string representation for the text area
            matrix_str = ""
            for row in matrix:
                matrix_str += ", ".join(str(val) for val in row) + "\n"
            st.session_state.adj_matrix_input = matrix_str.strip()
            
            # Store the matrix for later use in this session
            # This ensures the matrix is properly passed to the simulation
            # Always update the matrix in session state - force overwrite to ensure latest is used
            st.session_state.loaded_adj_matrix = matrix
            print(f"Stored adjacency matrix in session state with shape {matrix.shape}")
                
        except Exception as e:
            st.warning(f"Could not load custom adjacency matrix: {str(e)}")
    
    # Clear the loaded config to prevent reapplying it on next rerun
    st.session_state.loaded_config = None

# Set up Matplotlib style for dark theme plots
plt.style.use('dark_background')
plt.rcParams.update({
    'axes.facecolor': '#1e1e1e',
    'figure.facecolor': '#1e1e1e',
    'savefig.facecolor': '#1e1e1e',
    'axes.grid': True,
    'grid.color': '#444444',
    'grid.alpha': 0.3,
    'grid.linestyle': '--',
    'axes.edgecolor': '#444444',
    'xtick.color': '#888888',
    'ytick.color': '#888888',
    'text.color': '#ffffff',
    'axes.labelcolor': '#ffffff',
    'axes.titlecolor': '#ffffff',
    'lines.linewidth': 2,
})

# Page config is now at the top of the file
# This comment is kept to maintain file structure

# Import Aclonica font from Google Fonts
st.markdown("""
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Aclonica&display=swap" rel="stylesheet">
""", unsafe_allow_html=True)

# Load custom CSS
with open("src/styles/styles.css") as f:
    st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)

# Get the base64 encoded image
with open("static/images/wisp.base64", "r") as f:
    encoded_image = f.read()

# Add custom background and custom font
st.markdown(f"""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Aclonica&display=swap');
    
    .stApp {{
        background-image: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), 
                         url('data:image/jpeg;base64,{encoded_image}');
        background-size: cover;
        background-repeat: no-repeat;
        background-attachment: fixed;
    }}
    
    /* Ensure Aclonica font is applied everywhere */
    body, div, p, h1, h2, h3, h4, h5, h6, li, span, label, button, .sidebar .sidebar-content {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Fix Streamlit buttons to use Aclonica */
    button, .stButton button, .stDownloadButton button {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Fix Streamlit widgets text */
    .stSlider label, .stSelectbox label, .stNumberInput label {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Apply gradient_text1 to sidebar labels */
    .sidebar .sidebar-content label {{
        background: -webkit-linear-gradient(#14a5ff, #8138ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: bold;
    }}
</style>
""", unsafe_allow_html=True)

# Title
st.markdown("<h1 class='gradient_text1'>Kuramoto Model Simulator</h1>", unsafe_allow_html=True)

# Let Streamlit handle the styling
# No custom CSS needed here

# Create main sidebar parameters header at the top
st.sidebar.markdown("<h2 class='gradient_text1'>Simulation Parameters</h2>", unsafe_allow_html=True)

# Add Time Controls Section first
st.sidebar.markdown("<h3 class='gradient_text1'>Time Controls</h3>", unsafe_allow_html=True)

# Simulation time parameters
simulation_time = st.sidebar.slider(
    "Simulation Time",
    min_value=1.0,
    max_value=200.0,
    value=100.0,  # Set default value to 100.0
    step=1.0,
    help="Total simulation time",
    key="simulation_time"
)

# Time step is now automatically calculated based on oscillator frequencies and doesn't need a UI control
# Default value maintained for backward compatibility with database functions
time_step = 0.01

# Add separator before individual parameters
st.sidebar.markdown("<hr style='margin: 15px 0px; border-color: rgba(255,255,255,0.2);'>", unsafe_allow_html=True)

# Create subheading for manual parameters
st.sidebar.markdown("<h3 class='gradient_text1'>Manual Configuration</h3>", unsafe_allow_html=True)

# Initialize session state for parameters if they don't exist
if 'n_oscillators' not in st.session_state:
    st.session_state.n_oscillators = 10
if 'coupling_strength' not in st.session_state:
    st.session_state.coupling_strength = 1.0
if 'freq_type' not in st.session_state:
    st.session_state.freq_type = "Normal"
if 'freq_mean' not in st.session_state:
    st.session_state.freq_mean = 0.0
if 'freq_std' not in st.session_state:
    st.session_state.freq_std = 1.0
if 'freq_min' not in st.session_state:
    st.session_state.freq_min = -1.0
if 'freq_max' not in st.session_state:
    st.session_state.freq_max = 1.0
if 'peak1' not in st.session_state:
    st.session_state.peak1 = -1.0
if 'peak2' not in st.session_state:
    st.session_state.peak2 = 1.0
if 'custom_freqs' not in st.session_state:
    st.session_state.custom_freqs = "0.5, 1.0, 1.5, 2.0, 2.5, 3.0, -0.5, -1.0, -1.5, -2.0"
if 'simulation_time' not in st.session_state:
    st.session_state.simulation_time = 100.0
# Default time_step value maintained for backward compatibility
time_step = 0.01
# network_type is now initialized in the network connectivity section
if 'adj_matrix_input' not in st.session_state:
    # Create a default example matrix for a 5x5 ring topology
    default_matrix = "0, 1, 0, 0, 1\n1, 0, 1, 0, 0\n0, 1, 0, 1, 0\n0, 0, 1, 0, 1\n1, 0, 0, 1, 0"
    st.session_state.adj_matrix_input = default_matrix

# For auto-adjusting oscillator count based on matrix dimensions
if 'next_n_oscillators' not in st.session_state:
    st.session_state.next_n_oscillators = None
    
# If we have a pending oscillator count update from the previous run, apply it now
if st.session_state.next_n_oscillators is not None:
    print(f"Updating oscillator count from {st.session_state.n_oscillators} to {st.session_state.next_n_oscillators}")
    st.session_state.n_oscillators = st.session_state.next_n_oscillators
    st.session_state.next_n_oscillators = None  # Clear the pending update

# Number of oscillators slider
n_oscillators = st.sidebar.slider(
    "Number of Oscillators",
    min_value=2,
    max_value=50,
    step=1,
    help="Number of oscillators in the system",
    key="n_oscillators"
)

# Coupling strength slider
coupling_strength = st.sidebar.slider(
    "Coupling Strength (K)",
    min_value=0.0,
    max_value=10.0,
    step=0.1,
    help="Strength of coupling between oscillators",
    key="coupling_strength"
)

# Frequency distribution type
freq_type = st.sidebar.selectbox(
    "Frequency Distribution",
    ["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"],
    index=["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"].index(st.session_state.freq_type) if st.session_state.freq_type in ["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"] else 0,
    help="Distribution of natural frequencies",
    key="freq_type"
)

# Parameters for frequency distribution
if freq_type == "Normal":
    freq_mean = st.sidebar.slider("Mean", -2.0, 2.0, step=0.1, key="freq_mean")
    freq_std = st.sidebar.slider("Standard Deviation", 0.1, 3.0, step=0.1, key="freq_std")
    frequencies = np.random.normal(freq_mean, freq_std, n_oscillators)
    
elif freq_type == "Uniform":
    freq_min = st.sidebar.slider("Minimum", -5.0, 0.0, step=0.1, key="freq_min")
    freq_max = st.sidebar.slider("Maximum", 0.0, 5.0, step=0.1, key="freq_max")
    frequencies = np.random.uniform(freq_min, freq_max, n_oscillators)
    
elif freq_type == "Bimodal":
    peak1 = st.sidebar.slider("Peak 1", -5.0, 0.0, step=0.1, key="peak1")
    peak2 = st.sidebar.slider("Peak 2", 0.0, 5.0, step=0.1, key="peak2")
    mix = np.random.choice([0, 1], size=n_oscillators)
    freq1 = np.random.normal(peak1, 0.3, n_oscillators)
    freq2 = np.random.normal(peak2, 0.3, n_oscillators)
    frequencies = mix * freq1 + (1 - mix) * freq2

elif freq_type == "Golden Ratio":
    # The golden ratio (phi) â‰ˆ 1.618033988749895
    phi = (1 + 5**0.5) / 2
    
    # Create a golden ratio sequence starting at -3
    golden_ratio_start = -3.0
    st.sidebar.markdown(f"""
    <div style="background-color: rgba(255,200,0,0.15); padding: 10px; border-radius: 5px;">
    <p><b>Golden Ratio Distribution</b></p>
    <p>This creates a sequence where each frequency follows the golden ratio (Ï† â‰ˆ 1.618), 
    starting from {golden_ratio_start}.</p>
    <p>Each oscillator's frequency is: {golden_ratio_start} + iÂ·Ï†</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Generate frequencies that follow the golden ratio in sequence
    frequencies = np.array([golden_ratio_start + i * phi for i in range(n_oscillators)])
    
else:  # Custom
    custom_freqs = st.sidebar.text_area(
        "Enter custom frequencies (comma-separated)",
        value=st.session_state.custom_freqs,
        height=150,
        key="custom_freqs"
    )
    try:
        frequencies = np.array([float(x.strip()) for x in custom_freqs.split(',')])
        # Ensure we have the right number of frequencies
        if len(frequencies) < n_oscillators:
            # Repeat the pattern if not enough values
            frequencies = np.tile(frequencies, int(np.ceil(n_oscillators / len(frequencies))))
        frequencies = frequencies[:n_oscillators]  # Trim if too many
    except:
        st.sidebar.error("Invalid frequency input. Using normal distribution instead.")
        frequencies = np.random.normal(0, 1, n_oscillators)

# Random seed setting
if "random_seed" not in st.session_state:
    st.session_state.random_seed = 42

random_seed = int(st.sidebar.number_input(
    "Random Seed", 
    min_value=0,
    step=1,
    help="Seed for reproducibility",
    key="random_seed"
))

# Network Connectivity Configuration
st.sidebar.markdown("<h3 class='gradient_text1'>Network Connectivity</h3>", unsafe_allow_html=True)

# Add a refresh button at the top of the Network Connectivity section
if st.sidebar.button("ðŸ”„ Refresh Simulation", key="refresh_btn"):
    st.session_state.refresh_network = True
    print("Network refresh requested via main refresh button")
    st.rerun()

# Create radio button for network type without specifying both index and session state key
# This fixes the warning: "widget created with default value but also had value set via Session State API"
options = ["All-to-All", "Nearest Neighbor", "Random", "Custom Adjacency Matrix"]
if "network_type" not in st.session_state:
    # Only set this if it's not already in session state
    st.session_state.network_type = "Random"

# Get current index
current_index = options.index(st.session_state.network_type)

# Create the radio button
network_type = st.sidebar.radio(
    "Network Type",
    options=options,
    index=current_index,
    help="Define how oscillators are connected to each other"
)

# Update session state if changed
if network_type != st.session_state.network_type:
    st.session_state.network_type = network_type

# Custom adjacency matrix input
adj_matrix = None
# Check if we have a loaded adjacency matrix from a configuration
if 'loaded_adj_matrix' in st.session_state:
    adj_matrix = st.session_state.loaded_adj_matrix
    print(f"Retrieved adjacency matrix from session state with shape {adj_matrix.shape if hasattr(adj_matrix, 'shape') else 'unknown'}")
    
    # Safety check to ensure matrix is valid
    if hasattr(adj_matrix, 'shape') and adj_matrix.shape[0] > 0:
        print(f"Matrix looks valid: shape={adj_matrix.shape}, sum={np.sum(adj_matrix)}, non-zeros={np.count_nonzero(adj_matrix)}")
        
        # CRITICAL: We need to force the correct network type
        # This needs to take precedence over what's selected in the UI radio button
        if network_type != "Custom Adjacency Matrix":
            print("Detected loaded matrix with network type that doesn't match 'Custom Adjacency Matrix'.")
            print(f"Current network_type is '{network_type}' but will use matrix internally")
    else:
        print("Warning: Found loaded_adj_matrix in session state but it appears invalid:")
        print(f"Matrix type: {type(adj_matrix)}")
        if hasattr(adj_matrix, 'shape'):
            print(f"Shape: {adj_matrix.shape}")
        adj_matrix = None  # Reset to None if invalid matrix

if network_type == "Custom Adjacency Matrix":
    st.sidebar.markdown("""
    <div style="font-size: 0.85em;">
    Enter your adjacency matrix as comma-separated values. Each row should be on a new line.
    <br>Example for 3 oscillators:
    <pre style="background-color: #222; padding: 5px; border-radius: 3px;">
0, 1, 0.5
1, 0, 0.8
0.5, 0.8, 0</pre>
    </div>
    """, unsafe_allow_html=True)
    
    # Create a default example matrix if no prior matrix exists
    if not st.session_state.adj_matrix_input:
        # Create a simple default example for smaller number of oscillators
        default_matrix = ""
        for i in range(min(5, n_oscillators)):
            row = []
            for j in range(min(5, n_oscillators)):
                if i == j:
                    row.append("0")  # No self-connections
                elif abs(i-j) == 1 or abs(i-j) == min(5, n_oscillators)-1:  # Ring-neighbors
                    row.append("1")  # Connected
                else:
                    row.append("0")  # Not connected
            default_matrix += ", ".join(row) + "\n"
                
    # Make sure we have a non-empty value for the text area
    if network_type == "Custom Adjacency Matrix" and not st.session_state.adj_matrix_input:
        print("Custom matrix selected but no existing input - initializing default")
        st.session_state.adj_matrix_input = default_matrix
        
    adj_matrix_input = st.sidebar.text_area(
        "Adjacency Matrix",
        value=st.session_state.adj_matrix_input,
        height=200,
        help="Enter the adjacency matrix as comma-separated values, each row on a new line",
        key="adj_matrix_input"
    )
    
    # Process the input adjacency matrix
    if adj_matrix_input:
        try:
            # Parse the input text into a numpy array
            rows = adj_matrix_input.strip().split('\n')
            
            # Ensure we have at least one row
            if len(rows) == 0:
                raise ValueError("No data found in matrix input")
                
            # Process each row, removing extra spaces and parsing values
            adj_matrix = []
            for row in rows:
                # Skip empty rows
                if not row.strip():
                    continue
                    
                # Process values in this row
                values = []
                for val in row.split(','):
                    # Convert to float, handling extra whitespace
                    cleaned_val = val.strip()
                    if cleaned_val:  # Skip empty entries
                        values.append(float(cleaned_val))
                
                # Ensure row has data
                if values:
                    adj_matrix.append(values)
            
            # Make sure we have a valid matrix with data
            if not adj_matrix:
                raise ValueError("Could not find valid numeric data in input")
                
            # Convert to numpy array for faster processing
            adj_matrix = np.array(adj_matrix)
            
            # Validate the adjacency matrix
            if adj_matrix.shape[0] != adj_matrix.shape[1]:
                st.sidebar.error(f"The adjacency matrix must be square. Current shape: {adj_matrix.shape}")
            elif adj_matrix.shape[0] != n_oscillators:
                # We can't modify widget session state once widgets are created,
                # so we'll save the desired dimension in a different session state variable
                matrix_dim = adj_matrix.shape[0]
                
                # Log information
                print(f"Matrix dimensions ({matrix_dim}) don't match current oscillator count ({n_oscillators})")
                
                # Store the matrix as is, don't try to resize it
                st.session_state.next_n_oscillators = matrix_dim
                
                # Show message explaining what's happening
                st.sidebar.info(f"""
                Matrix size ({matrix_dim}Ã—{matrix_dim}) differs from current oscillator count ({n_oscillators}).
                The matrix will be used as-is for this simulation. Next time you interact with the UI, 
                the oscillator count will automatically update to match your matrix dimensions.
                """)
                
                # Keep local variable as is, use adj_matrix without modification
            else:
                st.sidebar.success("Adjacency matrix validated successfully!")
                
                # Add a dedicated button to force network visualization refresh
                if st.sidebar.button("ðŸ”„ Refresh", key="force_refresh_btn"):
                    st.session_state.refresh_network = True
                    print("Network refresh requested via button")
                    st.rerun()
                
                # Add save preset button and input field
                with st.sidebar.expander("Save as Preset"):
                    preset_name = st.text_input("Preset Name", key="preset_name", 
                                             placeholder="Enter a name for this matrix")
                    if st.button("ðŸ’¾ Save Preset", key="save_preset_btn"):
                        if preset_name:
                            # Save the configuration with current parameters
                            config_id = save_configuration(
                                name=preset_name,
                                n_oscillators=adj_matrix.shape[0],
                                coupling_strength=coupling_strength,
                                simulation_time=simulation_time,
                                time_step=0.01,  # Default value for backward compatibility
                                random_seed=random_seed,  # Use the UI's random_seed
                                network_type="Custom Adjacency Matrix",
                                frequency_distribution=freq_type,
                                frequency_params=json.dumps({
                                    "mean": float(freq_mean) if 'freq_mean' in locals() else 0.0,
                                    "std": float(freq_std) if 'freq_std' in locals() else 1.0,
                                    "min": float(freq_min) if 'freq_min' in locals() else -1.0,
                                    "max": float(freq_max) if 'freq_max' in locals() else 1.0
                                }),
                                adjacency_matrix=adj_matrix
                            )
                            st.success(f"Saved preset '{preset_name}' successfully!")
                            print(f"Saved matrix preset: '{preset_name}' with shape {adj_matrix.shape}")
                        else:
                            st.error("Please enter a preset name")
                
            # Store in session state for persistence
            st.session_state.loaded_adj_matrix = adj_matrix
            print(f"Updated adjacency matrix in session state with shape {adj_matrix.shape}")
                
        except Exception as e:
            st.sidebar.error(f"Error parsing matrix: {str(e)}")
            print(f"Matrix parsing error: {str(e)}")
            print(f"Input was: '{adj_matrix_input}'")
            adj_matrix = None


# Add JSON Configuration section at the bottom of the sidebar
st.sidebar.markdown("<hr style='margin: 15px 0px; border-color: rgba(255,255,255,0.2);'>", unsafe_allow_html=True)
st.sidebar.markdown("<h3 class='gradient_text1'>JSON Configuration</h3>", unsafe_allow_html=True)

# Initialize session state for JSON example if not present
if 'json_example' not in st.session_state:
    st.session_state.json_example = ""

# Display text area for JSON input (larger and left-aligned)
json_input = st.sidebar.text_area(
    "Import/Export Parameters",
    value=st.session_state.json_example,
    height=200,
    placeholder='Paste your JSON configuration here...',
    help="Enter a valid JSON configuration for the Kuramoto simulation"
)

# Add a collapsible section with examples but without parameter details
with st.sidebar.expander("Examples", expanded=False):
    example_json = {
        "n_oscillators": 10,
        "coupling_strength": 1.0,
        "network_type": "All-to-All", 
        "simulation_time": 100.0,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.2
        }
    }
    
    st.code(json.dumps(example_json, indent=2), language="json")
    
    # Add small-world network example
    st.markdown("**Small-world network example:**")
    
    # Generate a sample small-world network
    n = 10
    sample_matrix = np.zeros((n, n))
    for i in range(n):
        # Connect to neighbors
        for j in range(1, 3):
            sample_matrix[i, (i+j) % n] = 1
            sample_matrix[i, (i-j) % n] = 1
            
    # Add a few random long-range connections
    np.random.seed(42)
    for _ in range(5):
        i = np.random.randint(0, n)
        j = np.random.randint(0, n)
        if i != j and sample_matrix[i, j] == 0:
            sample_matrix[i, j] = 1
            sample_matrix[j, i] = 1
            
    # Create example with matrix
    complex_example = {
        "n_oscillators": n,
        "coupling_strength": 0.8,
        "network_type": "Custom Adjacency Matrix",
        "simulation_time": 100.0,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.1
        },
        "adjacency_matrix": sample_matrix.tolist()
    }
    
    # Add button to use this example - with smaller text
    if st.button("Use Small-World", key="small_world_btn"):
        st.session_state.json_example = json.dumps(complex_example, indent=2)
        st.rerun()

# Add import button and logic
if st.sidebar.button("Import Parameters", key="sidebar_import_json_button"):
    if json_input.strip():
        try:
            # Parse the JSON input
            params, error = parse_json_parameters(json_input)
            
            if error:
                st.sidebar.error(f"Error parsing JSON: {error}")
            else:
                # Update session state with the parsed parameters
                if params is not None:
                    # Store all parameters in a temporary variable in session state
                    # This is to avoid the error when trying to change widget values after initialization
                    st.session_state.temp_imported_params = params
                    
                    # Show success message
                    st.sidebar.success("Parameters imported successfully! Applying settings...")
                    
                    # Rerun the app to apply the changes
                    st.rerun()
                else:
                    st.sidebar.error("Failed to parse JSON parameters. Please check your input format.")
        except Exception as e:
            st.sidebar.error(f"Error processing parameters: {str(e)}")
    else:
        st.sidebar.warning("Please enter JSON configuration before importing.")


# Create tabs for different visualizations (Network is default tab)
tab1, tab2, tab3, tab4 = st.tabs(["Network", "Distributions", "Animation", "Numerical Considerations"])

# Set a unique key for each tab to force refresh of the Network tab
if 'current_tab' not in st.session_state:
    st.session_state.current_tab = "Network"
    
# Add a hidden button that is programmatically clicked when checking a custom matrix
tab_key = f"tab_refresh_{int(time.time())}"
if st.session_state.current_tab == "Network" and adj_matrix is not None:
    # This ensures the network tab is refreshed when the adjacency matrix changes
    st.session_state.refresh_network = True

# Determine the effective network type for display and matrix creation
# If we have a custom matrix, ALWAYS force the network type to custom
# regardless of what's displayed in the UI
if adj_matrix is not None:
    print("Detected valid adjacency matrix - forcing internal network type to Custom")
    print(f"Matrix shape: {adj_matrix.shape}, sum: {np.sum(adj_matrix)}, non-zeros: {np.count_nonzero(adj_matrix)}")
    
    # Don't change the UI selection, but use Custom type for all internal processing
    network_type_internal = "Custom Adjacency Matrix"
    
    # CRITICAL: We must NOT delete the matrix from session state until we've used it successfully
    # Otherwise, it will be lost on the next rerun when Streamlit rebuilds the application
    
    # Keep a flag to signal we've saved the matrix for this session
    if 'using_loaded_matrix' not in st.session_state:
        st.session_state.using_loaded_matrix = True
        print("First use of loaded matrix - will keep in session state")
else:
    # Use the selected network type
    network_type_internal = network_type
    
    # If we don't have a custom matrix but the UI type is set to custom,
    # we need to ensure this is communicated clearly
    if network_type == "Custom Adjacency Matrix" and adj_matrix is None:
        # Use custom styled message with orange background instead of the default yellow warning
        # This matches the sidebar error messages styling
        st.markdown("""
        <div style="background-color: rgba(255,150,0,0.15); color: #ffaa50; 
                    padding: 10px; border-radius: 15px; border-left: 5px solid #ff8800;">
            <b>Matrix Input:</b> Please enter your custom adjacency matrix in the sidebar.
            The format should be comma-separated values with each row on a new line.
        </div>
        """, unsafe_allow_html=True)
        print("Warning: Custom adjacency matrix selected but no valid matrix found")

# Function to simulate model
@st.cache_data(ttl=300)
def run_simulation(n_oscillators, coupling_strength, frequencies, simulation_time, time_step=None, random_seed=None, 
                  adjacency_matrix=None):
    """
    Run a Kuramoto model simulation with the specified parameters and return the results.
    
    Parameters:
    -----------
    n_oscillators : int
        Number of oscillators
    coupling_strength : float
        Coupling strength parameter K
    frequencies : ndarray
        Natural frequencies of oscillators
    simulation_time : float
        Total simulation time
    time_step : float, optional
        DEPRECATED: This parameter is no longer used. The time step is now automatically calculated
        based on oscillator frequencies to ensure numerical stability and accuracy.
        The parameter is kept for backward compatibility with saved configurations.
    random_seed : int, optional
        Seed for random number generation
    adjacency_matrix : ndarray, optional
        Custom adjacency matrix defining network connectivity
        
    Returns:
    --------
    tuple
        (model, times, phases, order_parameter)
    """
    # Convert random_seed to integer to prevent type errors
    if random_seed is not None:
        random_seed = int(random_seed)
    
    # Initialize the model with given parameters
    model = KuramotoModel(
        n_oscillators=n_oscillators,
        coupling_strength=coupling_strength,
        frequencies=frequencies,
        adjacency_matrix=adjacency_matrix,
        simulation_time=simulation_time,
        random_seed=random_seed
    )
    
    # Run the simulation with automatically calculated time step
    try:
        # Force at least 500 time points for visualization
        times, phases, order_parameter = model.simulate(min_time_points=500)
        print("Simulation successful!")
        print(f"  times shape: {times.shape if hasattr(times, 'shape') else 'N/A'}")
        print(f"  phases shape: {phases.shape if hasattr(phases, 'shape') else 'N/A'}")
        print(f"  order_parameter shape: {order_parameter.shape if hasattr(order_parameter, 'shape') else 'N/A'}")
    except Exception as e:
        print(f"Error in simulation: {str(e)}")
        import traceback
        traceback.print_exc()
        # Return empty arrays for graceful failure
        times = np.linspace(0, simulation_time, 100)
        phases = np.zeros((n_oscillators, 100))
        order_parameter = np.zeros(100)
    
    # Return results
    return model, times, phases, order_parameter

# Run the simulation
# If we have a custom adjacency matrix, adjust the oscillator count to match matrix dimensions
sim_n_oscillators = n_oscillators
if adj_matrix is not None:
    matrix_dim = adj_matrix.shape[0]
    if matrix_dim != n_oscillators:
        print(f"Adjusting simulation oscillator count to match matrix dimensions: {matrix_dim}")
        sim_n_oscillators = matrix_dim
        
        # Also adjust frequencies to match this count
        if len(frequencies) != sim_n_oscillators:
            print(f"Adjusting frequencies array from length {len(frequencies)} to {sim_n_oscillators}")
            if len(frequencies) > sim_n_oscillators:
                # Truncate if too many
                frequencies = frequencies[:sim_n_oscillators]
            else:
                # Extend by cycling through existing values if too few
                frequencies = np.resize(frequencies, sim_n_oscillators)

# Get current random seed from session state
current_random_seed = st.session_state.random_seed if "random_seed" in st.session_state else 42

# Run simulation
model, times, phases, order_parameter = run_simulation(
    n_oscillators=sim_n_oscillators,
    coupling_strength=coupling_strength,
    frequencies=frequencies,
    simulation_time=simulation_time,
    time_step=None,  # Not actually used, time_step is auto-calculated
    random_seed=current_random_seed,
    adjacency_matrix=adj_matrix
)

########################
# TAB 1: NETWORK TAB
########################
with tab1:
    # Update current tab in session state to track which tab is active
    st.session_state.current_tab = "Network"
    
    # Force a reload when we have a custom matrix change
    if 'refresh_network' in st.session_state and st.session_state.refresh_network:
        # Reset the flag to prevent infinite reloads
        st.session_state.refresh_network = False
        # This will cause network visualization to rebuild completely
        st.empty().button("Refresh Network", key=f"network_refresh_{time.time()}", on_click=lambda: None)
    st.markdown("<h2 class='gradient_text2'>Network Structure</h2>", unsafe_allow_html=True)
    
    # Display simulation information
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Create a network visualization
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5), gridspec_kw={'width_ratios': [2, 1]})
    
    # Import networkx for graph visualization
    import networkx as nx
    
    # Make sure adj_matrix is defined for all network types
    if network_type_internal == "All-to-All":
        # For all-to-all, create a fully connected matrix with uniform coupling
        network_adj_matrix = np.ones((n_oscillators, n_oscillators))
        np.fill_diagonal(network_adj_matrix, 0)  # No self-connections
    elif network_type_internal == "Nearest Neighbor":
        # For nearest neighbor, create a ring topology
        network_adj_matrix = np.zeros((n_oscillators, n_oscillators))
        for i in range(n_oscillators):
            # Connect to left and right neighbors on the ring
            network_adj_matrix[i, (i-1) % n_oscillators] = 1
            network_adj_matrix[i, (i+1) % n_oscillators] = 1
    elif network_type_internal == "Random":
        # For random, create random connections with 20% probability
        np.random.seed(current_random_seed)  # Use same seed for reproducibility
        network_adj_matrix = np.random.random((n_oscillators, n_oscillators)) < 0.2
        network_adj_matrix = network_adj_matrix.astype(float)
        np.fill_diagonal(network_adj_matrix, 0)  # No self-connections
    else:  # Custom Adjacency Matrix
        if adj_matrix is not None:
            # Make sure we're using a copy of the matrix to avoid modifying the original
            network_adj_matrix = np.array(adj_matrix, copy=True)
            
            # This section handles the case where network_adj_matrix dimensions
            # don't match n_oscillators, which might happen in rare cases
            if network_adj_matrix.shape[0] != n_oscillators:
                print(f"Network matrix dimensions mismatch: matrix is {network_adj_matrix.shape} but n_oscillators={n_oscillators}")
                
                # Here we directly use the matrix at its current dimensions without changing session state
                # This is safe because we're not modifying widget values, just local processing
                n_oscillators = network_adj_matrix.shape[0]
                print(f"Using matrix at its native dimension: {n_oscillators}x{n_oscillators}")
            
            # Print detailed debug info
            print(f"Using custom adjacency matrix with shape {network_adj_matrix.shape}")
            print(f"Sum of elements: {np.sum(network_adj_matrix)}")
            print(f"Number of non-zero elements: {np.count_nonzero(network_adj_matrix)}")
            if network_adj_matrix.shape[0] >= 3:
                print("Sample (top-left 3x3):")
                print(network_adj_matrix[:3, :3])
        else:
            print("Warning: No custom adjacency matrix provided, using fallback")
            # Create a default matrix but NOT fully connected
            # Use a simple ring structure instead as fallback
            network_adj_matrix = np.zeros((n_oscillators, n_oscillators))
            for i in range(n_oscillators):
                network_adj_matrix[i, (i-1) % n_oscillators] = 1
                network_adj_matrix[i, (i+1) % n_oscillators] = 1
    
    # Create a graph visualization using networkx
    # Ensure the adjacency matrix has no self-loops (diagonal should be zero)
    np.fill_diagonal(network_adj_matrix, 0)
    
    # Print debug info
    if network_type_internal == "Custom Adjacency Matrix":
        print("Network adjacency matrix before creating graph:")
        print(f"Shape: {network_adj_matrix.shape}")
        print(f"Sum of elements: {np.sum(network_adj_matrix)}")
        print(f"Number of non-zero elements: {np.count_nonzero(network_adj_matrix)}")
        print(f"Sample of matrix: {network_adj_matrix[:3, :3] if network_adj_matrix.shape[0] >= 3 else network_adj_matrix}")
        
        # Ensure the adjacency matrix has proper values for building a network
        # Some users might enter very small values (like 0.01) that don't register as edges
        # Convert anything > 0.1 to a definite edge to ensure network is visible
        adj_for_network = network_adj_matrix.copy()
        adj_for_network[adj_for_network > 0.1] = 1.0
        if np.count_nonzero(adj_for_network) != np.count_nonzero(network_adj_matrix):
            print(f"Enhancing {np.count_nonzero(adj_for_network) - np.count_nonzero(network_adj_matrix)} weak connections for visualization")
        
        # Use the enhanced matrix for network visualization only
        G = nx.from_numpy_array(adj_for_network)
    else:
        # Use original matrix for standard network types
        G = nx.from_numpy_array(network_adj_matrix)
    
    # Create custom colormap that matches our gradient_text1 theme for nodes
    custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                ["#9933FF", "#FF33FF", "#FFAA00", "#50FF96"], 
                                                N=256)
    
    # Sort oscillators by their natural frequency for consistent coloring
    # This is the SAME color assignment used throughout all visualizations
    sorted_indices = np.argsort(frequencies)
    color_indices = np.linspace(0, 1, n_oscillators)
    oscillator_colors = np.zeros(n_oscillators, dtype=object)
    
    # Assign colors based on frequency order
    for i, idx in enumerate(sorted_indices):
        oscillator_colors[idx] = custom_cmap(color_indices[i])
    
    # Choose layout based on network type
    if network_type_internal == "Nearest Neighbor":
        # Circular layout for nearest neighbor (ring)
        pos = nx.circular_layout(G)
    # Special case for the Etz Hayim (Tree of Life) matrix - 10x10 matrix with specific structure
    elif network_type_internal == "Custom Adjacency Matrix" and network_adj_matrix.shape[0] == 10 and np.count_nonzero(network_adj_matrix) >= 40:
        # This appears to be our special Etz Hayim matrix - use a custom tree-like layout
        # Create a dictionary with fixed positions for this specific matrix
        # These positions follow a traditional Sephirotic tree arrangement with improved spacing
        fixed_positions = {
            0: (0.0, 1.0),     # Keter (Crown) - top position
            1: (-0.4, 0.8),    # Chokhmah (Wisdom) - upper right
            2: (0.4, 0.8),     # Binah (Understanding) - upper left
            3: (-0.7, 0.4),    # Chesed (Kindness) - middle right
            4: (0.7, 0.4),     # Gevurah (Strength) - middle left
            5: (0.0, 0.4),     # Tiferet (Beauty) - center
            6: (-0.7, 0.0),    # Netzach (Victory) - lower right
            7: (0.7, 0.0),     # Hod (Splendor) - lower left
            8: (0.0, -0.4),    # Yesod (Foundation) - bottom center
            9: (0.0, -0.8)     # Malkhut (Kingdom) - bottom
        }
        pos = fixed_positions
        
        # Add a note that we're using the special layout
        st.info("Using special 'Etz Hayim' (Tree of Life) layout for this adjacency matrix.")
    elif n_oscillators <= 20:
        # Spring layout for smaller networks
        pos = nx.spring_layout(G, seed=current_random_seed)
    else:
        # Circular layout is better for visualization with many nodes
        pos = nx.circular_layout(G)
    
    # Create graph visualization
    ax1.set_facecolor('#121212')
    
    # Debug information about the graph
    print(f"Graph info: nodes={len(G.nodes())}, edges={len(G.edges())}")
    if len(G.edges()) == 0:
        print("WARNING: Graph has no edges! Check adjacency matrix values.")
        # Force at least some edges for visualization by creating a ring
        temp_G = nx.cycle_graph(network_adj_matrix.shape[0])
        pos = nx.circular_layout(temp_G)
        edges = nx.draw_networkx_edges(temp_G, pos, ax=ax1, alpha=0.7,
                                  edge_color='#ff5500', width=1.5, 
                                  style='dashed')  # Use orange dashed lines to indicate fallback
        # Add warning to graph
        ax1.text(0.5, 0.5, "Warning: No edges detected in custom matrix\nShowing placeholder network",
              horizontalalignment='center', verticalalignment='center',
              transform=ax1.transAxes, color='#ff5500', fontsize=14)
    else:
        # Draw the graph with dark blue edges to match adjacency matrix
        edges = nx.draw_networkx_edges(G, pos, ax=ax1, alpha=0.7, 
                                   edge_color='#0070db', width=1.5)
    
    # Convert the RGBA colors to hex for networkx
    node_colors = []
    for c in oscillator_colors:
        # Create hex color from the custom colormap colors
        if hasattr(c, 'tolist'):  # If it's a numpy array
            rgba = c.tolist()
        else:  # If it's already a tuple/list
            rgba = c
        # Format as hex
        node_colors.append(f"#{int(rgba[0]*255):02x}{int(rgba[1]*255):02x}{int(rgba[2]*255):02x}")
    
    # Calculate dynamic node size based on number of nodes
    # Larger size for fewer nodes, smaller size for many nodes
    n_nodes = len(G.nodes)
    # Adjusted node size to be moderately sized - not too big, not too small
    node_size = max(150, int(800 * (1 / (0.12 * n_nodes + 0.6))))  # Balanced node size
    
    # Generate brighter versions of node colors for edges
    bright_node_colors = []
    for color in node_colors:
        # Convert hex to RGB and make it brighter
        r = int(color[1:3], 16)
        g = int(color[3:5], 16)
        b = int(color[5:7], 16)
        # Make RGB values brighter (closer to white)
        r = min(255, int(r * 1.5))
        g = min(255, int(g * 1.5))
        b = min(255, int(b * 1.5))
        bright_node_colors.append(f"#{r:02x}{g:02x}{b:02x}")
    
    # No glow effect for network nodes to keep the visualization clean
    
    # Draw the main nodes on top of glow effects
    nodes = nx.draw_networkx_nodes(G, pos, ax=ax1, 
                               node_color=node_colors, 
                               node_size=node_size, alpha=0.9, 
                               edgecolors=bright_node_colors, linewidths=1.0)
    
    # Add node labels only if there are relatively few nodes
    if n_oscillators <= 15:
        labels = {i: str(i) for i in range(n_oscillators)}
        nx.draw_networkx_labels(G, pos, labels=labels, ax=ax1, 
                           font_color='white', font_weight='bold')
        
    # Add title and styling
    ax1.set_title(f'Oscillator Network Graph ({network_type_internal})', 
               color='white', fontsize=14, pad=15)
    ax1.set_axis_off()
    
    # Add a legend explaining node colors with brighter outline
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.0), 
                markeredgecolor='#ae56ff', markersize=10, label='Lowest frequency (violet)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.33), 
                markeredgecolor='#ff50ff', markersize=10, label='Lower frequency (magenta)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.67), 
                markeredgecolor='#ffc060', markersize=10, label='Higher frequency (orange)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(1.0), 
                markeredgecolor='#70e898', markersize=10, label='Highest frequency (green)')
    ]
    ax1.legend(handles=legend_elements, loc='upper right', 
            frameon=True, framealpha=0.7, facecolor='#121212', 
            edgecolor='#555555', labelcolor='white')
    
    # Create a heatmap of the adjacency matrix using blue gradient
    # Create a custom blue colormap for the adjacency matrix (swapped light/dark and adjusted intensity)
    blue_cmap = LinearSegmentedColormap.from_list("adj_matrix_blue", 
                                             ["#00c2dd", "#109ae8", "#0070db"], 
                                             N=256)
    # Apply custom colormap - dark blue for 0s, light blue for 1s
    # Using binary data without text annotations
    im = ax2.imshow(network_adj_matrix, cmap=blue_cmap, interpolation='nearest')
    plt.colorbar(im, ax=ax2, label='Connection Strength')
    
    # Remove the actual 0/1 text annotations by turning off tick labels
    ax2.set_xticks([])
    ax2.set_yticks([])
    
    # Add labels and styling
    ax2.set_title('Adjacency Matrix', color='white', fontsize=14)
    ax2.set_xlabel('Oscillator Index', color='white')
    ax2.set_ylabel('Oscillator Index', color='white')
    
    # Set background color
    ax2.set_facecolor('#1a1a1a')
    fig.patch.set_facecolor('#121212')
    
    # Add a grid to help distinguish cells
    ax2.grid(False)
    
    # Add text annotations for connection strength (only for matrices smaller than 15x15)
    if n_oscillators <= 12:
        for i in range(network_adj_matrix.shape[0]):
            for j in range(network_adj_matrix.shape[1]):
                if network_adj_matrix[i, j] > 0:
                    ax2.text(j, i, f"{network_adj_matrix[i, j]:.1f}", 
                          ha="center", va="center", 
                          color="white" if network_adj_matrix[i, j] < 0.7 else "black",
                          fontsize=9)
    
    # Adjust spacing between subplots
    plt.tight_layout()
    
    # Display the figure
    st.pyplot(fig)
    
    # Special description for Etz Hayim matrix
    if network_type_internal == "Custom Adjacency Matrix" and network_adj_matrix.shape[0] == 10 and np.count_nonzero(network_adj_matrix) >= 40:
        st.markdown("""
        <div class='section'>
            <p>Figure Description:</p>
            <ul>
                <li><b>Left:</b> Graph representing the ten Sephirot (emanations) in the Kabbalistic Tree of Life, arranged in their traditional positions</li>
                <li><b>Right:</b> Adjacency matrix showing the 22 paths connecting the Sephirot</li>
            </ul>
            <p>The nodes represent (from top to bottom, right to left):</p>
            <ol>
                <li>Keter (Crown) - Will and the origin of divine revelation</li>
                <li>Chokhmah (Wisdom) - Beginning of conscious thought</li>
                <li>Binah (Understanding) - Processing and understanding</li>
                <li>Chesed (Kindness) - Expansion, loving kindness</li>
                <li>Gevurah (Strength) - Restriction, judgment and discipline</li>
                <li>Tiferet (Beauty) - Harmony, balance, integration</li>
                <li>Netzach (Victory) - Endurance and overcoming</li>
                <li>Hod (Splendor) - Surrender, sincerity, and gratitude</li>
                <li>Yesod (Foundation) - Connection and bonding force</li>
                <li>Malkhut (Kingdom) - Physical manifestation and action</li>
            </ol>
            <p>This structure offers a fascinating system to study synchronization patterns across interconnected oscillators.</p>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div class='section'>
            <p>Figure Description:</p>
            <ul>
                <li><b>Left:</b> Graph representation of oscillator connections, with nodes colored by natural frequency</li>
                <li><b>Right:</b> Adjacency matrix representation, where each cell (i,j) represents the connection strength between oscillators</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)

########################
# TAB 2: DISTRIBUTIONS TAB
########################
with tab2:
    # Update current tab in session state
    st.session_state.current_tab = "Distributions"
    st.markdown("<h2 class='gradient_text2'>Initial Distributions</h2>", unsafe_allow_html=True)
    
    # Display simulation information at the top
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Add the distribution histograms
    dist_col1, dist_col2 = st.columns(2)
    
    # Define a consistent figure size for both histograms
    hist_figsize = (4.0, 3.0)
    
    with dist_col1:
        st.markdown("<h4 class='gradient_text2'>Natural Frequency Distribution</h4>", unsafe_allow_html=True)
        
        # Create frequency distribution histogram
        fig_freq, ax_freq = plt.subplots(figsize=hist_figsize)
        
        # Use a gradient colormap for the histogram
        n_bins = 15
        counts, bin_edges = np.histogram(frequencies, bins=n_bins)
        
        # Create custom colormap that matches our gradient theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                ["#00ffff", "#00aaff"], 
                                                N=256)
        
        # Create custom colors with a gradient effect that matches our theme
        colors = custom_cmap(np.linspace(0.1, 0.9, n_bins))
        
        # Plot the histogram with gradient colors and outline
        bars = ax_freq.bar(
            (bin_edges[:-1] + bin_edges[1:]) / 2, 
            counts, 
            width=(bin_edges[1] - bin_edges[0]) * 0.9,
            color=colors, 
            alpha=0.8,
            edgecolor='white',
            linewidth=0.5
        )
        
        # Add a soft glow effect behind bars
        for bar, color in zip(bars, colors):
            x = bar.get_x()
            width = bar.get_width()
            height = bar.get_height()
            glow = plt.Rectangle(
                (x - width * 0.05, 0), 
                width * 1.1, 
                height, 
                color=color,
                alpha=0.3,
                zorder=-1
            )
            ax_freq.add_patch(glow)
        
        # Enhance the axes and labels
        ax_freq.set_facecolor('#1a1a1a')
        ax_freq.set_xlabel('Natural Frequency', fontsize=12, fontweight='bold', color='white')
        ax_freq.set_ylabel('Count', fontsize=12, fontweight='bold', color='white')
        ax_freq.set_title(f'Natural Frequency Distribution ({freq_type})', 
                       fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Add mean frequency marker
        mean_freq = np.mean(frequencies)
        ax_freq.axvline(x=mean_freq, color='#ff5555', linestyle='-', linewidth=2, alpha=0.7,
                      label=f'Mean: {mean_freq:.2f}')
        ax_freq.legend(framealpha=0.7)
        
        # Customize grid
        ax_freq.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add a subtle box around the plot
        for spine in ax_freq.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        st.pyplot(fig_freq)
        
        # Distribution properties description
        st.markdown(f"""
        <div class='section' style='font-size: 0.85em;'>
            <p><b>Mean:</b> {np.mean(frequencies):.4f}</p>
            <p><b>Standard Deviation:</b> {np.std(frequencies):.4f}</p>
            <p><b>Min:</b> {np.min(frequencies):.4f}</p>
            <p><b>Max:</b> {np.max(frequencies):.4f}</p>
        </div>
        """, unsafe_allow_html=True)
    
    with dist_col2:
        st.markdown("<h4 class='gradient_text2'>Initial Phase Distribution</h4>", unsafe_allow_html=True)
        
        # Create initial phase distribution histogram with matching size
        fig_init_phase, ax_init_phase = plt.subplots(figsize=hist_figsize)
        
        initial_phases = phases[:, 0] % (2 * np.pi)
        
        # Use a gradient colormap for the histogram
        n_bins = 15
        counts, bin_edges = np.histogram(initial_phases, bins=n_bins)
        
        # Create custom colors with a gradient effect that matches our theme
        colors = custom_cmap(np.linspace(0.1, 0.9, n_bins))
        
        # Plot the histogram with gradient colors and outline
        bars = ax_init_phase.bar(
            (bin_edges[:-1] + bin_edges[1:]) / 2, 
            counts, 
            width=(bin_edges[1] - bin_edges[0]) * 0.9,
            color=colors, 
            alpha=0.8,
            edgecolor='white',
            linewidth=0.5
        )
        
        # Add a soft glow effect behind bars
        for bar, color in zip(bars, colors):
            x = bar.get_x()
            width = bar.get_width()
            height = bar.get_height()
            glow = plt.Rectangle(
                (x - width * 0.05, 0), 
                width * 1.1, 
                height, 
                color=color,
                alpha=0.3,
                zorder=-1
            )
            ax_init_phase.add_patch(glow)
        
        # Enhance the axes and labels
        ax_init_phase.set_facecolor('#1a1a1a')
        ax_init_phase.set_xlabel('Phase (mod 2Ï€)', fontsize=12, fontweight='bold', color='white')
        ax_init_phase.set_ylabel('Count', fontsize=12, fontweight='bold', color='white')
        ax_init_phase.set_title('Initial Phase Distribution (t=0)', 
                             fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Calculate initial order parameter
        initial_r = order_parameter[0]
        initial_psi = np.angle(np.sum(np.exp(1j * initial_phases))) % (2 * np.pi)
        
        # Always add mean phase marker with red vertical line
        ax_init_phase.axvline(x=initial_psi, color='#ff5555', linestyle='-', linewidth=2, alpha=0.7,
                           label=f'Mean Phase: {initial_psi:.2f}')
        ax_init_phase.legend(framealpha=0.7)
        
        # Customize grid
        ax_init_phase.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add a subtle box around the plot
        for spine in ax_init_phase.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        st.pyplot(fig_init_phase)
        
        # Initial phase properties description
        st.markdown(f"""
        <div class='section' style='font-size: 0.85em;'>
            <p><b>Initial Order Parameter:</b> {initial_r:.4f}</p>
            <p><b>Initial Mean Phase:</b> {initial_psi:.4f}</p>
        </div>
        """, unsafe_allow_html=True)
    
    # Order Parameter Analysis section
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Order Parameter Analysis</h3>
        <p>The order parameter r(t) measures the degree of synchronization among oscillators:</p>
        <ul>
            <li>r = 1: Complete synchronization (all oscillators have the same phase)</li>
            <li>r = 0: Complete desynchronization (phases are uniformly distributed)</li>
        </ul>
        <p>At critical coupling strength (K_c), the system transitions from desynchronized to partially synchronized state.</p>
    </div>
    """, unsafe_allow_html=True)

########################
# TAB 3: ANIMATION TAB
########################
with tab3:
    # Update current tab in session state
    st.session_state.current_tab = "Animation"
    st.markdown("<h2 class='gradient_text2'>Interactive Animation</h2>", unsafe_allow_html=True)
    
    # Display simulation information at the top
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Create oscillator visualization
    # Removed "Oscillator Synchronization" header as requested
    
    # Initialize time_index in session state if not present
    if 'time_index' not in st.session_state:
        st.session_state.time_index = 0
        
    # Set time index from session state
    time_index = st.session_state.time_index
    
    # Safety check to prevent index out of bounds errors
    max_valid_index = len(times) - 1
    if time_index > max_valid_index:
        # Reset the time index to a valid value
        time_index = max_valid_index
        st.session_state.time_index = max_valid_index
        st.warning(f"Time index was reset to maximum value ({max_valid_index})")
    
    # Initialize animation variables
    animate = False
    animation_speed = 3.0
    
    # Get time and order parameter values for the current time index (now with bounds checking)
    current_time = times[time_index]
    current_r = order_parameter[time_index]
    
    # Import needed module
    
    # Function to create the phase visualization
    def create_phase_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        # Create visualization with enhanced visuals for dark theme
        fig_circle = plt.figure(figsize=(5, 5))
        ax_circle = fig_circle.add_subplot(111)
        
        # Add background glow effect
        bg_circle = plt.Circle((0, 0), 1.1, fill=True, color='#121a24', alpha=0.6, zorder=1)
        ax_circle.add_patch(bg_circle)
        
        # Add subtle circle rings for reference in white to match unit circle
        for radius in [0.25, 0.5, 0.75]:
            ring = plt.Circle((0, 0), radius, fill=False, color='#ffffff', 
                            linestyle=':', alpha=0.25, zorder=2)
            ax_circle.add_patch(ring)
        
        # Draw unit circle with glow effect - using white
        circle_glow = plt.Circle((0, 0), 1.02, fill=False, color='#ffffff', alpha=0.3, linewidth=3, zorder=3)
        ax_circle.add_patch(circle_glow)
        
        # Main unit circle in white
        circle = plt.Circle((0, 0), 1, fill=False, color='#ffffff', linestyle='-', 
                         linewidth=1.5, alpha=0.8, zorder=4)
        ax_circle.add_patch(circle)
        
        # Plot oscillators - with bounds checking
        # Make sure we're using a valid time index
        safe_time_idx = max_valid_idx
        
        # Safety check for phase data dimensions
        if safe_time_idx < phases.shape[1]:
            phases_at_time = phases[:, safe_time_idx]
            x = np.cos(phases_at_time)
            y = np.sin(phases_at_time)
        else:
            # Fallback to initial phases if time index is beyond data
            initial_phases = phases[:, 0]
            x = np.cos(initial_phases)
            y = np.sin(initial_phases)
            # Show a warning in the plot
            ax_circle.text(0, 0, "Invalid time index", 
                         ha='center', va='center', color='red', fontsize=12)
        
        # Create custom colormap that matches our gradient_text1 theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                     ["#8A2BE2", "#FF00FF", "#FFA500", "#50C878"], 
                                                     N=256)
        
        # Sort oscillators by their natural frequency
        sorted_indices = np.argsort(frequencies)
        # Create colors based on frequency ordering
        color_indices = np.linspace(0, 1, n_oscillators)
        colors = [custom_cmap(idx) for idx in color_indices]
        
        # Map colors to oscillators by frequency order
        oscillator_colors = np.zeros((n_oscillators, 4))  # RGBA colors
        for i, idx in enumerate(sorted_indices):
            oscillator_colors[idx] = colors[i]
        
        # Enhanced scatter plot with oscillator colors - with reduced glow effect
        # Create slightly brighter versions of the colors for outlines and glow
        bright_oscillator_colors = np.copy(oscillator_colors)
        for i in range(len(bright_oscillator_colors)):
            # Make RGB values brighter (closer to white) but preserve alpha - reduced from 1.7 to 1.3
            bright_oscillator_colors[i, :3] = np.minimum(1.0, bright_oscillator_colors[i, :3] * 1.3)  # 30% brighter
        
        # First add a smaller glow effect for each oscillator
        for i in range(n_oscillators):
            # Reduced size from 0.11 to 0.07 and alpha from 0.3 to 0.2
            glow = plt.Circle((x[i], y[i]), 0.07, fill=True, 
                          color=oscillator_colors[i], alpha=0.2, zorder=7)
            ax_circle.add_patch(glow)
            
        # Add a subtle pulse effect with smaller secondary glow (or remove if too much)
        for i in range(n_oscillators):
            # Reduced size from 0.14 to 0.09 and alpha from 0.15 to 0.1
            second_glow = plt.Circle((x[i], y[i]), 0.09, fill=True, 
                               color=bright_oscillator_colors[i], alpha=0.1, zorder=6)
            ax_circle.add_patch(second_glow)
        
        # Use custom edge colors and increased size for main points - slightly smaller
        sc = ax_circle.scatter(x, y, facecolors=oscillator_colors, edgecolors=bright_oscillator_colors, s=180, 
                         alpha=0.9, linewidth=1.3, zorder=10)
        
        # Calculate and show order parameter
        r = order_parameter[time_idx]
        psi = np.angle(np.sum(np.exp(1j * phases_at_time)))
        
        # Draw arrow showing mean field with glow effect - using bright blue color
        # First add glow/shadow
        ax_circle.arrow(0, 0, r * np.cos(psi), r * np.sin(psi), 
                       head_width=0.07, head_length=0.12, fc='#00c2ff', ec='#00c2ff', 
                       width=0.03, alpha=0.3, zorder=5)
        
        # Then add main arrow
        ax_circle.arrow(0, 0, r * np.cos(psi), r * np.sin(psi), 
                       head_width=0.05, head_length=0.1, fc='#00a5ff', ec='#00a5ff', 
                       width=0.02, zorder=6)
        
        # Draw axes
        ax_circle.axhline(y=0, color='#555555', linestyle='-', alpha=0.5, zorder=0)
        ax_circle.axvline(x=0, color='#555555', linestyle='-', alpha=0.5, zorder=0)
        
        ax_circle.set_xlim(-1.2, 1.2)
        ax_circle.set_ylim(-1.2, 1.2)
        ax_circle.set_aspect('equal')
        
        # Add subtle grid
        ax_circle.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Enhance title
        ax_circle.set_title(f'Oscillators at t={times[time_idx]:.2f}', 
                          color='white', fontsize=14, pad=15)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
        
        return fig_circle
    
    # Function to create oscillator phases over time plot (as dots)
    def create_oscillator_phases_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        fig, ax = plt.subplots(figsize=(12, 3.5))
        
        # Add background
        ax.set_facecolor('#1a1a1a')
        
        # Create transparent bands at phase regions
        for y in [0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi]:
            ax.axhspan(y-0.1, y+0.1, color='#222233', alpha=0.4, zorder=0)
        
        # Create custom colormap that matches our gradient_text1 theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                     ["#8A2BE2", "#FF00FF", "#FFA500", "#50C878"], 
                                                     N=256)
        
        # Sort oscillators by their natural frequency for consistent coloring
        sorted_indices = np.argsort(frequencies)
        color_indices = np.linspace(0, 1, n_oscillators)
        oscillator_colors = np.zeros(n_oscillators, dtype=object)
        
        # Assign colors based on frequency order
        for i, idx in enumerate(sorted_indices):
            oscillator_colors[idx] = custom_cmap(color_indices[i])
        
        # Use the safety bounds check variable
        safe_time_idx = max_valid_idx
        
        # Plot all oscillators as dots up to the current time point
        for i in range(n_oscillators):
            color = oscillator_colors[i]
            
            # Create a brighter version of the color for edge
            # Extract RGB values and make them brighter
            rgb = matplotlib.colors.to_rgb(color)
            # Create brighter version (closer to white)
            bright_color = tuple(min(1.0, c * 1.5) for c in rgb)
            
            # Plot oscillator phases as filled dots with color gradient
            ax.scatter(times[:safe_time_idx+1], phases[i, :safe_time_idx+1] % (2 * np.pi), 
                     facecolors=color, edgecolor=bright_color, alpha=0.7, s=50, 
                     linewidth=0.5, zorder=5)
            
            # Add a subtle connecting line with low opacity
            ax.plot(times[:safe_time_idx+1], phases[i, :safe_time_idx+1] % (2 * np.pi), 
                  color=color, alpha=0.2, linewidth=0.8, zorder=2)
            
            # Highlight current position with a larger filled marker
            ax.scatter([times[safe_time_idx]], [phases[i, safe_time_idx] % (2 * np.pi)], 
                     s=140, facecolors=color, edgecolor=bright_color, 
                     linewidth=1.0, zorder=15)
        
        # Add labels for key phase positions
        phase_labels = [(0, '0'), (np.pi/2, 'Ï€/2'), (np.pi, 'Ï€'), (3*np.pi/2, '3Ï€/2'), (2*np.pi, '2Ï€')]
        for y, label in phase_labels:
            ax.annotate(label, xy=(-0.02, y), xycoords=('axes fraction', 'data'),
                      fontsize=11, color='white', ha='center', va='center')
        
        # Plot styling
        ax.set_xlabel('Time', fontsize=13, fontweight='bold', color='white')
        ax.set_ylabel('Phase (mod 2Ï€)', fontsize=13, fontweight='bold', color='white')
        ax.set_title(f'Oscillator Phases at t={times[safe_time_idx]:.2f}', 
                   fontsize=14, fontweight='bold', color='white', pad=15)
        ax.set_ylim(0, 2 * np.pi)
        ax.set_yticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
        ax.set_yticklabels(['0', 'Ï€/2', 'Ï€', '3Ï€/2', '2Ï€'])
        ax.set_xlim(times.min(), times.max())
        
        # Custom grid
        ax.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add box around the plot
        for spine in ax.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
            
        return fig
    
    # Create a function to create order parameter plot over time (as a dot plot)
    def create_order_parameter_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        fig, ax = plt.subplots(figsize=(5, 5))
        
        # Add background gradient
        ax.set_facecolor('#1a1a1a')
        
        # Add subtle horizontal bands for visual reference
        for y in np.linspace(0, 1, 6):
            ax.axhspan(y-0.05, y+0.05, color='#222233', alpha=0.3, zorder=0)
        
        # Create a custom colormap that matches the blue gradient used in the sidebar
        cmap = LinearSegmentedColormap.from_list("order_param", 
                                             ["#00c2dd", "#109ae8", "#0070db"], 
                                             N=256)
        
        # Use the safe index for all references
        safe_time_idx = max_valid_idx
        
        # Plot order parameter with filled gradient dots and brighter outline
        base_colors = [cmap(r) for r in order_parameter[:safe_time_idx+1]]
        edge_colors = []
        
        # Create brighter versions of each color for the outlines
        for color in base_colors:
            rgb = matplotlib.colors.to_rgb(color)
            # Make RGB values brighter but preserve alpha
            bright_color = tuple(min(1.0, c * 1.5) for c in rgb)
            edge_colors.append(bright_color)
        
        scatter = ax.scatter(times[:safe_time_idx+1], order_parameter[:safe_time_idx+1],
                          facecolors=base_colors, edgecolors=edge_colors,
                          s=70, alpha=0.9, linewidth=0.5, zorder=10)
        
        # Removed connecting line as requested
        
        # Highlight current position with a larger filled marker
        if safe_time_idx > 0:
            # Get color and make brighter version for outline
            current_color = cmap(order_parameter[safe_time_idx])
            rgb = matplotlib.colors.to_rgb(current_color)
            bright_current = tuple(min(1.0, c * 1.5) for c in rgb)
            
            ax.scatter([times[safe_time_idx]], [order_parameter[safe_time_idx]], 
                     s=180, facecolors=current_color, 
                     edgecolors=bright_current, 
                     linewidth=1.0, zorder=15)
        
        # Add highlights at important thresholds
        ax.axhline(y=0.5, color='#aaaaaa', linestyle='--', alpha=0.5, zorder=1, 
                 label='Partial Synchronization (r=0.5)')
        ax.axhline(y=0.8, color='#ffffff', linestyle='--', alpha=0.5, zorder=1,
                 label='Strong Synchronization (r=0.8)')
        
        # Enhance the plot appearance
        ax.set_xlim(times.min(), times.max())
        ax.set_ylim(0, 1.05)
        ax.set_xlabel('Time', fontsize=13, fontweight='bold', color='white')
        ax.set_ylabel('Order Parameter r(t)', fontsize=13, fontweight='bold', color='white')
        ax.set_title(f'Phase Synchronization at t={times[safe_time_idx]:.2f}', 
                   fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Create custom grid
        ax.grid(True, color='#333333', alpha=0.5, linestyle=':')
        
        # Legend removed as requested
        
        # Add subtle box around the plot
        for spine in ax.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
            
        return fig
    
    # Create a more space-efficient layout 
    # First row: Oscillator phases plot (wider view)
    phases_plot_placeholder = st.empty()
    phases_plot_placeholder.pyplot(create_oscillator_phases_plot(time_index))
    
    # Second row: Circle plot and order parameter side by side
    col1, col2 = st.columns(2)
    with col1:
        circle_plot_placeholder = st.empty()
        circle_plot_placeholder.pyplot(create_phase_plot(time_index))
    
    with col2:
        order_plot_placeholder = st.empty()
        order_plot_placeholder.pyplot(create_order_parameter_plot(time_index))
    
    # Removed "Current Time" display as requested
    
    # Put animation controls first (at the top) with proper containment
    st.markdown("<h4 style='margin-bottom: 20px;'>Animation Controls</h4>", unsafe_allow_html=True)
    
    # Create a container for the buttons to ensure they stay together
    button_container = st.container()
    
    # Create centered columns for control buttons within the container
    with button_container:
        # Use wider columns for the buttons to center them better
        bcol1, bcol2, bcol3, bcol4, bcol5 = st.columns([1, 3, 3, 3, 1])
    
        # Set a fixed animation speed value for smoother playback
        animation_speed = 5.0  # Faster speed for smoother animation
        
        # Previous frame button
        if bcol2.button("âª Previous", use_container_width=True):
            if st.session_state.time_index > 0:
                st.session_state.time_index -= 1
                st.rerun()
        
        # Simplified Play/Pause button with text inside
        play_button_text = "â¯ï¸ Play"
        if bcol3.button(play_button_text, use_container_width=True):
            # Toggle animation state
            animate = True
            # Let the animation code run
        
        # Next frame button 
        if bcol4.button("â© Next", use_container_width=True):
            if st.session_state.time_index < len(times) - 1:
                st.session_state.time_index += 1
                st.rerun()
    
    # Create a separate container for time step display
    time_info_container = st.container()
    with time_info_container:
        time_col1, time_col2, time_col3 = st.columns([1, 2, 1])
        # Create a placeholder for displaying time step info 
        current_time_placeholder = time_col2.empty()
        
        # Function to update time step display
        def update_time_step_display(time_idx):
            # Calculate the actual time step (difference between consecutive time points)
            if time_idx > 0:
                time_step = times[time_idx] - times[time_idx-1]
            else:
                # Use first difference for the first point
                if len(times) > 1:
                    time_step = times[1] - times[0]
                else:
                    time_step = 0
                    
            current_time = times[time_idx]
            current_percent = (time_idx / (len(times) - 1)) * 100
            
            # Update the placeholder with the time step information
            current_time_placeholder.markdown(f"""
            <div style="padding: 10px; border-radius: 5px; background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(255, 0, 255, 0.2)); 
                        border: 1px solid rgba(255, 255, 255, 0.1); text-align: center;">
                <span style="font-size: 0.85rem; color: white;">Î”t = {time_step:.5f}</span><br>
                <span style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.7);">t = {current_time:.3f}</span>
            </div>
            """, unsafe_allow_html=True)
    
    # Initial display of time step
    update_time_step_display(st.session_state.time_index)
    
    # Add a slider to manually control visualization time point AFTER the buttons
    playback_container = st.container()
    time_index = playback_container.slider(
        "Time Point", 
        min_value=0, 
        max_value=len(times)-1, 
        value=st.session_state.time_index,
        help="Manually select a specific time point to display"
    )
    
    # Update session state when slider is moved
    if st.session_state.time_index != time_index:
        st.session_state.time_index = time_index
            
    # If animation is triggered
    if animate:
        # Get the current time index as the starting point
        start_idx = st.session_state.time_index
        
        # Ensure we're not starting beyond the available data
        max_valid_index = len(times) - 1
        if start_idx > max_valid_index:
            start_idx = 0
            st.session_state.time_index = 0
        
        # Calculate how many frames to skip for smoother animation
        frame_skip = max(1, len(times) // 100)  # Skip more frames for smoother playback
        
        # Set up a progress bar
        progress_bar = st.progress(0)
        
        # Animation loop with bounds checking
        for i in range(start_idx, min(len(times), max_valid_index + 1), frame_skip):
            # Update the session state
            st.session_state.time_index = i
            
            # Update progress bar - with safeguards to prevent division by zero
            denominator = max(1, max_valid_index - start_idx)  # Ensure non-zero denominator
            progress = min(1.0, (i - start_idx) / denominator)
            progress_bar.progress(progress)
            
            # Update all three plots
            # Safety checks for index values
            plot_idx = min(i, max_valid_index)
            circle_plot_placeholder.pyplot(create_phase_plot(plot_idx))
            phases_plot_placeholder.pyplot(create_oscillator_phases_plot(plot_idx))
            order_plot_placeholder.pyplot(create_order_parameter_plot(plot_idx))
            
            # Update the time step display with the current time index
            update_time_step_display(plot_idx)
            
            # Add a short pause to control animation speed
            time.sleep(0.02 / animation_speed)  # Much faster frame updates
        
        # Clear progress bar after animation
        progress_bar.empty()
    
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Visualization Guide</h3>
        <p>The <b>top plot</b> shows oscillator phases over time. Each horizontal trace represents one oscillator's phase trajectory with consistent coloring based on the oscillator's natural frequency.</p>
        <p>The <b>bottom left plot</b> shows oscillators on a unit circle. Each colored dot represents an oscillator at its current phase position. The blue arrow shows the mean field vector, with length equal to the order parameter r.</p>
        <p>The <b>bottom right plot</b> shows the order parameter over time, with color-coded dots showing the synchronization level from 0 (no synchronization) to 1 (complete synchronization).</p>
        <p>Click "â¯ï¸ Play" to watch all three visualizations animate together to see the synchronization process in real-time.</p>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Order Parameter Analysis</h3>
        <p>The order parameter r(t) measures the degree of synchronization among oscillators:</p>
        <ul>
            <li>r = 1: Complete synchronization (all oscillators have the same phase)</li>
            <li>r = 0: Complete desynchronization (phases are uniformly distributed)</li>
        </ul>
        <p>At critical coupling strength (K_c), the system transitions from desynchronized to partially synchronized state.</p>
    </div>
    """, unsafe_allow_html=True)

########################
# TAB 4: NUMERICAL CONSIDERATIONS TAB
########################
with tab4:
    # Update current tab in session state to track which tab is active
    st.session_state.current_tab = "Numerical Considerations"
    st.markdown("""
    <div class='section'>
    <ul>
        <li>The animation uses an explicit RK45 integrator with an adaptive, heuristically chosen maximum step size.</li>
        <li>No formal error or stability bounds are provided, however extreme coupling strengths, highly non-uniform frequency distributions, or large time steps may lead to numerical instability.</li>
        <li>For production-level accuracy, one should compare against sympletic or implicit schemes, tighten tolerances, and perform systematic convergence tests.</li>
        <li>Note that the time step is automatically calculated based on oscillator frequencies to ensure numerical stability and accuracy.</li>
    </ul>
    </div>
    """, unsafe_allow_html=True)

=== backups/checkpoint_before_refactor/app_original_1971_lines.py ===

import streamlit as st

# Set page config must be the first Streamlit command
st.set_page_config(
    page_title="Kuramoto Model Simulator",
    page_icon="ðŸ”„",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Let's strip down all CSS in the app to the minimum needed
st.markdown("""
<style>
    /* No special styling - let Streamlit's defaults handle alignment */
</style>
""", unsafe_allow_html=True)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors
from matplotlib.colors import LinearSegmentedColormap
import json
from src.models.kuramoto_model import KuramotoModel
from src.database.database import save_configuration
import time

# Initialize refresh state for network refresh button
if 'refresh_network' not in st.session_state:
    st.session_state.refresh_network = False

# Function to parse JSON parameters input
def parse_json_parameters(json_string):
    """
    Parse a JSON string containing Kuramoto simulation parameters.
    
    Expected format:
    {
        "n_oscillators": 10,
        "coupling_strength": 1.0,
        "network_type": "All-to-All", 
        "simulation_time": 10.0,
        "time_step": 0.1,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.2
        },
        "adjacency_matrix": [[0,1,1,...], [1,0,1,...], ...] (optional)
    }
    
    Returns:
    dict: Parameters dictionary containing all parsed values, or error message
    """
    try:
        # Parse the JSON string
        params = json.loads(json_string)
        
        # Initialize the result dictionary with default values
        result = {
            "n_oscillators": 10,
            "coupling_strength": 1.0,
            "network_type": "All-to-All",
            "simulation_time": 10.0,
            "time_step": 0.1,
            "random_seed": 42,
            "frequency_distribution": "Normal",
            "frequency_parameters": {
                "mean": 0.0,
                "std": 0.2
            },
            "adjacency_matrix": None
        }
        
        # Update with values from the JSON
        if "n_oscillators" in params:
            result["n_oscillators"] = int(params["n_oscillators"])
            
        if "coupling_strength" in params:
            result["coupling_strength"] = float(params["coupling_strength"])
            
        if "network_type" in params:
            valid_types = ["All-to-All", "Nearest Neighbor", "Random", "Custom Adjacency Matrix"]
            if params["network_type"] in valid_types:
                result["network_type"] = params["network_type"]
            
        if "simulation_time" in params:
            result["simulation_time"] = float(params["simulation_time"])
            
        # time_step is now automatically calculated based on oscillator frequencies
        # We keep this for backward compatibility with existing JSON configs
        if "time_step" in params:
            # We acknowledge the parameter but don't use it directly
            pass
            
        if "random_seed" in params:
            result["random_seed"] = int(params["random_seed"])
            
        if "frequency_distribution" in params:
            valid_distributions = ["Normal", "Uniform", "Custom", "Golden Ratio", "Bimodal"]
            if params["frequency_distribution"] in valid_distributions:
                result["frequency_distribution"] = params["frequency_distribution"]
            
        if "frequency_parameters" in params:
            fp = params["frequency_parameters"]
            if "mean" in fp and result["frequency_distribution"] == "Normal":
                result["frequency_parameters"]["mean"] = float(fp["mean"])
            if "std" in fp and result["frequency_distribution"] == "Normal":
                result["frequency_parameters"]["std"] = float(fp["std"])
            if "min" in fp and result["frequency_distribution"] == "Uniform":
                result["frequency_parameters"]["min"] = float(fp["min"])
            if "max" in fp and result["frequency_distribution"] == "Uniform":
                result["frequency_parameters"]["max"] = float(fp["max"])
            if "custom_values" in fp and result["frequency_distribution"] == "Custom":
                # Convert custom frequency values to floats
                result["frequency_parameters"]["custom_values"] = [float(x) for x in fp["custom_values"]]
        
        # Process the adjacency matrix if provided
        if "adjacency_matrix" in params:
            matrix_data = params["adjacency_matrix"]
            if isinstance(matrix_data, list) and len(matrix_data) > 0:
                try:
                    # Convert to numpy array and validate
                    adj_matrix = np.array(matrix_data, dtype=float)
                    
                    # Check if the matrix is square
                    if adj_matrix.shape[0] == adj_matrix.shape[1]:
                        result["adjacency_matrix"] = adj_matrix
                        # If adjacency matrix is provided, force network type to Custom
                        result["network_type"] = "Custom Adjacency Matrix"
                    else:
                        return None, f"Adjacency matrix must be square. Current shape: {adj_matrix.shape}"
                except Exception as e:
                    return None, f"Error processing adjacency matrix: {str(e)}"
        
        return result, None
        
    except Exception as e:
        # Return error message if parsing fails
        return None, str(e)

# Initialize session state for configuration loading
if 'loaded_config' not in st.session_state:
    st.session_state.loaded_config = None

# Check for temp imported parameters and apply them
# This handles imports from the JSON Parameter Import Section
if 'temp_imported_params' in st.session_state:
    params = st.session_state.temp_imported_params
    
    # Update session state with the parsed parameters
    st.session_state.n_oscillators = params["n_oscillators"]
    st.session_state.coupling_strength = params["coupling_strength"]
    st.session_state.network_type = params["network_type"]
    st.session_state.simulation_time = params["simulation_time"]
    # time_step is no longer used, it's automatically calculated
    st.session_state.random_seed = params["random_seed"]
    st.session_state.freq_type = params["frequency_distribution"]
    
    # Update frequency parameters based on distribution type
    if params["frequency_distribution"] == "Normal":
        st.session_state.freq_mean = params["frequency_parameters"]["mean"]
        st.session_state.freq_std = params["frequency_parameters"]["std"]
    elif params["frequency_distribution"] == "Uniform":
        st.session_state.freq_min = params["frequency_parameters"]["min"]
        st.session_state.freq_max = params["frequency_parameters"]["max"]
    elif params["frequency_distribution"] == "Custom" and "custom_values" in params["frequency_parameters"]:
        st.session_state.custom_freqs = ", ".join(str(x) for x in params["frequency_parameters"]["custom_values"])
    
    # Handle custom adjacency matrix if present
    if params["adjacency_matrix"] is not None:
        matrix = params["adjacency_matrix"]
        
        # Convert matrix to string representation for the text area
        matrix_str = ""
        for row in matrix:
            matrix_str += ", ".join(str(val) for val in row) + "\n"
        
        # Update session state for adjacency matrix
        st.session_state.adj_matrix_input = matrix_str.strip()
        st.session_state.loaded_adj_matrix = matrix
    
    # Clear the temp parameters to avoid reapplying
    del st.session_state.temp_imported_params

# Apply loaded configuration if available
if st.session_state.loaded_config is not None:
    config = st.session_state.loaded_config
    
    # Update session state with configuration values
    st.session_state.n_oscillators = config['n_oscillators']
    st.session_state.coupling_strength = config['coupling_strength']
    st.session_state.simulation_time = config['simulation_time']
    # time_step is no longer needed - it's automatically calculated
    st.session_state.random_seed = int(config['random_seed']) # Ensure it's an integer
    st.session_state.network_type = config['network_type']
    st.session_state.freq_type = config['frequency_distribution']
    
    # Update frequency distribution parameters based on type
    freq_params = config.get('frequency_params', {})
    if freq_params:
        try:
            freq_params = json.loads(freq_params)
        except:
            # It's already a dictionary
            pass
            
        if config['frequency_distribution'] == "Normal":
            st.session_state.freq_mean = freq_params.get('mean', 0.0)
            st.session_state.freq_std = freq_params.get('std', 1.0)
        elif config['frequency_distribution'] == "Uniform":
            st.session_state.freq_min = freq_params.get('min', -1.0)
            st.session_state.freq_max = freq_params.get('max', 1.0)
        elif config['frequency_distribution'] == "Bimodal":
            st.session_state.peak1 = freq_params.get('peak1', -1.0)
            st.session_state.peak2 = freq_params.get('peak2', 1.0)
        elif config['frequency_distribution'] == "Custom":
            if 'custom_values' in freq_params and isinstance(freq_params['custom_values'], list):
                st.session_state.custom_freqs = ', '.join(map(str, freq_params['custom_values']))
            elif 'values' in freq_params and isinstance(freq_params['values'], list):
                st.session_state.custom_freqs = ', '.join(map(str, freq_params['values']))
    
    # Handle custom adjacency matrix if present
    if config['network_type'] == "Custom Adjacency Matrix" and config.get('adjacency_matrix') is not None:
        try:
            matrix = config['adjacency_matrix']
            if isinstance(matrix, bytes):
                import pickle
                matrix = pickle.loads(matrix)
            elif isinstance(matrix, list):
                # Convert list to numpy array if it's still a list
                matrix = np.array(matrix)
            
            # Make sure no self-loops (diagonal elements should be zero)
            # This is important to ensure consistent visualization
            if hasattr(matrix, 'shape') and matrix.shape[0] == matrix.shape[1]:
                np.fill_diagonal(matrix, 0)
                
            # Print debug info
            print(f"Loading adjacency matrix: type={type(matrix)}, shape={matrix.shape if hasattr(matrix, 'shape') else 'unknown'}")
            
            if hasattr(matrix, 'shape'):
                print(f"Matrix sum: {np.sum(matrix)}, non-zeros: {np.count_nonzero(matrix)}")
                if matrix.shape[0] >= 3:
                    print("Sample (top-left 3x3):")
                    print(matrix[:3, :3])
                
            # Convert matrix to string representation for the text area
            matrix_str = ""
            for row in matrix:
                matrix_str += ", ".join(str(val) for val in row) + "\n"
            st.session_state.adj_matrix_input = matrix_str.strip()
            
            # Store the matrix for later use in this session
            # This ensures the matrix is properly passed to the simulation
            # Always update the matrix in session state - force overwrite to ensure latest is used
            st.session_state.loaded_adj_matrix = matrix
            print(f"Stored adjacency matrix in session state with shape {matrix.shape}")
                
        except Exception as e:
            st.warning(f"Could not load custom adjacency matrix: {str(e)}")
    
    # Clear the loaded config to prevent reapplying it on next rerun
    st.session_state.loaded_config = None

# Set up Matplotlib style for dark theme plots
plt.style.use('dark_background')
plt.rcParams.update({
    'axes.facecolor': '#1e1e1e',
    'figure.facecolor': '#1e1e1e',
    'savefig.facecolor': '#1e1e1e',
    'axes.grid': True,
    'grid.color': '#444444',
    'grid.alpha': 0.3,
    'grid.linestyle': '--',
    'axes.edgecolor': '#444444',
    'xtick.color': '#888888',
    'ytick.color': '#888888',
    'text.color': '#ffffff',
    'axes.labelcolor': '#ffffff',
    'axes.titlecolor': '#ffffff',
    'lines.linewidth': 2,
})

# Page config is now at the top of the file
# This comment is kept to maintain file structure

# Import Aclonica font from Google Fonts
st.markdown("""
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Aclonica&display=swap" rel="stylesheet">
""", unsafe_allow_html=True)

# Load custom CSS
with open("src/styles/styles.css") as f:
    st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)

# Get the base64 encoded image
with open("static/images/wisp.base64", "r") as f:
    encoded_image = f.read()

# Add custom background and custom font
st.markdown(f"""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Aclonica&display=swap');
    
    .stApp {{
        background-image: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), 
                         url('data:image/jpeg;base64,{encoded_image}');
        background-size: cover;
        background-repeat: no-repeat;
        background-attachment: fixed;
    }}
    
    /* Ensure Aclonica font is applied everywhere */
    body, div, p, h1, h2, h3, h4, h5, h6, li, span, label, button, .sidebar .sidebar-content {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Fix Streamlit buttons to use Aclonica */
    button, .stButton button, .stDownloadButton button {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Fix Streamlit widgets text */
    .stSlider label, .stSelectbox label, .stNumberInput label {{
        font-family: 'Aclonica', sans-serif !important;
    }}
    
    /* Apply gradient_text1 to sidebar labels */
    .sidebar .sidebar-content label {{
        background: -webkit-linear-gradient(#14a5ff, #8138ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: bold;
    }}
</style>
""", unsafe_allow_html=True)

# Title
st.markdown("<h1 class='gradient_text1'>Kuramoto Model Simulator</h1>", unsafe_allow_html=True)

# Let Streamlit handle the styling
# No custom CSS needed here

# Create main sidebar parameters header at the top
st.sidebar.markdown("<h2 class='gradient_text1'>Simulation Parameters</h2>", unsafe_allow_html=True)

# Add Time Controls Section first
st.sidebar.markdown("<h3 class='gradient_text1'>Time Controls</h3>", unsafe_allow_html=True)

# Simulation time parameters
simulation_time = st.sidebar.slider(
    "Simulation Time",
    min_value=1.0,
    max_value=200.0,
    value=100.0,  # Set default value to 100.0
    step=1.0,
    help="Total simulation time",
    key="simulation_time"
)

# Time step is now automatically calculated based on oscillator frequencies and doesn't need a UI control
# Default value maintained for backward compatibility with database functions
time_step = 0.01

# Add separator before individual parameters
st.sidebar.markdown("<hr style='margin: 15px 0px; border-color: rgba(255,255,255,0.2);'>", unsafe_allow_html=True)

# Create subheading for manual parameters
st.sidebar.markdown("<h3 class='gradient_text1'>Manual Configuration</h3>", unsafe_allow_html=True)

# Initialize session state for parameters if they don't exist
if 'n_oscillators' not in st.session_state:
    st.session_state.n_oscillators = 10
if 'coupling_strength' not in st.session_state:
    st.session_state.coupling_strength = 1.0
if 'freq_type' not in st.session_state:
    st.session_state.freq_type = "Normal"
if 'freq_mean' not in st.session_state:
    st.session_state.freq_mean = 0.0
if 'freq_std' not in st.session_state:
    st.session_state.freq_std = 1.0
if 'freq_min' not in st.session_state:
    st.session_state.freq_min = -1.0
if 'freq_max' not in st.session_state:
    st.session_state.freq_max = 1.0
if 'peak1' not in st.session_state:
    st.session_state.peak1 = -1.0
if 'peak2' not in st.session_state:
    st.session_state.peak2 = 1.0
if 'custom_freqs' not in st.session_state:
    st.session_state.custom_freqs = "0.5, 1.0, 1.5, 2.0, 2.5, 3.0, -0.5, -1.0, -1.5, -2.0"
if 'simulation_time' not in st.session_state:
    st.session_state.simulation_time = 100.0
# Default time_step value maintained for backward compatibility
time_step = 0.01
# network_type is now initialized in the network connectivity section
if 'adj_matrix_input' not in st.session_state:
    # Create a default example matrix for a 5x5 ring topology
    default_matrix = "0, 1, 0, 0, 1\n1, 0, 1, 0, 0\n0, 1, 0, 1, 0\n0, 0, 1, 0, 1\n1, 0, 0, 1, 0"
    st.session_state.adj_matrix_input = default_matrix

# For auto-adjusting oscillator count based on matrix dimensions
if 'next_n_oscillators' not in st.session_state:
    st.session_state.next_n_oscillators = None
    
# If we have a pending oscillator count update from the previous run, apply it now
if st.session_state.next_n_oscillators is not None:
    print(f"Updating oscillator count from {st.session_state.n_oscillators} to {st.session_state.next_n_oscillators}")
    st.session_state.n_oscillators = st.session_state.next_n_oscillators
    st.session_state.next_n_oscillators = None  # Clear the pending update

# Number of oscillators slider
n_oscillators = st.sidebar.slider(
    "Number of Oscillators",
    min_value=2,
    max_value=50,
    step=1,
    help="Number of oscillators in the system",
    key="n_oscillators"
)

# Coupling strength slider
coupling_strength = st.sidebar.slider(
    "Coupling Strength (K)",
    min_value=0.0,
    max_value=10.0,
    step=0.1,
    help="Strength of coupling between oscillators",
    key="coupling_strength"
)

# Frequency distribution type
freq_type = st.sidebar.selectbox(
    "Frequency Distribution",
    ["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"],
    index=["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"].index(st.session_state.freq_type) if st.session_state.freq_type in ["Normal", "Uniform", "Bimodal", "Golden Ratio", "Custom"] else 0,
    help="Distribution of natural frequencies",
    key="freq_type"
)

# Parameters for frequency distribution
if freq_type == "Normal":
    freq_mean = st.sidebar.slider("Mean", -2.0, 2.0, step=0.1, key="freq_mean")
    freq_std = st.sidebar.slider("Standard Deviation", 0.1, 3.0, step=0.1, key="freq_std")
    frequencies = np.random.normal(freq_mean, freq_std, n_oscillators)
    
elif freq_type == "Uniform":
    freq_min = st.sidebar.slider("Minimum", -5.0, 0.0, step=0.1, key="freq_min")
    freq_max = st.sidebar.slider("Maximum", 0.0, 5.0, step=0.1, key="freq_max")
    frequencies = np.random.uniform(freq_min, freq_max, n_oscillators)
    
elif freq_type == "Bimodal":
    peak1 = st.sidebar.slider("Peak 1", -5.0, 0.0, step=0.1, key="peak1")
    peak2 = st.sidebar.slider("Peak 2", 0.0, 5.0, step=0.1, key="peak2")
    mix = np.random.choice([0, 1], size=n_oscillators)
    freq1 = np.random.normal(peak1, 0.3, n_oscillators)
    freq2 = np.random.normal(peak2, 0.3, n_oscillators)
    frequencies = mix * freq1 + (1 - mix) * freq2

elif freq_type == "Golden Ratio":
    # The golden ratio (phi) â‰ˆ 1.618033988749895
    phi = (1 + 5**0.5) / 2
    
    # Create a golden ratio sequence starting at -3
    golden_ratio_start = -3.0
    st.sidebar.markdown(f"""
    <div style="background-color: rgba(255,200,0,0.15); padding: 10px; border-radius: 5px;">
    <p><b>Golden Ratio Distribution</b></p>
    <p>This creates a sequence where each frequency follows the golden ratio (Ï† â‰ˆ 1.618), 
    starting from {golden_ratio_start}.</p>
    <p>Each oscillator's frequency is: {golden_ratio_start} + iÂ·Ï†</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Generate frequencies that follow the golden ratio in sequence
    frequencies = np.array([golden_ratio_start + i * phi for i in range(n_oscillators)])
    
else:  # Custom
    custom_freqs = st.sidebar.text_area(
        "Enter custom frequencies (comma-separated)",
        value=st.session_state.custom_freqs,
        height=150,
        key="custom_freqs"
    )
    try:
        frequencies = np.array([float(x.strip()) for x in custom_freqs.split(',')])
        # Ensure we have the right number of frequencies
        if len(frequencies) < n_oscillators:
            # Repeat the pattern if not enough values
            frequencies = np.tile(frequencies, int(np.ceil(n_oscillators / len(frequencies))))
        frequencies = frequencies[:n_oscillators]  # Trim if too many
    except:
        st.sidebar.error("Invalid frequency input. Using normal distribution instead.")
        frequencies = np.random.normal(0, 1, n_oscillators)

# Random seed setting
if "random_seed" not in st.session_state:
    st.session_state.random_seed = 42

random_seed = int(st.sidebar.number_input(
    "Random Seed", 
    min_value=0,
    step=1,
    help="Seed for reproducibility",
    key="random_seed"
))

# Network Connectivity Configuration
st.sidebar.markdown("<h3 class='gradient_text1'>Network Connectivity</h3>", unsafe_allow_html=True)

# Add a refresh button at the top of the Network Connectivity section
if st.sidebar.button("ðŸ”„ Refresh Simulation", key="refresh_btn"):
    st.session_state.refresh_network = True
    print("Network refresh requested via main refresh button")
    st.rerun()

# Create radio button for network type without specifying both index and session state key
# This fixes the warning: "widget created with default value but also had value set via Session State API"
options = ["All-to-All", "Nearest Neighbor", "Random", "Custom Adjacency Matrix"]
if "network_type" not in st.session_state:
    # Only set this if it's not already in session state
    st.session_state.network_type = "Random"

# Get current index
current_index = options.index(st.session_state.network_type)

# Create the radio button
network_type = st.sidebar.radio(
    "Network Type",
    options=options,
    index=current_index,
    help="Define how oscillators are connected to each other"
)

# Update session state if changed
if network_type != st.session_state.network_type:
    st.session_state.network_type = network_type

# Custom adjacency matrix input
adj_matrix = None
# Check if we have a loaded adjacency matrix from a configuration
if 'loaded_adj_matrix' in st.session_state:
    adj_matrix = st.session_state.loaded_adj_matrix
    print(f"Retrieved adjacency matrix from session state with shape {adj_matrix.shape if hasattr(adj_matrix, 'shape') else 'unknown'}")
    
    # Safety check to ensure matrix is valid
    if hasattr(adj_matrix, 'shape') and adj_matrix.shape[0] > 0:
        print(f"Matrix looks valid: shape={adj_matrix.shape}, sum={np.sum(adj_matrix)}, non-zeros={np.count_nonzero(adj_matrix)}")
        
        # CRITICAL: We need to force the correct network type
        # This needs to take precedence over what's selected in the UI radio button
        if network_type != "Custom Adjacency Matrix":
            print("Detected loaded matrix with network type that doesn't match 'Custom Adjacency Matrix'.")
            print(f"Current network_type is '{network_type}' but will use matrix internally")
    else:
        print("Warning: Found loaded_adj_matrix in session state but it appears invalid:")
        print(f"Matrix type: {type(adj_matrix)}")
        if hasattr(adj_matrix, 'shape'):
            print(f"Shape: {adj_matrix.shape}")
        adj_matrix = None  # Reset to None if invalid matrix

if network_type == "Custom Adjacency Matrix":
    st.sidebar.markdown("""
    <div style="font-size: 0.85em;">
    Enter your adjacency matrix as comma-separated values. Each row should be on a new line.
    <br>Example for 3 oscillators:
    <pre style="background-color: #222; padding: 5px; border-radius: 3px;">
0, 1, 0.5
1, 0, 0.8
0.5, 0.8, 0</pre>
    </div>
    """, unsafe_allow_html=True)
    
    # Create a default example matrix if no prior matrix exists
    if not st.session_state.adj_matrix_input:
        # Create a simple default example for smaller number of oscillators
        default_matrix = ""
        for i in range(min(5, n_oscillators)):
            row = []
            for j in range(min(5, n_oscillators)):
                if i == j:
                    row.append("0")  # No self-connections
                elif abs(i-j) == 1 or abs(i-j) == min(5, n_oscillators)-1:  # Ring-neighbors
                    row.append("1")  # Connected
                else:
                    row.append("0")  # Not connected
            default_matrix += ", ".join(row) + "\n"
                
    # Make sure we have a non-empty value for the text area
    if network_type == "Custom Adjacency Matrix" and not st.session_state.adj_matrix_input:
        print("Custom matrix selected but no existing input - initializing default")
        st.session_state.adj_matrix_input = default_matrix
        
    adj_matrix_input = st.sidebar.text_area(
        "Adjacency Matrix",
        value=st.session_state.adj_matrix_input,
        height=200,
        help="Enter the adjacency matrix as comma-separated values, each row on a new line",
        key="adj_matrix_input"
    )
    
    # Process the input adjacency matrix
    if adj_matrix_input:
        try:
            # Parse the input text into a numpy array
            rows = adj_matrix_input.strip().split('\n')
            
            # Ensure we have at least one row
            if len(rows) == 0:
                raise ValueError("No data found in matrix input")
                
            # Process each row, removing extra spaces and parsing values
            adj_matrix = []
            for row in rows:
                # Skip empty rows
                if not row.strip():
                    continue
                    
                # Process values in this row
                values = []
                for val in row.split(','):
                    # Convert to float, handling extra whitespace
                    cleaned_val = val.strip()
                    if cleaned_val:  # Skip empty entries
                        values.append(float(cleaned_val))
                
                # Ensure row has data
                if values:
                    adj_matrix.append(values)
            
            # Make sure we have a valid matrix with data
            if not adj_matrix:
                raise ValueError("Could not find valid numeric data in input")
                
            # Convert to numpy array for faster processing
            adj_matrix = np.array(adj_matrix)
            
            # Validate the adjacency matrix
            if adj_matrix.shape[0] != adj_matrix.shape[1]:
                st.sidebar.error(f"The adjacency matrix must be square. Current shape: {adj_matrix.shape}")
            elif adj_matrix.shape[0] != n_oscillators:
                # We can't modify widget session state once widgets are created,
                # so we'll save the desired dimension in a different session state variable
                matrix_dim = adj_matrix.shape[0]
                
                # Log information
                print(f"Matrix dimensions ({matrix_dim}) don't match current oscillator count ({n_oscillators})")
                
                # Store the matrix as is, don't try to resize it
                st.session_state.next_n_oscillators = matrix_dim
                
                # Show message explaining what's happening
                st.sidebar.info(f"""
                Matrix size ({matrix_dim}Ã—{matrix_dim}) differs from current oscillator count ({n_oscillators}).
                The matrix will be used as-is for this simulation. Next time you interact with the UI, 
                the oscillator count will automatically update to match your matrix dimensions.
                """)
                
                # Keep local variable as is, use adj_matrix without modification
            else:
                st.sidebar.success("Adjacency matrix validated successfully!")
                
                # Add a dedicated button to force network visualization refresh
                if st.sidebar.button("ðŸ”„ Refresh", key="force_refresh_btn"):
                    st.session_state.refresh_network = True
                    print("Network refresh requested via button")
                    st.rerun()
                
                # Add save preset button and input field
                with st.sidebar.expander("Save as Preset"):
                    preset_name = st.text_input("Preset Name", key="preset_name", 
                                             placeholder="Enter a name for this matrix")
                    if st.button("ðŸ’¾ Save Preset", key="save_preset_btn"):
                        if preset_name:
                            # Save the configuration with current parameters
                            config_id = save_configuration(
                                name=preset_name,
                                n_oscillators=adj_matrix.shape[0],
                                coupling_strength=coupling_strength,
                                simulation_time=simulation_time,
                                time_step=0.01,  # Default value for backward compatibility
                                random_seed=random_seed,  # Use the UI's random_seed
                                network_type="Custom Adjacency Matrix",
                                frequency_distribution=freq_type,
                                frequency_params=json.dumps({
                                    "mean": float(freq_mean) if 'freq_mean' in locals() else 0.0,
                                    "std": float(freq_std) if 'freq_std' in locals() else 1.0,
                                    "min": float(freq_min) if 'freq_min' in locals() else -1.0,
                                    "max": float(freq_max) if 'freq_max' in locals() else 1.0
                                }),
                                adjacency_matrix=adj_matrix
                            )
                            st.success(f"Saved preset '{preset_name}' successfully!")
                            print(f"Saved matrix preset: '{preset_name}' with shape {adj_matrix.shape}")
                        else:
                            st.error("Please enter a preset name")
                
            # Store in session state for persistence
            st.session_state.loaded_adj_matrix = adj_matrix
            print(f"Updated adjacency matrix in session state with shape {adj_matrix.shape}")
                
        except Exception as e:
            st.sidebar.error(f"Error parsing matrix: {str(e)}")
            print(f"Matrix parsing error: {str(e)}")
            print(f"Input was: '{adj_matrix_input}'")
            adj_matrix = None


# Add JSON Configuration section at the bottom of the sidebar
st.sidebar.markdown("<hr style='margin: 15px 0px; border-color: rgba(255,255,255,0.2);'>", unsafe_allow_html=True)
st.sidebar.markdown("<h3 class='gradient_text1'>JSON Configuration</h3>", unsafe_allow_html=True)

# Initialize session state for JSON example if not present
if 'json_example' not in st.session_state:
    st.session_state.json_example = ""

# Display text area for JSON input (larger and left-aligned)
json_input = st.sidebar.text_area(
    "Import/Export Parameters",
    value=st.session_state.json_example,
    height=200,
    placeholder='Paste your JSON configuration here...',
    help="Enter a valid JSON configuration for the Kuramoto simulation"
)

# Add a collapsible section with examples but without parameter details
with st.sidebar.expander("Examples", expanded=False):
    example_json = {
        "n_oscillators": 10,
        "coupling_strength": 1.0,
        "network_type": "All-to-All", 
        "simulation_time": 100.0,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.2
        }
    }
    
    st.code(json.dumps(example_json, indent=2), language="json")
    
    # Add small-world network example
    st.markdown("**Small-world network example:**")
    
    # Generate a sample small-world network
    n = 10
    sample_matrix = np.zeros((n, n))
    for i in range(n):
        # Connect to neighbors
        for j in range(1, 3):
            sample_matrix[i, (i+j) % n] = 1
            sample_matrix[i, (i-j) % n] = 1
            
    # Add a few random long-range connections
    np.random.seed(42)
    for _ in range(5):
        i = np.random.randint(0, n)
        j = np.random.randint(0, n)
        if i != j and sample_matrix[i, j] == 0:
            sample_matrix[i, j] = 1
            sample_matrix[j, i] = 1
            
    # Create example with matrix
    complex_example = {
        "n_oscillators": n,
        "coupling_strength": 0.8,
        "network_type": "Custom Adjacency Matrix",
        "simulation_time": 100.0,
        "random_seed": 42,
        "frequency_distribution": "Normal",
        "frequency_parameters": {
            "mean": 0.0,
            "std": 0.1
        },
        "adjacency_matrix": sample_matrix.tolist()
    }
    
    # Add button to use this example - with smaller text
    if st.button("Use Small-World", key="small_world_btn"):
        st.session_state.json_example = json.dumps(complex_example, indent=2)
        st.rerun()

# Add import button and logic
if st.sidebar.button("Import Parameters", key="sidebar_import_json_button"):
    if json_input.strip():
        try:
            # Parse the JSON input
            params, error = parse_json_parameters(json_input)
            
            if error:
                st.sidebar.error(f"Error parsing JSON: {error}")
            else:
                # Update session state with the parsed parameters
                if params is not None:
                    # Store all parameters in a temporary variable in session state
                    # This is to avoid the error when trying to change widget values after initialization
                    st.session_state.temp_imported_params = params
                    
                    # Show success message
                    st.sidebar.success("Parameters imported successfully! Applying settings...")
                    
                    # Rerun the app to apply the changes
                    st.rerun()
                else:
                    st.sidebar.error("Failed to parse JSON parameters. Please check your input format.")
        except Exception as e:
            st.sidebar.error(f"Error processing parameters: {str(e)}")
    else:
        st.sidebar.warning("Please enter JSON configuration before importing.")


# Create tabs for different visualizations (Network is default tab)
tab1, tab2, tab3, tab4 = st.tabs(["Network", "Distributions", "Animation", "Numerical Considerations"])

# Set a unique key for each tab to force refresh of the Network tab
if 'current_tab' not in st.session_state:
    st.session_state.current_tab = "Network"
    
# Add a hidden button that is programmatically clicked when checking a custom matrix
tab_key = f"tab_refresh_{int(time.time())}"
if st.session_state.current_tab == "Network" and adj_matrix is not None:
    # This ensures the network tab is refreshed when the adjacency matrix changes
    st.session_state.refresh_network = True

# Determine the effective network type for display and matrix creation
# If we have a custom matrix, ALWAYS force the network type to custom
# regardless of what's displayed in the UI
if adj_matrix is not None:
    print("Detected valid adjacency matrix - forcing internal network type to Custom")
    print(f"Matrix shape: {adj_matrix.shape}, sum: {np.sum(adj_matrix)}, non-zeros: {np.count_nonzero(adj_matrix)}")
    
    # Don't change the UI selection, but use Custom type for all internal processing
    network_type_internal = "Custom Adjacency Matrix"
    
    # CRITICAL: We must NOT delete the matrix from session state until we've used it successfully
    # Otherwise, it will be lost on the next rerun when Streamlit rebuilds the application
    
    # Keep a flag to signal we've saved the matrix for this session
    if 'using_loaded_matrix' not in st.session_state:
        st.session_state.using_loaded_matrix = True
        print("First use of loaded matrix - will keep in session state")
else:
    # Use the selected network type
    network_type_internal = network_type
    
    # If we don't have a custom matrix but the UI type is set to custom,
    # we need to ensure this is communicated clearly
    if network_type == "Custom Adjacency Matrix" and adj_matrix is None:
        # Use custom styled message with orange background instead of the default yellow warning
        # This matches the sidebar error messages styling
        st.markdown("""
        <div style="background-color: rgba(255,150,0,0.15); color: #ffaa50; 
                    padding: 10px; border-radius: 15px; border-left: 5px solid #ff8800;">
            <b>Matrix Input:</b> Please enter your custom adjacency matrix in the sidebar.
            The format should be comma-separated values with each row on a new line.
        </div>
        """, unsafe_allow_html=True)
        print("Warning: Custom adjacency matrix selected but no valid matrix found")

# Function to simulate model
@st.cache_data(ttl=300)
def run_simulation(n_oscillators, coupling_strength, frequencies, simulation_time, time_step=None, random_seed=None, 
                  adjacency_matrix=None):
    """
    Run a Kuramoto model simulation with the specified parameters and return the results.
    
    Parameters:
    -----------
    n_oscillators : int
        Number of oscillators
    coupling_strength : float
        Coupling strength parameter K
    frequencies : ndarray
        Natural frequencies of oscillators
    simulation_time : float
        Total simulation time
    time_step : float, optional
        DEPRECATED: This parameter is no longer used. The time step is now automatically calculated
        based on oscillator frequencies to ensure numerical stability and accuracy.
        The parameter is kept for backward compatibility with saved configurations.
    random_seed : int, optional
        Seed for random number generation
    adjacency_matrix : ndarray, optional
        Custom adjacency matrix defining network connectivity
        
    Returns:
    --------
    tuple
        (model, times, phases, order_parameter)
    """
    # Convert random_seed to integer to prevent type errors
    if random_seed is not None:
        random_seed = int(random_seed)
    
    # Initialize the model with given parameters
    model = KuramotoModel(
        n_oscillators=n_oscillators,
        coupling_strength=coupling_strength,
        frequencies=frequencies,
        adjacency_matrix=adjacency_matrix,
        simulation_time=simulation_time,
        random_seed=random_seed
    )
    
    # Run the simulation with automatically calculated time step
    try:
        # Force at least 500 time points for visualization
        times, phases, order_parameter = model.simulate(min_time_points=500)
        print("Simulation successful!")
        print(f"  times shape: {times.shape if hasattr(times, 'shape') else 'N/A'}")
        print(f"  phases shape: {phases.shape if hasattr(phases, 'shape') else 'N/A'}")
        print(f"  order_parameter shape: {order_parameter.shape if hasattr(order_parameter, 'shape') else 'N/A'}")
    except Exception as e:
        print(f"Error in simulation: {str(e)}")
        import traceback
        traceback.print_exc()
        # Return empty arrays for graceful failure
        times = np.linspace(0, simulation_time, 100)
        phases = np.zeros((n_oscillators, 100))
        order_parameter = np.zeros(100)
    
    # Return results
    return model, times, phases, order_parameter

# Run the simulation
# If we have a custom adjacency matrix, adjust the oscillator count to match matrix dimensions
sim_n_oscillators = n_oscillators
if adj_matrix is not None:
    matrix_dim = adj_matrix.shape[0]
    if matrix_dim != n_oscillators:
        print(f"Adjusting simulation oscillator count to match matrix dimensions: {matrix_dim}")
        sim_n_oscillators = matrix_dim
        
        # Also adjust frequencies to match this count
        if len(frequencies) != sim_n_oscillators:
            print(f"Adjusting frequencies array from length {len(frequencies)} to {sim_n_oscillators}")
            if len(frequencies) > sim_n_oscillators:
                # Truncate if too many
                frequencies = frequencies[:sim_n_oscillators]
            else:
                # Extend by cycling through existing values if too few
                frequencies = np.resize(frequencies, sim_n_oscillators)

# Get current random seed from session state
current_random_seed = st.session_state.random_seed if "random_seed" in st.session_state else 42

# Run simulation
model, times, phases, order_parameter = run_simulation(
    n_oscillators=sim_n_oscillators,
    coupling_strength=coupling_strength,
    frequencies=frequencies,
    simulation_time=simulation_time,
    time_step=None,  # Not actually used, time_step is auto-calculated
    random_seed=current_random_seed,
    adjacency_matrix=adj_matrix
)

########################
# TAB 1: NETWORK TAB
########################
with tab1:
    # Update current tab in session state to track which tab is active
    st.session_state.current_tab = "Network"
    
    # Force a reload when we have a custom matrix change
    if 'refresh_network' in st.session_state and st.session_state.refresh_network:
        # Reset the flag to prevent infinite reloads
        st.session_state.refresh_network = False
        # This will cause network visualization to rebuild completely
        st.empty().button("Refresh Network", key=f"network_refresh_{time.time()}", on_click=lambda: None)
    st.markdown("<h2 class='gradient_text2'>Network Structure</h2>", unsafe_allow_html=True)
    
    # Display simulation information
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Create a network visualization
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5), gridspec_kw={'width_ratios': [2, 1]})
    
    # Import networkx for graph visualization
    import networkx as nx
    
    # Make sure adj_matrix is defined for all network types
    if network_type_internal == "All-to-All":
        # For all-to-all, create a fully connected matrix with uniform coupling
        network_adj_matrix = np.ones((n_oscillators, n_oscillators))
        np.fill_diagonal(network_adj_matrix, 0)  # No self-connections
    elif network_type_internal == "Nearest Neighbor":
        # For nearest neighbor, create a ring topology
        network_adj_matrix = np.zeros((n_oscillators, n_oscillators))
        for i in range(n_oscillators):
            # Connect to left and right neighbors on the ring
            network_adj_matrix[i, (i-1) % n_oscillators] = 1
            network_adj_matrix[i, (i+1) % n_oscillators] = 1
    elif network_type_internal == "Random":
        # For random, create random connections with 20% probability
        np.random.seed(current_random_seed)  # Use same seed for reproducibility
        network_adj_matrix = np.random.random((n_oscillators, n_oscillators)) < 0.2
        network_adj_matrix = network_adj_matrix.astype(float)
        np.fill_diagonal(network_adj_matrix, 0)  # No self-connections
    else:  # Custom Adjacency Matrix
        if adj_matrix is not None:
            # Make sure we're using a copy of the matrix to avoid modifying the original
            network_adj_matrix = np.array(adj_matrix, copy=True)
            
            # This section handles the case where network_adj_matrix dimensions
            # don't match n_oscillators, which might happen in rare cases
            if network_adj_matrix.shape[0] != n_oscillators:
                print(f"Network matrix dimensions mismatch: matrix is {network_adj_matrix.shape} but n_oscillators={n_oscillators}")
                
                # Here we directly use the matrix at its current dimensions without changing session state
                # This is safe because we're not modifying widget values, just local processing
                n_oscillators = network_adj_matrix.shape[0]
                print(f"Using matrix at its native dimension: {n_oscillators}x{n_oscillators}")
            
            # Print detailed debug info
            print(f"Using custom adjacency matrix with shape {network_adj_matrix.shape}")
            print(f"Sum of elements: {np.sum(network_adj_matrix)}")
            print(f"Number of non-zero elements: {np.count_nonzero(network_adj_matrix)}")
            if network_adj_matrix.shape[0] >= 3:
                print("Sample (top-left 3x3):")
                print(network_adj_matrix[:3, :3])
        else:
            print("Warning: No custom adjacency matrix provided, using fallback")
            # Create a default matrix but NOT fully connected
            # Use a simple ring structure instead as fallback
            network_adj_matrix = np.zeros((n_oscillators, n_oscillators))
            for i in range(n_oscillators):
                network_adj_matrix[i, (i-1) % n_oscillators] = 1
                network_adj_matrix[i, (i+1) % n_oscillators] = 1
    
    # Create a graph visualization using networkx
    # Ensure the adjacency matrix has no self-loops (diagonal should be zero)
    np.fill_diagonal(network_adj_matrix, 0)
    
    # Print debug info
    if network_type_internal == "Custom Adjacency Matrix":
        print("Network adjacency matrix before creating graph:")
        print(f"Shape: {network_adj_matrix.shape}")
        print(f"Sum of elements: {np.sum(network_adj_matrix)}")
        print(f"Number of non-zero elements: {np.count_nonzero(network_adj_matrix)}")
        print(f"Sample of matrix: {network_adj_matrix[:3, :3] if network_adj_matrix.shape[0] >= 3 else network_adj_matrix}")
        
        # Ensure the adjacency matrix has proper values for building a network
        # Some users might enter very small values (like 0.01) that don't register as edges
        # Convert anything > 0.1 to a definite edge to ensure network is visible
        adj_for_network = network_adj_matrix.copy()
        adj_for_network[adj_for_network > 0.1] = 1.0
        if np.count_nonzero(adj_for_network) != np.count_nonzero(network_adj_matrix):
            print(f"Enhancing {np.count_nonzero(adj_for_network) - np.count_nonzero(network_adj_matrix)} weak connections for visualization")
        
        # Use the enhanced matrix for network visualization only
        G = nx.from_numpy_array(adj_for_network)
    else:
        # Use original matrix for standard network types
        G = nx.from_numpy_array(network_adj_matrix)
    
    # Create custom colormap that matches our gradient_text1 theme for nodes
    custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                ["#9933FF", "#FF33FF", "#FFAA00", "#50FF96"], 
                                                N=256)
    
    # Sort oscillators by their natural frequency for consistent coloring
    # This is the SAME color assignment used throughout all visualizations
    sorted_indices = np.argsort(frequencies)
    color_indices = np.linspace(0, 1, n_oscillators)
    oscillator_colors = np.zeros(n_oscillators, dtype=object)
    
    # Assign colors based on frequency order
    for i, idx in enumerate(sorted_indices):
        oscillator_colors[idx] = custom_cmap(color_indices[i])
    
    # Choose layout based on network type
    if network_type_internal == "Nearest Neighbor":
        # Circular layout for nearest neighbor (ring)
        pos = nx.circular_layout(G)
    # Special case for the Etz Hayim (Tree of Life) matrix - 10x10 matrix with specific structure
    elif network_type_internal == "Custom Adjacency Matrix" and network_adj_matrix.shape[0] == 10 and np.count_nonzero(network_adj_matrix) >= 40:
        # This appears to be our special Etz Hayim matrix - use a custom tree-like layout
        # Create a dictionary with fixed positions for this specific matrix
        # These positions follow a traditional Sephirotic tree arrangement with improved spacing
        fixed_positions = {
            0: (0.0, 1.0),     # Keter (Crown) - top position
            1: (-0.4, 0.8),    # Chokhmah (Wisdom) - upper right
            2: (0.4, 0.8),     # Binah (Understanding) - upper left
            3: (-0.7, 0.4),    # Chesed (Kindness) - middle right
            4: (0.7, 0.4),     # Gevurah (Strength) - middle left
            5: (0.0, 0.4),     # Tiferet (Beauty) - center
            6: (-0.7, 0.0),    # Netzach (Victory) - lower right
            7: (0.7, 0.0),     # Hod (Splendor) - lower left
            8: (0.0, -0.4),    # Yesod (Foundation) - bottom center
            9: (0.0, -0.8)     # Malkhut (Kingdom) - bottom
        }
        pos = fixed_positions
        
        # Add a note that we're using the special layout
        st.info("Using special 'Etz Hayim' (Tree of Life) layout for this adjacency matrix.")
    elif n_oscillators <= 20:
        # Spring layout for smaller networks
        pos = nx.spring_layout(G, seed=current_random_seed)
    else:
        # Circular layout is better for visualization with many nodes
        pos = nx.circular_layout(G)
    
    # Create graph visualization
    ax1.set_facecolor('#121212')
    
    # Debug information about the graph
    print(f"Graph info: nodes={len(G.nodes())}, edges={len(G.edges())}")
    if len(G.edges()) == 0:
        print("WARNING: Graph has no edges! Check adjacency matrix values.")
        # Force at least some edges for visualization by creating a ring
        temp_G = nx.cycle_graph(network_adj_matrix.shape[0])
        pos = nx.circular_layout(temp_G)
        edges = nx.draw_networkx_edges(temp_G, pos, ax=ax1, alpha=0.7,
                                  edge_color='#ff5500', width=1.5, 
                                  style='dashed')  # Use orange dashed lines to indicate fallback
        # Add warning to graph
        ax1.text(0.5, 0.5, "Warning: No edges detected in custom matrix\nShowing placeholder network",
              horizontalalignment='center', verticalalignment='center',
              transform=ax1.transAxes, color='#ff5500', fontsize=14)
    else:
        # Draw the graph with dark blue edges to match adjacency matrix
        edges = nx.draw_networkx_edges(G, pos, ax=ax1, alpha=0.7, 
                                   edge_color='#0070db', width=1.5)
    
    # Convert the RGBA colors to hex for networkx
    node_colors = []
    for c in oscillator_colors:
        # Create hex color from the custom colormap colors
        if hasattr(c, 'tolist'):  # If it's a numpy array
            rgba = c.tolist()
        else:  # If it's already a tuple/list
            rgba = c
        # Format as hex
        node_colors.append(f"#{int(rgba[0]*255):02x}{int(rgba[1]*255):02x}{int(rgba[2]*255):02x}")
    
    # Calculate dynamic node size based on number of nodes
    # Larger size for fewer nodes, smaller size for many nodes
    n_nodes = len(G.nodes)
    # Adjusted node size to be moderately sized - not too big, not too small
    node_size = max(150, int(800 * (1 / (0.12 * n_nodes + 0.6))))  # Balanced node size
    
    # Generate brighter versions of node colors for edges
    bright_node_colors = []
    for color in node_colors:
        # Convert hex to RGB and make it brighter
        r = int(color[1:3], 16)
        g = int(color[3:5], 16)
        b = int(color[5:7], 16)
        # Make RGB values brighter (closer to white)
        r = min(255, int(r * 1.5))
        g = min(255, int(g * 1.5))
        b = min(255, int(b * 1.5))
        bright_node_colors.append(f"#{r:02x}{g:02x}{b:02x}")
    
    # No glow effect for network nodes to keep the visualization clean
    
    # Draw the main nodes on top of glow effects
    nodes = nx.draw_networkx_nodes(G, pos, ax=ax1, 
                               node_color=node_colors, 
                               node_size=node_size, alpha=0.9, 
                               edgecolors=bright_node_colors, linewidths=1.0)
    
    # Add node labels only if there are relatively few nodes
    if n_oscillators <= 15:
        labels = {i: str(i) for i in range(n_oscillators)}
        nx.draw_networkx_labels(G, pos, labels=labels, ax=ax1, 
                           font_color='white', font_weight='bold')
        
    # Add title and styling
    ax1.set_title(f'Oscillator Network Graph ({network_type_internal})', 
               color='white', fontsize=14, pad=15)
    ax1.set_axis_off()
    
    # Add a legend explaining node colors with brighter outline
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.0), 
                markeredgecolor='#ae56ff', markersize=10, label='Lowest frequency (violet)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.33), 
                markeredgecolor='#ff50ff', markersize=10, label='Lower frequency (magenta)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(0.67), 
                markeredgecolor='#ffc060', markersize=10, label='Higher frequency (orange)'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=custom_cmap(1.0), 
                markeredgecolor='#70e898', markersize=10, label='Highest frequency (green)')
    ]
    ax1.legend(handles=legend_elements, loc='upper right', 
            frameon=True, framealpha=0.7, facecolor='#121212', 
            edgecolor='#555555', labelcolor='white')
    
    # Create a heatmap of the adjacency matrix using blue gradient
    # Create a custom blue colormap for the adjacency matrix (swapped light/dark and adjusted intensity)
    blue_cmap = LinearSegmentedColormap.from_list("adj_matrix_blue", 
                                             ["#00c2dd", "#109ae8", "#0070db"], 
                                             N=256)
    # Apply custom colormap - dark blue for 0s, light blue for 1s
    # Using binary data without text annotations
    im = ax2.imshow(network_adj_matrix, cmap=blue_cmap, interpolation='nearest')
    plt.colorbar(im, ax=ax2, label='Connection Strength')
    
    # Remove the actual 0/1 text annotations by turning off tick labels
    ax2.set_xticks([])
    ax2.set_yticks([])
    
    # Add labels and styling
    ax2.set_title('Adjacency Matrix', color='white', fontsize=14)
    ax2.set_xlabel('Oscillator Index', color='white')
    ax2.set_ylabel('Oscillator Index', color='white')
    
    # Set background color
    ax2.set_facecolor('#1a1a1a')
    fig.patch.set_facecolor('#121212')
    
    # Add a grid to help distinguish cells
    ax2.grid(False)
    
    # Add text annotations for connection strength (only for matrices smaller than 15x15)
    if n_oscillators <= 12:
        for i in range(network_adj_matrix.shape[0]):
            for j in range(network_adj_matrix.shape[1]):
                if network_adj_matrix[i, j] > 0:
                    ax2.text(j, i, f"{network_adj_matrix[i, j]:.1f}", 
                          ha="center", va="center", 
                          color="white" if network_adj_matrix[i, j] < 0.7 else "black",
                          fontsize=9)
    
    # Adjust spacing between subplots
    plt.tight_layout()
    
    # Display the figure
    st.pyplot(fig)
    
    # Special description for Etz Hayim matrix
    if network_type_internal == "Custom Adjacency Matrix" and network_adj_matrix.shape[0] == 10 and np.count_nonzero(network_adj_matrix) >= 40:
        st.markdown("""
        <div class='section'>
            <p>Figure Description:</p>
            <ul>
                <li><b>Left:</b> Graph representing the ten Sephirot (emanations) in the Kabbalistic Tree of Life, arranged in their traditional positions</li>
                <li><b>Right:</b> Adjacency matrix showing the 22 paths connecting the Sephirot</li>
            </ul>
            <p>The nodes represent (from top to bottom, right to left):</p>
            <ol>
                <li>Keter (Crown) - Will and the origin of divine revelation</li>
                <li>Chokhmah (Wisdom) - Beginning of conscious thought</li>
                <li>Binah (Understanding) - Processing and understanding</li>
                <li>Chesed (Kindness) - Expansion, loving kindness</li>
                <li>Gevurah (Strength) - Restriction, judgment and discipline</li>
                <li>Tiferet (Beauty) - Harmony, balance, integration</li>
                <li>Netzach (Victory) - Endurance and overcoming</li>
                <li>Hod (Splendor) - Surrender, sincerity, and gratitude</li>
                <li>Yesod (Foundation) - Connection and bonding force</li>
                <li>Malkhut (Kingdom) - Physical manifestation and action</li>
            </ol>
            <p>This structure offers a fascinating system to study synchronization patterns across interconnected oscillators.</p>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div class='section'>
            <p>Figure Description:</p>
            <ul>
                <li><b>Left:</b> Graph representation of oscillator connections, with nodes colored by natural frequency</li>
                <li><b>Right:</b> Adjacency matrix representation, where each cell (i,j) represents the connection strength between oscillators</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)

########################
# TAB 2: DISTRIBUTIONS TAB
########################
with tab2:
    # Update current tab in session state
    st.session_state.current_tab = "Distributions"
    st.markdown("<h2 class='gradient_text2'>Initial Distributions</h2>", unsafe_allow_html=True)
    
    # Display simulation information at the top
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Add the distribution histograms
    dist_col1, dist_col2 = st.columns(2)
    
    # Define a consistent figure size for both histograms
    hist_figsize = (4.0, 3.0)
    
    with dist_col1:
        st.markdown("<h4 class='gradient_text2'>Natural Frequency Distribution</h4>", unsafe_allow_html=True)
        
        # Create frequency distribution histogram
        fig_freq, ax_freq = plt.subplots(figsize=hist_figsize)
        
        # Use a gradient colormap for the histogram
        n_bins = 15
        counts, bin_edges = np.histogram(frequencies, bins=n_bins)
        
        # Create custom colormap that matches our gradient theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                ["#00ffff", "#00aaff"], 
                                                N=256)
        
        # Create custom colors with a gradient effect that matches our theme
        colors = custom_cmap(np.linspace(0.1, 0.9, n_bins))
        
        # Plot the histogram with gradient colors and outline
        bars = ax_freq.bar(
            (bin_edges[:-1] + bin_edges[1:]) / 2, 
            counts, 
            width=(bin_edges[1] - bin_edges[0]) * 0.9,
            color=colors, 
            alpha=0.8,
            edgecolor='white',
            linewidth=0.5
        )
        
        # Add a soft glow effect behind bars
        for bar, color in zip(bars, colors):
            x = bar.get_x()
            width = bar.get_width()
            height = bar.get_height()
            glow = plt.Rectangle(
                (x - width * 0.05, 0), 
                width * 1.1, 
                height, 
                color=color,
                alpha=0.3,
                zorder=-1
            )
            ax_freq.add_patch(glow)
        
        # Enhance the axes and labels
        ax_freq.set_facecolor('#1a1a1a')
        ax_freq.set_xlabel('Natural Frequency', fontsize=12, fontweight='bold', color='white')
        ax_freq.set_ylabel('Count', fontsize=12, fontweight='bold', color='white')
        ax_freq.set_title(f'Natural Frequency Distribution ({freq_type})', 
                       fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Add mean frequency marker
        mean_freq = np.mean(frequencies)
        ax_freq.axvline(x=mean_freq, color='#ff5555', linestyle='-', linewidth=2, alpha=0.7,
                      label=f'Mean: {mean_freq:.2f}')
        ax_freq.legend(framealpha=0.7)
        
        # Customize grid
        ax_freq.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add a subtle box around the plot
        for spine in ax_freq.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        st.pyplot(fig_freq)
        
        # Distribution properties description
        st.markdown(f"""
        <div class='section' style='font-size: 0.85em;'>
            <p><b>Mean:</b> {np.mean(frequencies):.4f}</p>
            <p><b>Standard Deviation:</b> {np.std(frequencies):.4f}</p>
            <p><b>Min:</b> {np.min(frequencies):.4f}</p>
            <p><b>Max:</b> {np.max(frequencies):.4f}</p>
        </div>
        """, unsafe_allow_html=True)
    
    with dist_col2:
        st.markdown("<h4 class='gradient_text2'>Initial Phase Distribution</h4>", unsafe_allow_html=True)
        
        # Create initial phase distribution histogram with matching size
        fig_init_phase, ax_init_phase = plt.subplots(figsize=hist_figsize)
        
        initial_phases = phases[:, 0] % (2 * np.pi)
        
        # Use a gradient colormap for the histogram
        n_bins = 15
        counts, bin_edges = np.histogram(initial_phases, bins=n_bins)
        
        # Create custom colors with a gradient effect that matches our theme
        colors = custom_cmap(np.linspace(0.1, 0.9, n_bins))
        
        # Plot the histogram with gradient colors and outline
        bars = ax_init_phase.bar(
            (bin_edges[:-1] + bin_edges[1:]) / 2, 
            counts, 
            width=(bin_edges[1] - bin_edges[0]) * 0.9,
            color=colors, 
            alpha=0.8,
            edgecolor='white',
            linewidth=0.5
        )
        
        # Add a soft glow effect behind bars
        for bar, color in zip(bars, colors):
            x = bar.get_x()
            width = bar.get_width()
            height = bar.get_height()
            glow = plt.Rectangle(
                (x - width * 0.05, 0), 
                width * 1.1, 
                height, 
                color=color,
                alpha=0.3,
                zorder=-1
            )
            ax_init_phase.add_patch(glow)
        
        # Enhance the axes and labels
        ax_init_phase.set_facecolor('#1a1a1a')
        ax_init_phase.set_xlabel('Phase (mod 2Ï€)', fontsize=12, fontweight='bold', color='white')
        ax_init_phase.set_ylabel('Count', fontsize=12, fontweight='bold', color='white')
        ax_init_phase.set_title('Initial Phase Distribution (t=0)', 
                             fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Calculate initial order parameter
        initial_r = order_parameter[0]
        initial_psi = np.angle(np.sum(np.exp(1j * initial_phases))) % (2 * np.pi)
        
        # Always add mean phase marker with red vertical line
        ax_init_phase.axvline(x=initial_psi, color='#ff5555', linestyle='-', linewidth=2, alpha=0.7,
                           label=f'Mean Phase: {initial_psi:.2f}')
        ax_init_phase.legend(framealpha=0.7)
        
        # Customize grid
        ax_init_phase.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add a subtle box around the plot
        for spine in ax_init_phase.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        st.pyplot(fig_init_phase)
        
        # Initial phase properties description
        st.markdown(f"""
        <div class='section' style='font-size: 0.85em;'>
            <p><b>Initial Order Parameter:</b> {initial_r:.4f}</p>
            <p><b>Initial Mean Phase:</b> {initial_psi:.4f}</p>
        </div>
        """, unsafe_allow_html=True)
    
    # Order Parameter Analysis section
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Order Parameter Analysis</h3>
        <p>The order parameter r(t) measures the degree of synchronization among oscillators:</p>
        <ul>
            <li>r = 1: Complete synchronization (all oscillators have the same phase)</li>
            <li>r = 0: Complete desynchronization (phases are uniformly distributed)</li>
        </ul>
        <p>At critical coupling strength (K_c), the system transitions from desynchronized to partially synchronized state.</p>
    </div>
    """, unsafe_allow_html=True)

########################
# TAB 3: ANIMATION TAB
########################
with tab3:
    # Update current tab in session state
    st.session_state.current_tab = "Animation"
    st.markdown("<h2 class='gradient_text2'>Interactive Animation</h2>", unsafe_allow_html=True)
    
    # Display simulation information at the top
    st.markdown(f"""
    <div style='background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 20px;'>
        <span style='font-size: 1.2em;'><b>Simulation Information</b></span><br>
        <span><b>Oscillators:</b> {sim_n_oscillators} | <b>Coupling Strength:</b> {coupling_strength} | <b>Network Type:</b> {network_type_internal}</span>
    </div>
    """, unsafe_allow_html=True)
    
    # Create oscillator visualization
    # Removed "Oscillator Synchronization" header as requested
    
    # Initialize time_index in session state if not present
    if 'time_index' not in st.session_state:
        st.session_state.time_index = 0
        
    # Set time index from session state
    time_index = st.session_state.time_index
    
    # Safety check to prevent index out of bounds errors
    max_valid_index = len(times) - 1
    if time_index > max_valid_index:
        # Reset the time index to a valid value
        time_index = max_valid_index
        st.session_state.time_index = max_valid_index
        st.warning(f"Time index was reset to maximum value ({max_valid_index})")
    
    # Initialize animation variables
    animate = False
    animation_speed = 3.0
    
    # Get time and order parameter values for the current time index (now with bounds checking)
    current_time = times[time_index]
    current_r = order_parameter[time_index]
    
    # Import needed module
    
    # Function to create the phase visualization
    def create_phase_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        # Create visualization with enhanced visuals for dark theme
        fig_circle = plt.figure(figsize=(5, 5))
        ax_circle = fig_circle.add_subplot(111)
        
        # Add background glow effect
        bg_circle = plt.Circle((0, 0), 1.1, fill=True, color='#121a24', alpha=0.6, zorder=1)
        ax_circle.add_patch(bg_circle)
        
        # Add subtle circle rings for reference in white to match unit circle
        for radius in [0.25, 0.5, 0.75]:
            ring = plt.Circle((0, 0), radius, fill=False, color='#ffffff', 
                            linestyle=':', alpha=0.25, zorder=2)
            ax_circle.add_patch(ring)
        
        # Draw unit circle with glow effect - using white
        circle_glow = plt.Circle((0, 0), 1.02, fill=False, color='#ffffff', alpha=0.3, linewidth=3, zorder=3)
        ax_circle.add_patch(circle_glow)
        
        # Main unit circle in white
        circle = plt.Circle((0, 0), 1, fill=False, color='#ffffff', linestyle='-', 
                         linewidth=1.5, alpha=0.8, zorder=4)
        ax_circle.add_patch(circle)
        
        # Plot oscillators - with bounds checking
        # Make sure we're using a valid time index
        safe_time_idx = max_valid_idx
        
        # Safety check for phase data dimensions
        if safe_time_idx < phases.shape[1]:
            phases_at_time = phases[:, safe_time_idx]
            x = np.cos(phases_at_time)
            y = np.sin(phases_at_time)
        else:
            # Fallback to initial phases if time index is beyond data
            initial_phases = phases[:, 0]
            x = np.cos(initial_phases)
            y = np.sin(initial_phases)
            # Show a warning in the plot
            ax_circle.text(0, 0, "Invalid time index", 
                         ha='center', va='center', color='red', fontsize=12)
        
        # Create custom colormap that matches our gradient_text1 theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                     ["#8A2BE2", "#FF00FF", "#FFA500", "#50C878"], 
                                                     N=256)
        
        # Sort oscillators by their natural frequency
        sorted_indices = np.argsort(frequencies)
        # Create colors based on frequency ordering
        color_indices = np.linspace(0, 1, n_oscillators)
        colors = [custom_cmap(idx) for idx in color_indices]
        
        # Map colors to oscillators by frequency order
        oscillator_colors = np.zeros((n_oscillators, 4))  # RGBA colors
        for i, idx in enumerate(sorted_indices):
            oscillator_colors[idx] = colors[i]
        
        # Enhanced scatter plot with oscillator colors - with reduced glow effect
        # Create slightly brighter versions of the colors for outlines and glow
        bright_oscillator_colors = np.copy(oscillator_colors)
        for i in range(len(bright_oscillator_colors)):
            # Make RGB values brighter (closer to white) but preserve alpha - reduced from 1.7 to 1.3
            bright_oscillator_colors[i, :3] = np.minimum(1.0, bright_oscillator_colors[i, :3] * 1.3)  # 30% brighter
        
        # First add a smaller glow effect for each oscillator
        for i in range(n_oscillators):
            # Reduced size from 0.11 to 0.07 and alpha from 0.3 to 0.2
            glow = plt.Circle((x[i], y[i]), 0.07, fill=True, 
                          color=oscillator_colors[i], alpha=0.2, zorder=7)
            ax_circle.add_patch(glow)
            
        # Add a subtle pulse effect with smaller secondary glow (or remove if too much)
        for i in range(n_oscillators):
            # Reduced size from 0.14 to 0.09 and alpha from 0.15 to 0.1
            second_glow = plt.Circle((x[i], y[i]), 0.09, fill=True, 
                               color=bright_oscillator_colors[i], alpha=0.1, zorder=6)
            ax_circle.add_patch(second_glow)
        
        # Use custom edge colors and increased size for main points - slightly smaller
        sc = ax_circle.scatter(x, y, facecolors=oscillator_colors, edgecolors=bright_oscillator_colors, s=180, 
                         alpha=0.9, linewidth=1.3, zorder=10)
        
        # Calculate and show order parameter
        r = order_parameter[time_idx]
        psi = np.angle(np.sum(np.exp(1j * phases_at_time)))
        
        # Draw arrow showing mean field with glow effect - using bright blue color
        # First add glow/shadow
        ax_circle.arrow(0, 0, r * np.cos(psi), r * np.sin(psi), 
                       head_width=0.07, head_length=0.12, fc='#00c2ff', ec='#00c2ff', 
                       width=0.03, alpha=0.3, zorder=5)
        
        # Then add main arrow
        ax_circle.arrow(0, 0, r * np.cos(psi), r * np.sin(psi), 
                       head_width=0.05, head_length=0.1, fc='#00a5ff', ec='#00a5ff', 
                       width=0.02, zorder=6)
        
        # Draw axes
        ax_circle.axhline(y=0, color='#555555', linestyle='-', alpha=0.5, zorder=0)
        ax_circle.axvline(x=0, color='#555555', linestyle='-', alpha=0.5, zorder=0)
        
        ax_circle.set_xlim(-1.2, 1.2)
        ax_circle.set_ylim(-1.2, 1.2)
        ax_circle.set_aspect('equal')
        
        # Add subtle grid
        ax_circle.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Enhance title
        ax_circle.set_title(f'Oscillators at t={times[time_idx]:.2f}', 
                          color='white', fontsize=14, pad=15)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
        
        return fig_circle
    
    # Function to create oscillator phases over time plot (as dots)
    def create_oscillator_phases_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        fig, ax = plt.subplots(figsize=(12, 3.5))
        
        # Add background
        ax.set_facecolor('#1a1a1a')
        
        # Create transparent bands at phase regions
        for y in [0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi]:
            ax.axhspan(y-0.1, y+0.1, color='#222233', alpha=0.4, zorder=0)
        
        # Create custom colormap that matches our gradient_text1 theme
        custom_cmap = LinearSegmentedColormap.from_list("kuramoto_colors", 
                                                     ["#8A2BE2", "#FF00FF", "#FFA500", "#50C878"], 
                                                     N=256)
        
        # Sort oscillators by their natural frequency for consistent coloring
        sorted_indices = np.argsort(frequencies)
        color_indices = np.linspace(0, 1, n_oscillators)
        oscillator_colors = np.zeros(n_oscillators, dtype=object)
        
        # Assign colors based on frequency order
        for i, idx in enumerate(sorted_indices):
            oscillator_colors[idx] = custom_cmap(color_indices[i])
        
        # Use the safety bounds check variable
        safe_time_idx = max_valid_idx
        
        # Plot all oscillators as dots up to the current time point
        for i in range(n_oscillators):
            color = oscillator_colors[i]
            
            # Create a brighter version of the color for edge
            # Extract RGB values and make them brighter
            rgb = matplotlib.colors.to_rgb(color)
            # Create brighter version (closer to white)
            bright_color = tuple(min(1.0, c * 1.5) for c in rgb)
            
            # Plot oscillator phases as filled dots with color gradient
            ax.scatter(times[:safe_time_idx+1], phases[i, :safe_time_idx+1] % (2 * np.pi), 
                     facecolors=color, edgecolor=bright_color, alpha=0.7, s=50, 
                     linewidth=0.5, zorder=5)
            
            # Add a subtle connecting line with low opacity
            ax.plot(times[:safe_time_idx+1], phases[i, :safe_time_idx+1] % (2 * np.pi), 
                  color=color, alpha=0.2, linewidth=0.8, zorder=2)
            
            # Highlight current position with a larger filled marker
            ax.scatter([times[safe_time_idx]], [phases[i, safe_time_idx] % (2 * np.pi)], 
                     s=140, facecolors=color, edgecolor=bright_color, 
                     linewidth=1.0, zorder=15)
        
        # Add labels for key phase positions
        phase_labels = [(0, '0'), (np.pi/2, 'Ï€/2'), (np.pi, 'Ï€'), (3*np.pi/2, '3Ï€/2'), (2*np.pi, '2Ï€')]
        for y, label in phase_labels:
            ax.annotate(label, xy=(-0.02, y), xycoords=('axes fraction', 'data'),
                      fontsize=11, color='white', ha='center', va='center')
        
        # Plot styling
        ax.set_xlabel('Time', fontsize=13, fontweight='bold', color='white')
        ax.set_ylabel('Phase (mod 2Ï€)', fontsize=13, fontweight='bold', color='white')
        ax.set_title(f'Oscillator Phases at t={times[safe_time_idx]:.2f}', 
                   fontsize=14, fontweight='bold', color='white', pad=15)
        ax.set_ylim(0, 2 * np.pi)
        ax.set_yticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
        ax.set_yticklabels(['0', 'Ï€/2', 'Ï€', '3Ï€/2', '2Ï€'])
        ax.set_xlim(times.min(), times.max())
        
        # Custom grid
        ax.grid(True, color='#333333', alpha=0.4, linestyle=':')
        
        # Add box around the plot
        for spine in ax.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
            
        return fig
    
    # Create a function to create order parameter plot over time (as a dot plot)
    def create_order_parameter_plot(time_idx):
        # Add bounds checking to prevent index errors
        max_valid_idx = min(time_idx, len(times) - 1)
        
        fig, ax = plt.subplots(figsize=(5, 5))
        
        # Add background gradient
        ax.set_facecolor('#1a1a1a')
        
        # Add subtle horizontal bands for visual reference
        for y in np.linspace(0, 1, 6):
            ax.axhspan(y-0.05, y+0.05, color='#222233', alpha=0.3, zorder=0)
        
        # Create a custom colormap that matches the blue gradient used in the sidebar
        cmap = LinearSegmentedColormap.from_list("order_param", 
                                             ["#00c2dd", "#109ae8", "#0070db"], 
                                             N=256)
        
        # Use the safe index for all references
        safe_time_idx = max_valid_idx
        
        # Plot order parameter with filled gradient dots and brighter outline
        base_colors = [cmap(r) for r in order_parameter[:safe_time_idx+1]]
        edge_colors = []
        
        # Create brighter versions of each color for the outlines
        for color in base_colors:
            rgb = matplotlib.colors.to_rgb(color)
            # Make RGB values brighter but preserve alpha
            bright_color = tuple(min(1.0, c * 1.5) for c in rgb)
            edge_colors.append(bright_color)
        
        scatter = ax.scatter(times[:safe_time_idx+1], order_parameter[:safe_time_idx+1],
                          facecolors=base_colors, edgecolors=edge_colors,
                          s=70, alpha=0.9, linewidth=0.5, zorder=10)
        
        # Removed connecting line as requested
        
        # Highlight current position with a larger filled marker
        if safe_time_idx > 0:
            # Get color and make brighter version for outline
            current_color = cmap(order_parameter[safe_time_idx])
            rgb = matplotlib.colors.to_rgb(current_color)
            bright_current = tuple(min(1.0, c * 1.5) for c in rgb)
            
            ax.scatter([times[safe_time_idx]], [order_parameter[safe_time_idx]], 
                     s=180, facecolors=current_color, 
                     edgecolors=bright_current, 
                     linewidth=1.0, zorder=15)
        
        # Add highlights at important thresholds
        ax.axhline(y=0.5, color='#aaaaaa', linestyle='--', alpha=0.5, zorder=1, 
                 label='Partial Synchronization (r=0.5)')
        ax.axhline(y=0.8, color='#ffffff', linestyle='--', alpha=0.5, zorder=1,
                 label='Strong Synchronization (r=0.8)')
        
        # Enhance the plot appearance
        ax.set_xlim(times.min(), times.max())
        ax.set_ylim(0, 1.05)
        ax.set_xlabel('Time', fontsize=13, fontweight='bold', color='white')
        ax.set_ylabel('Order Parameter r(t)', fontsize=13, fontweight='bold', color='white')
        ax.set_title(f'Phase Synchronization at t={times[safe_time_idx]:.2f}', 
                   fontsize=14, fontweight='bold', color='white', pad=15)
        
        # Create custom grid
        ax.grid(True, color='#333333', alpha=0.5, linestyle=':')
        
        # Legend removed as requested
        
        # Add subtle box around the plot
        for spine in ax.spines.values():
            spine.set_edgecolor('#555555')
            spine.set_linewidth(1)
        
        # Close any previous figure to avoid memory issues
        plt.close('all')
            
        return fig
    
    # Create a more space-efficient layout 
    # First row: Oscillator phases plot (wider view)
    phases_plot_placeholder = st.empty()
    phases_plot_placeholder.pyplot(create_oscillator_phases_plot(time_index))
    
    # Second row: Circle plot and order parameter side by side
    col1, col2 = st.columns(2)
    with col1:
        circle_plot_placeholder = st.empty()
        circle_plot_placeholder.pyplot(create_phase_plot(time_index))
    
    with col2:
        order_plot_placeholder = st.empty()
        order_plot_placeholder.pyplot(create_order_parameter_plot(time_index))
    
    # Removed "Current Time" display as requested
    
    # Put animation controls first (at the top) with proper containment
    st.markdown("<h4 style='margin-bottom: 20px;'>Animation Controls</h4>", unsafe_allow_html=True)
    
    # Create a container for the buttons to ensure they stay together
    button_container = st.container()
    
    # Create centered columns for control buttons within the container
    with button_container:
        # Use wider columns for the buttons to center them better
        bcol1, bcol2, bcol3, bcol4, bcol5 = st.columns([1, 3, 3, 3, 1])
    
        # Set a fixed animation speed value for smoother playback
        animation_speed = 5.0  # Faster speed for smoother animation
        
        # Previous frame button
        if bcol2.button("âª Previous", use_container_width=True):
            if st.session_state.time_index > 0:
                st.session_state.time_index -= 1
                st.rerun()
        
        # Simplified Play/Pause button with text inside
        play_button_text = "â¯ï¸ Play"
        if bcol3.button(play_button_text, use_container_width=True):
            # Toggle animation state
            animate = True
            # Let the animation code run
        
        # Next frame button 
        if bcol4.button("â© Next", use_container_width=True):
            if st.session_state.time_index < len(times) - 1:
                st.session_state.time_index += 1
                st.rerun()
    
    # Create a separate container for time step display
    time_info_container = st.container()
    with time_info_container:
        time_col1, time_col2, time_col3 = st.columns([1, 2, 1])
        # Create a placeholder for displaying time step info 
        current_time_placeholder = time_col2.empty()
        
        # Function to update time step display
        def update_time_step_display(time_idx):
            # Calculate the actual time step (difference between consecutive time points)
            if time_idx > 0:
                time_step = times[time_idx] - times[time_idx-1]
            else:
                # Use first difference for the first point
                if len(times) > 1:
                    time_step = times[1] - times[0]
                else:
                    time_step = 0
                    
            current_time = times[time_idx]
            current_percent = (time_idx / (len(times) - 1)) * 100
            
            # Update the placeholder with the time step information
            current_time_placeholder.markdown(f"""
            <div style="padding: 10px; border-radius: 5px; background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(255, 0, 255, 0.2)); 
                        border: 1px solid rgba(255, 255, 255, 0.1); text-align: center;">
                <span style="font-size: 0.85rem; color: white;">Î”t = {time_step:.5f}</span><br>
                <span style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.7);">t = {current_time:.3f}</span>
            </div>
            """, unsafe_allow_html=True)
    
    # Initial display of time step
    update_time_step_display(st.session_state.time_index)
    
    # Add a slider to manually control visualization time point AFTER the buttons
    playback_container = st.container()
    time_index = playback_container.slider(
        "Time Point", 
        min_value=0, 
        max_value=len(times)-1, 
        value=st.session_state.time_index,
        help="Manually select a specific time point to display"
    )
    
    # Update session state when slider is moved
    if st.session_state.time_index != time_index:
        st.session_state.time_index = time_index
            
    # If animation is triggered
    if animate:
        # Get the current time index as the starting point
        start_idx = st.session_state.time_index
        
        # Ensure we're not starting beyond the available data
        max_valid_index = len(times) - 1
        if start_idx > max_valid_index:
            start_idx = 0
            st.session_state.time_index = 0
        
        # Calculate how many frames to skip for smoother animation
        frame_skip = max(1, len(times) // 100)  # Skip more frames for smoother playback
        
        # Set up a progress bar
        progress_bar = st.progress(0)
        
        # Animation loop with bounds checking
        for i in range(start_idx, min(len(times), max_valid_index + 1), frame_skip):
            # Update the session state
            st.session_state.time_index = i
            
            # Update progress bar - with safeguards to prevent division by zero
            denominator = max(1, max_valid_index - start_idx)  # Ensure non-zero denominator
            progress = min(1.0, (i - start_idx) / denominator)
            progress_bar.progress(progress)
            
            # Update all three plots
            # Safety checks for index values
            plot_idx = min(i, max_valid_index)
            circle_plot_placeholder.pyplot(create_phase_plot(plot_idx))
            phases_plot_placeholder.pyplot(create_oscillator_phases_plot(plot_idx))
            order_plot_placeholder.pyplot(create_order_parameter_plot(plot_idx))
            
            # Update the time step display with the current time index
            update_time_step_display(plot_idx)
            
            # Add a short pause to control animation speed
            time.sleep(0.02 / animation_speed)  # Much faster frame updates
        
        # Clear progress bar after animation
        progress_bar.empty()
    
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Visualization Guide</h3>
        <p>The <b>top plot</b> shows oscillator phases over time. Each horizontal trace represents one oscillator's phase trajectory with consistent coloring based on the oscillator's natural frequency.</p>
        <p>The <b>bottom left plot</b> shows oscillators on a unit circle. Each colored dot represents an oscillator at its current phase position. The blue arrow shows the mean field vector, with length equal to the order parameter r.</p>
        <p>The <b>bottom right plot</b> shows the order parameter over time, with color-coded dots showing the synchronization level from 0 (no synchronization) to 1 (complete synchronization).</p>
        <p>Click "â¯ï¸ Play" to watch all three visualizations animate together to see the synchronization process in real-time.</p>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
    <div class='section'>
        <h3 class='gradient_text1'>Order Parameter Analysis</h3>
        <p>The order parameter r(t) measures the degree of synchronization among oscillators:</p>
        <ul>
            <li>r = 1: Complete synchronization (all oscillators have the same phase)</li>
            <li>r = 0: Complete desynchronization (phases are uniformly distributed)</li>
        </ul>
        <p>At critical coupling strength (K_c), the system transitions from desynchronized to partially synchronized state.</p>
    </div>
    """, unsafe_allow_html=True)

########################
# TAB 4: NUMERICAL CONSIDERATIONS TAB
########################
with tab4:
    # Update current tab in session state to track which tab is active
    st.session_state.current_tab = "Numerical Considerations"
    st.markdown("""
    <div class='section'>
    <ul>
        <li>The animation uses an explicit RK45 integrator with an adaptive, heuristically chosen maximum step size.</li>
        <li>No formal error or stability bounds are provided, however extreme coupling strengths, highly non-uniform frequency distributions, or large time steps may lead to numerical instability.</li>
        <li>For production-level accuracy, one should compare against sympletic or implicit schemes, tighten tolerances, and perform systematic convergence tests.</li>
        <li>Note that the time step is automatically calculated based on oscillator frequencies to ensure numerical stability and accuracy.</li>
    </ul>
    </div>
    """, unsafe_allow_html=True)

=== backups/checkpoint_before_refactor/database.py ===

"""
Database module for the Kuramoto Model Simulator.
This module provides functionality to store and retrieve simulation data,
as well as import/export configurations as JSON files.
"""

import os
import numpy as np
import json
import pickle
import pandas as pd
from datetime import datetime
from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, LargeBinary, ForeignKey, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship

# Create the engine and base
DATABASE_URL = "sqlite:///kuramoto_simulations.db"
engine = create_engine(DATABASE_URL)
Base = declarative_base()

# Session factory
Session = sessionmaker(bind=engine)


class Simulation(Base):
    """Model representing a Kuramoto simulation run."""
    __tablename__ = "simulations"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.now)
    n_oscillators = Column(Integer)
    coupling_strength = Column(Float)
    simulation_time = Column(Float)
    time_step = Column(Float)
    random_seed = Column(Integer)
    frequency_distribution = Column(String(50))
    frequency_params = Column(Text)  # JSON string of distribution parameters
    
    # Relationships
    frequencies = relationship("Frequency", back_populates="simulation", cascade="all, delete-orphan")
    phases = relationship("Phase", back_populates="simulation", cascade="all, delete-orphan")
    order_parameters = relationship("OrderParameter", back_populates="simulation", cascade="all, delete-orphan")
    adjacency_matrix = relationship("AdjacencyMatrix", back_populates="simulation", uselist=False, cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Simulation(id={self.id}, oscillators={self.n_oscillators}, coupling={self.coupling_strength})>"


class Frequency(Base):
    """Model representing oscillator natural frequencies."""
    __tablename__ = "frequencies"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"))
    oscillator_index = Column(Integer)
    value = Column(Float)
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="frequencies")

    def __repr__(self):
        return f"<Frequency(oscillator={self.oscillator_index}, value={self.value})>"


class Phase(Base):
    """Model representing phase data for each oscillator over time."""
    __tablename__ = "phases"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"))
    time_index = Column(Integer)
    oscillator_index = Column(Integer)
    value = Column(Float)
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="phases")

    def __repr__(self):
        return f"<Phase(time={self.time_index}, oscillator={self.oscillator_index}, value={self.value})>"


class OrderParameter(Base):
    """Model representing order parameter data over time."""
    __tablename__ = "order_parameters"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"))
    time_index = Column(Integer)
    magnitude = Column(Float)
    phase = Column(Float)
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="order_parameters")

    def __repr__(self):
        return f"<OrderParameter(time={self.time_index}, r={self.magnitude}, psi={self.phase})>"


class AdjacencyMatrix(Base):
    """Model representing the network adjacency matrix."""
    __tablename__ = "adjacency_matrices"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"), unique=True)
    data = Column(LargeBinary)  # Serialized numpy array
    network_type = Column(String(50))
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="adjacency_matrix")

    def __repr__(self):
        return f"<AdjacencyMatrix(sim_id={self.simulation_id}, type={self.network_type})>"


class Configuration(Base):
    """Model for storing and retrieving simulation configurations."""
    __tablename__ = "configurations"
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100))
    timestamp = Column(DateTime, default=datetime.now)
    n_oscillators = Column(Integer)
    coupling_strength = Column(Float)
    simulation_time = Column(Float)
    time_step = Column(Float)
    random_seed = Column(Integer)
    network_type = Column(String(50))
    frequency_distribution = Column(String(50))
    frequency_params = Column(Text)  # JSON string
    adjacency_matrix = Column(LargeBinary, nullable=True)  # Serialized numpy array
    
    def __repr__(self):
        return f"<Configuration(id={self.id}, name={self.name})>"


# Create all tables if they don't exist
Base.metadata.create_all(engine)


def store_simulation(model, times, phases, order_parameter, frequencies, freq_type, freq_params=None, adjacency_matrix=None):
    """
    Store simulation results in the database.
    
    Parameters:
    -----------
    model : KuramotoModel
        The model instance containing simulation parameters
    times : ndarray
        Array of time points
    phases : ndarray
        Array of phase data (shape: time points Ã— oscillators)
    order_parameter : dict
        Dictionary containing 'r' and 'psi' for order parameter magnitude and phase
    frequencies : ndarray
        Array of natural frequencies for each oscillator
    freq_type : str
        Type of frequency distribution (e.g., 'normal', 'uniform', 'custom')
    freq_params : dict, optional
        Parameters for the frequency distribution
    adjacency_matrix : ndarray, optional
        Adjacency matrix defining the network structure
        
    Returns:
    --------
    int
        ID of the stored simulation
    """
    # Create a new session
    session = Session()
    
    try:
        # Convert adjacency matrix to binary if it exists
        adj_matrix_binary = None
        network_type = "All-to-All"
        
        if adjacency_matrix is not None:
            adj_matrix_binary = pickle.dumps(adjacency_matrix)
            network_type = "Custom Adjacency Matrix"
        
        # Convert frequency params to JSON if they exist
        freq_params_json = None
        if freq_params is not None:
            freq_params_json = json.dumps(freq_params)
        
        # Create the simulation record
        simulation = Simulation(
            n_oscillators=model.n_oscillators,
            coupling_strength=model.coupling_strength,
            simulation_time=model.simulation_time,
            time_step=model.time_step,
            random_seed=model.random_seed,
            frequency_distribution=freq_type,
            frequency_params=freq_params_json
        )
        
        # Add to session
        session.add(simulation)
        session.flush()  # Flush to get the ID
        
        # Store the adjacency matrix if it exists
        if adj_matrix_binary is not None:
            adj_matrix_record = AdjacencyMatrix(
                simulation_id=simulation.id,
                data=adj_matrix_binary,
                network_type=network_type
            )
            session.add(adj_matrix_record)
        
        # Store frequencies
        for i, freq in enumerate(frequencies):
            freq_record = Frequency(
                simulation_id=simulation.id,
                oscillator_index=i,
                value=float(freq)
            )
            session.add(freq_record)
        
        # Store phase data (if phases is large, store a subset)
        max_phase_samples = 1000
        if len(times) > max_phase_samples:
            # Sample phases at regular intervals
            sample_indices = np.linspace(0, len(times) - 1, max_phase_samples, dtype=int)
            times_sampled = times[sample_indices]
            phases_sampled = phases[sample_indices]
        else:
            times_sampled = times
            phases_sampled = phases
        
        # Store phases
        for t_idx, t in enumerate(times_sampled):
            for osc_idx in range(model.n_oscillators):
                phase_record = Phase(
                    simulation_id=simulation.id,
                    time_index=t_idx,
                    oscillator_index=osc_idx,
                    value=float(phases_sampled[t_idx, osc_idx])
                )
                session.add(phase_record)
        
        # Store order parameter (if order_parameter is large, store a subset)
        r_values = order_parameter['r']
        psi_values = order_parameter['psi']
        
        if len(r_values) > max_phase_samples:
            # Sample order parameter at regular intervals
            sample_indices = np.linspace(0, len(r_values) - 1, max_phase_samples, dtype=int)
            r_sampled = r_values[sample_indices]
            psi_sampled = psi_values[sample_indices]
        else:
            r_sampled = r_values
            psi_sampled = psi_values
        
        for t_idx, (r, psi) in enumerate(zip(r_sampled, psi_sampled)):
            order_param_record = OrderParameter(
                simulation_id=simulation.id,
                time_index=t_idx,
                magnitude=float(r),
                phase=float(psi)
            )
            session.add(order_param_record)
        
        # Commit the transaction
        session.commit()
        return simulation.id
    
    except Exception as e:
        session.rollback()
        print(f"Error storing simulation: {e}")
        raise
    
    finally:
        session.close()


def get_simulation(simulation_id):
    """
    Retrieve a simulation from the database by ID.
    
    Parameters:
    -----------
    simulation_id : int
        ID of the simulation to retrieve
        
    Returns:
    --------
    dict
        Dictionary containing the simulation data, with keys:
        - 'params': Simulation parameters
        - 'times': Time points
        - 'phases': Phase data
        - 'order_parameter': Order parameter data
        - 'frequencies': Natural frequencies
        - 'adjacency_matrix': Network adjacency matrix (if available)
    """
    # Create a session
    session = Session()
    
    try:
        # Query the simulation
        simulation = session.query(Simulation).get(simulation_id)
        
        if not simulation:
            return None
        
        # Retrieve frequencies
        frequencies = session.query(Frequency).filter_by(simulation_id=simulation_id).order_by(Frequency.oscillator_index).all()
        freq_values = np.array([f.value for f in frequencies])
        
        # Retrieve phases
        phases = session.query(Phase).filter_by(simulation_id=simulation_id).order_by(Phase.time_index, Phase.oscillator_index).all()
        time_indices = sorted(list(set([p.time_index for p in phases])))
        oscillator_indices = sorted(list(set([p.oscillator_index for p in phases])))
        
        # Create a phases array
        phases_array = np.zeros((len(time_indices), len(oscillator_indices)))
        for p in phases:
            phases_array[p.time_index, p.oscillator_index] = p.value
        
        # Retrieve order parameter
        order_params = session.query(OrderParameter).filter_by(simulation_id=simulation_id).order_by(OrderParameter.time_index).all()
        r_values = np.array([op.magnitude for op in order_params])
        psi_values = np.array([op.phase for op in order_params])
        
        # Retrieve adjacency matrix if available
        adj_matrix = session.query(AdjacencyMatrix).filter_by(simulation_id=simulation_id).first()
        adj_matrix_array = None
        network_type = "All-to-All"
        
        if adj_matrix:
            adj_matrix_array = pickle.loads(adj_matrix.data)
            network_type = adj_matrix.network_type
        
        # Parse frequency params if available
        freq_params = None
        if simulation.frequency_params:
            try:
                freq_params = json.loads(simulation.frequency_params)
            except:
                freq_params = simulation.frequency_params
        
        # Create a result dictionary
        result = {
            'params': {
                'id': simulation.id,
                'timestamp': simulation.timestamp,
                'n_oscillators': simulation.n_oscillators,
                'coupling_strength': simulation.coupling_strength,
                'simulation_time': simulation.simulation_time,
                'time_step': simulation.time_step,
                'random_seed': simulation.random_seed,
                'frequency_distribution': simulation.frequency_distribution,
                'frequency_params': freq_params,
                'network_type': network_type
            },
            'frequencies': freq_values,
            'times': np.array(time_indices),
            'phases': phases_array,
            'order_parameter': {
                'r': r_values,
                'psi': psi_values
            },
            'adjacency_matrix': adj_matrix_array
        }
        
        return result
    
    except Exception as e:
        print(f"Error retrieving simulation: {e}")
        return None
    
    finally:
        session.close()


def list_simulations():
    """
    List all simulations in the database.
    
    Returns:
    --------
    list
        List of dictionaries, each containing metadata about a simulation
    """
    # Create a session
    session = Session()
    
    try:
        # Query all simulations
        simulations = session.query(Simulation).order_by(Simulation.timestamp.desc()).all()
        
        result = []
        for sim in simulations:
            # Get the network type
            adj_matrix = session.query(AdjacencyMatrix).filter_by(simulation_id=sim.id).first()
            network_type = adj_matrix.network_type if adj_matrix else "All-to-All"
            
            # Parse frequency params if available
            freq_params = None
            if sim.frequency_params:
                try:
                    freq_params = json.loads(sim.frequency_params)
                except:
                    freq_params = sim.frequency_params
            
            # Add to result
            result.append({
                'id': sim.id,
                'timestamp': sim.timestamp,
                'n_oscillators': sim.n_oscillators,
                'coupling_strength': sim.coupling_strength,
                'simulation_time': sim.simulation_time,
                'time_step': sim.time_step,
                'random_seed': sim.random_seed,
                'frequency_distribution': sim.frequency_distribution,
                'frequency_params': freq_params,
                'network_type': network_type
            })
        
        return result
    
    except Exception as e:
        print(f"Error listing simulations: {e}")
        return []
    
    finally:
        session.close()


def delete_simulation(simulation_id):
    """
    Delete a simulation from the database.
    
    Parameters:
    -----------
    simulation_id : int
        ID of the simulation to delete
        
    Returns:
    --------
    bool
        True if deletion was successful, False otherwise
    """
    # Create a session
    session = Session()
    
    try:
        # Query the simulation
        simulation = session.query(Simulation).get(simulation_id)
        
        if not simulation:
            return False
        
        # Delete the simulation (cascade will delete related records)
        session.delete(simulation)
        session.commit()
        
        return True
    
    except Exception as e:
        session.rollback()
        print(f"Error deleting simulation: {e}")
        return False
    
    finally:
        session.close()


def save_configuration(name, n_oscillators, coupling_strength, simulation_time, time_step, 
                     random_seed, network_type, frequency_distribution, frequency_params, adjacency_matrix=None):
    """
    Save a configuration to the database.
    
    Parameters:
    -----------
    name : str
        Name for the configuration
    n_oscillators : int
        Number of oscillators
    coupling_strength : float
        Coupling strength K
    simulation_time : float
        Total simulation time
    time_step : float
        Time step for simulation
    random_seed : int
        Random seed for reproducibility
    network_type : str
        Type of network connection ('All-to-All', 'Nearest Neighbor', 'Random', 'Custom Adjacency Matrix')
    frequency_distribution : str
        Type of frequency distribution ('Normal', 'Uniform', 'Bimodal', 'Custom')
    frequency_params : str or dict
        Parameters for the frequency distribution (will be converted to JSON if dict)
    adjacency_matrix : ndarray, optional
        Custom adjacency matrix (for 'Custom Adjacency Matrix' network type)
        
    Returns:
    --------
    int
        ID of the saved configuration
    """
    # Create a session
    session = Session()
    
    try:
        # Convert adjacency matrix to binary if it exists
        adj_matrix_binary = None
        if adjacency_matrix is not None:
            adj_matrix_binary = pickle.dumps(adjacency_matrix)
        
        # Convert frequency params to JSON if it's a dict
        if isinstance(frequency_params, dict):
            frequency_params = json.dumps(frequency_params)
        
        # Create the configuration record
        config = Configuration(
            name=name,
            n_oscillators=n_oscillators,
            coupling_strength=coupling_strength,
            simulation_time=simulation_time,
            time_step=time_step,
            random_seed=random_seed,
            network_type=network_type,
            frequency_distribution=frequency_distribution,
            frequency_params=frequency_params,
            adjacency_matrix=adj_matrix_binary
        )
        
        # Add to session and commit
        session.add(config)
        session.commit()
        
        return config.id
    
    except Exception as e:
        session.rollback()
        print(f"Error saving configuration: {e}")
        raise
    
    finally:
        session.close()


def list_configurations():
    """
    List all configurations in the database.
    
    Returns:
    --------
    list
        List of dictionaries, each containing metadata about a configuration
    """
    # Create a session
    session = Session()
    
    try:
        # Query all configurations
        configs = session.query(Configuration).order_by(Configuration.timestamp.desc()).all()
        
        result = []
        for config in configs:
            # Parse frequency params if available
            freq_params = None
            if config.frequency_params:
                try:
                    freq_params = json.loads(config.frequency_params)
                except:
                    freq_params = config.frequency_params
            
            # Add to result
            result.append({
                'id': config.id,
                'name': config.name,
                'timestamp': config.timestamp,
                'n_oscillators': config.n_oscillators,
                'coupling_strength': config.coupling_strength,
                'simulation_time': config.simulation_time,
                'time_step': config.time_step,
                'random_seed': config.random_seed,
                'network_type': config.network_type,
                'frequency_distribution': config.frequency_distribution,
                'frequency_params': freq_params,
                'has_matrix': config.adjacency_matrix is not None
            })
        
        return result
    
    except Exception as e:
        print(f"Error listing configurations: {e}")
        return []
    
    finally:
        session.close()


def get_configuration(config_id):
    """
    Get a configuration from the database by ID.
    
    Parameters:
    -----------
    config_id : int
        ID of the configuration to retrieve
        
    Returns:
    --------
    dict
        Dictionary containing the configuration data
    """
    # Create a session
    session = Session()
    
    try:
        # Query the configuration
        config = session.query(Configuration).get(config_id)
        
        if not config:
            return None
        
        # Parse frequency params if available
        freq_params = None
        if config.frequency_params:
            try:
                freq_params = json.loads(config.frequency_params)
            except:
                freq_params = config.frequency_params
        
        # Get adjacency matrix if available
        adj_matrix = None
        if config.adjacency_matrix:
            adj_matrix = pickle.loads(config.adjacency_matrix)
        
        # Create result dictionary
        result = {
            'id': config.id,
            'name': config.name,
            'timestamp': config.timestamp,
            'n_oscillators': config.n_oscillators,
            'coupling_strength': config.coupling_strength,
            'simulation_time': config.simulation_time,
            'time_step': config.time_step,
            'random_seed': config.random_seed,
            'network_type': config.network_type,
            'frequency_distribution': config.frequency_distribution,
            'frequency_params': freq_params,
            'adjacency_matrix': adj_matrix
        }
        
        return result
    
    except Exception as e:
        print(f"Error retrieving configuration: {e}")
        return None
    
    finally:
        session.close()


def get_configuration_by_name(name):
    """
    Get a configuration from the database by name.
    
    Parameters:
    -----------
    name : str
        Name of the configuration to retrieve
        
    Returns:
    --------
    dict
        Dictionary containing the configuration data
    """
    # Create a session
    session = Session()
    
    try:
        # Query the configuration
        config = session.query(Configuration).filter_by(name=name).first()
        
        if not config:
            return None
        
        # Parse frequency params if available
        freq_params = None
        if config.frequency_params:
            try:
                freq_params = json.loads(config.frequency_params)
            except:
                freq_params = config.frequency_params
        
        # Get adjacency matrix if available
        adj_matrix = None
        if config.adjacency_matrix:
            adj_matrix = pickle.loads(config.adjacency_matrix)
        
        # Create result dictionary
        result = {
            'id': config.id,
            'name': config.name,
            'timestamp': config.timestamp,
            'n_oscillators': config.n_oscillators,
            'coupling_strength': config.coupling_strength,
            'simulation_time': config.simulation_time,
            'time_step': config.time_step,
            'random_seed': config.random_seed,
            'network_type': config.network_type,
            'frequency_distribution': config.frequency_distribution,
            'frequency_params': freq_params,
            'adjacency_matrix': adj_matrix
        }
        
        return result
    
    except Exception as e:
        print(f"Error retrieving configuration: {e}")
        return None
    
    finally:
        session.close()


def delete_configuration(config_id):
    """
    Delete a configuration from the database.
    
    Parameters:
    -----------
    config_id : int
        ID of the configuration to delete
        
    Returns:
    --------
    bool
        True if deletion was successful, False otherwise
    """
    # Create a session
    session = Session()
    
    try:
        # Query the configuration
        config = session.query(Configuration).get(config_id)
        
        if not config:
            return False
        
        # Delete the configuration
        session.delete(config)
        session.commit()
        
        return True
    
    except Exception as e:
        session.rollback()
        print(f"Error deleting configuration: {e}")
        return False
    
    finally:
        session.close()


def export_configuration_to_json(config_id, file_path=None):
    """
    Export a configuration to a JSON file.
    
    Parameters:
    -----------
    config_id : int
        ID of the configuration to export
    file_path : str, optional
        Path where to save the JSON file, if None, returns the JSON string
        
    Returns:
    --------
    str or None
        JSON string if file_path is None, otherwise None
    """
    # Get the configuration
    config = get_configuration(config_id)
    
    if not config:
        return None
    
    # Create a JSON-compatible dictionary
    json_data = {
        'n_oscillators': config['n_oscillators'],
        'coupling_strength': config['coupling_strength'],
        'network_type': config['network_type'],
        'simulation_time': config['simulation_time'],
        'time_step': config['time_step'],
        'random_seed': config['random_seed'],
        'frequency_distribution': config['frequency_distribution'],
        'frequency_parameters': config['frequency_params']
    }
    
    # Add adjacency matrix if available
    if config['adjacency_matrix'] is not None:
        json_data['adjacency_matrix'] = config['adjacency_matrix'].tolist()
    
    # Export to file or return as string
    if file_path:
        with open(file_path, 'w') as f:
            json.dump(json_data, f, indent=2)
        return None
    else:
        return json.dumps(json_data, indent=2)


def import_configuration_from_json(file_path, save_to_db=True):
    """
    Import a configuration from a JSON file.
    
    Parameters:
    -----------
    file_path : str
        Path to the JSON file
    save_to_db : bool, optional
        Whether to save the imported configuration to the database
        
    Returns:
    --------
    dict
        Dictionary containing the imported configuration
    """
    try:
        # Read the JSON file
        with open(file_path, 'r') as f:
            json_data = json.load(f)
        
        # Process adjacency matrix if available
        adj_matrix = None
        if 'adjacency_matrix' in json_data:
            adj_matrix = np.array(json_data['adjacency_matrix'])
        
        # Create a configuration dictionary
        config = {
            'n_oscillators': json_data.get('n_oscillators', 10),
            'coupling_strength': json_data.get('coupling_strength', 1.0),
            'network_type': json_data.get('network_type', 'All-to-All'),
            'simulation_time': json_data.get('simulation_time', 10.0),
            'time_step': json_data.get('time_step', 0.01),
            'random_seed': json_data.get('random_seed', 42),
            'frequency_distribution': json_data.get('frequency_distribution', 'Normal'),
            'frequency_params': json_data.get('frequency_parameters', {'mean': 0.0, 'std': 0.2}),
            'adjacency_matrix': adj_matrix
        }
        
        # Save to database if requested
        if save_to_db:
            name = os.path.splitext(os.path.basename(file_path))[0]
            config_id = save_configuration(
                name=name,
                n_oscillators=config['n_oscillators'],
                coupling_strength=config['coupling_strength'],
                simulation_time=config['simulation_time'],
                time_step=config['time_step'],
                random_seed=config['random_seed'],
                network_type=config['network_type'],
                frequency_distribution=config['frequency_distribution'],
                frequency_params=config['frequency_params'],
                adjacency_matrix=config['adjacency_matrix']
            )
            config['id'] = config_id
        
        return config
    
    except Exception as e:
        print(f"Error importing configuration: {e}")
        return None

=== backups/checkpoint_before_refactor/kuramoto_model.py ===

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

class KuramotoModel:
    """
    Kuramoto model with adaptive RK45 integration and an automatic max_step
    based on the fastest natural frequency.
    """
    def __init__(self,
                n_oscillators=10,
                coupling_strength=1.0,
                frequencies=None,
                adjacency_matrix=None,
                simulation_time=10.0,
                random_seed=None):
        if random_seed is not None:
            np.random.seed(int(random_seed))

        self.N = n_oscillators
        self.K = coupling_strength
        self.T = simulation_time

        # natural frequencies for each oscillator
        if frequencies is None:
            self.natural_frequencies = np.random.normal(0, 1, self.N)
        else:
            self.natural_frequencies = np.array(frequencies, dtype=float)

        # adjacency matrix A (allâ€toâ€all by default)
        if adjacency_matrix is None:
            A = np.ones((self.N, self.N))
            np.fill_diagonal(A, 0)
            self.A = A
        else:
            self.A = np.array(adjacency_matrix, dtype=float)
            if self.A.shape != (self.N, self.N):
                raise ValueError("Adjacency matrix must be NxN")

        # initial random phases for each oscillator
        self.initial_phases = 2*np.pi*np.random.rand(self.N)

        # placeholders
        self.times = None
        self.phases = None
        self.order = None

    def kuramoto_rhs(self, t, phases):
        """
        Vectorized Kuramoto equation: dphase_i/dt = natural_freq_i + (K/N) * sum_j A_ij * sin(phase_j - phase_i)
        """
        # Calculate phase differences between all pairs of oscillators
        phase_diff = phases[:, None] - phases[None, :]
        
        # Calculate coupling term
        coupling = (self.K/self.N) * self.A * np.sin(-phase_diff)
        
        # Rate of change = natural frequency + coupling influence
        dphase_dt = self.natural_frequencies + np.sum(coupling, axis=1)
        
        return dphase_dt
        
    # Alias for backwards compatibility
    _rhs = kuramoto_rhs

    def simulate(self,
         rtol=1e-6,
         atol=1e-9,
         max_step=None,
         steps_per_period=20,
         min_time_points=500):
        """
        Run an adaptive RK45, capping the stepâ€size by the fastest combined Ï‰+coupling timescale.
        
        Parameters
        ----------
        rtol : float
            Relative tolerance for the solver
        atol : float
            Absolute tolerance for the solver
        max_step : float, optional
            Maximum time step, will be calculated if not provided
        steps_per_period : int
            Number of steps desired per fastest naturalâ€frequency period
        min_time_points : int
            Minimum number of time points to generate for visualization
        
        Returns
        --------
        tuple
            (times, phases, order_parameter)
        """
        # 1) Estimate fastest rate: natural frequencies + coupling
        freq_max = np.max(np.abs(self.natural_frequencies))
        # maximum node degree in the adjacency
        max_deg = np.max(np.sum(self.A > 0, axis=1))
        lambda_max = freq_max + self.K * max_deg

        # 2) Convert that rate to an effective period (avoid div 0)
        if lambda_max <= 0:
            T_eff = np.inf
        else:
            T_eff = 2 * np.pi / lambda_max

        # 3) Compute our cap: "steps_per_period" per fastest period
        cap = T_eff / steps_per_period

        # 4) If user didn't supply or supplied a larger cap, use ours
        if max_step is None or max_step > cap:
            max_step = cap
            
        # Scale the number of points based on simulation duration
        # For longer simulations, use more points, but cap at 2000 points to avoid performance issues
        points_per_time_unit = min_time_points / 10.0  # 500 points for a 10-unit simulation is our baseline
        max_points = 2000  # Upper limit to prevent performance issues with very long simulations
        scaled_points = min(max_points, max(min_time_points, int(points_per_time_unit * self.T)))
        
        # Create the t_eval array with scaled number of points
        t_eval = np.linspace(0, self.T, scaled_points)
        
        print(f"Simulating with max_step={max_step:.5f}, freq_max={freq_max:.5f}, lambda_max={lambda_max:.5f}")
        print(f"Using t_eval with {len(t_eval)} points for simulation duration {self.T:.1f}")

        # 5) Call the integrator with this max_step and t_eval for fixed time points
        sol = solve_ivp(
            fun=self._rhs,
            t_span=(0, self.T),
            y0=self.initial_phases,
            method='RK45',
            rtol=rtol,
            atol=atol,
            max_step=max_step,
            t_eval=t_eval
        )

        self.times = sol.t
        self.phases = sol.y
        # order parameter r(t) = |sum of e^{i*phase_j}| / N
        self.order = np.abs(np.sum(np.exp(1j*self.phases), axis=0)) / self.N
        return self.times, self.phases, self.order

    def plot_order_parameter(self, ax=None):
        if self.order is None:
            self.simulate()
        if ax is None:
            fig, ax = plt.subplots()
        ax.plot(self.times, self.order)
        ax.set_xlabel("Time")
        ax.set_ylabel("Order Parameter r(t)")
        ax.set_title("Kuramoto Synchronization")
        ax.grid(True)
        return ax

    def plot_phases(self, ax=None):
        if self.phases is None:
            self.simulate()
        if ax is None:
            fig, ax = plt.subplots()
        for i in range(self.N):
            ax.plot(self.times, self.phases[i,:] % (2*np.pi), lw=0.8)
        ax.set_xlabel("Time")
        ax.set_ylabel("Phase (mod 2*pi)")
        ax.set_title("Oscillator Phases")
        ax.set_ylim(0, 2*np.pi)
        ax.grid(True)
        return ax

# Example usage
if __name__ == "__main__":
    model = KuramotoModel(n_oscillators=50,
                         coupling_strength=2.5,
                         simulation_time=20.0,
                         random_seed=123)
    t, theta, r = model.simulate()
    model.plot_order_parameter()
    plt.show()

=== pyproject.toml ===

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "ipython>=9.1.0",
    "matplotlib>=3.10.1",
    "networkx>=3.4.2",
    "numpy>=2.2.4",
    "pandas>=2.2.3",
    "plotly>=6.0.1",
    "scipy>=1.15.2",
    "sqlalchemy>=2.0.40",
    "streamlit>=1.44.1",
    "trafilatura>=2.0.0",
]


=== repo-summary.py ===

#!/usr/bin/env python3
"""
repo-to-txt.py
Create a clean, LLM-friendly text snapshot of a repository:
- Directory tree (depth-limited)
- Source file contents
- Optional repo intent
- Notebook summaries instead of raw JSON
Run from repo root:
    python repo-to-txt.py
"""

from pathlib import Path

# =====================
# Configuration
# =====================

OUTPUT_FILE = "snapshot.txt"
MAX_FILE_SIZE = 200_000  # bytes
TREE_DEPTH = 3

INCLUDE_EXTS = {
    ".md", ".py", ".txt", ".yml", ".yaml", ".json", ".toml"
}

EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "node_modules",
    ".ipynb_checkpoints",
    ".egg-info",
    "build",
    "dist",
}

# Explicitly exclude generated snapshots / prompts
EXCLUDE_FILES = {
    "snapshot.txt",
    "prompt.txt",
    "repo_snapshot.txt",
}

REPO_INTENT_FILE = "REPO_INTENT.txt"

NOTEBOOK_SUMMARIES = {
    # "notebooks/demo.ipynb": "Notebook demonstrating training loop and visualization."
}

# =====================
# Helpers
# =====================

def is_excluded(path: Path) -> bool:
    return any(part in EXCLUDE_DIRS for part in path.parts)


def is_text_file(path: Path) -> bool:
    return (
        path.is_file()
        and path.suffix in INCLUDE_EXTS
        and path.stat().st_size < MAX_FILE_SIZE
    )


def load_repo_intent() -> str:
    path = Path(REPO_INTENT_FILE)
    if path.exists():
        return path.read_text(encoding="utf-8").strip()
    return ""


def print_tree(root: Path, depth: int) -> str:
    lines = []
    for path in sorted(root.rglob("*")):
        if is_excluded(path):
            continue
        rel = path.relative_to(root)
        if len(rel.parts) <= depth:
            indent = "  " * (len(rel.parts) - 1)
            lines.append(f"{indent}{path.name}")
    return "\n".join(lines)


def write_section(out, title: str):
    out.write(f"## {title}\n\n")


# =====================
# Main
# =====================

def main():
    repo = Path(".").resolve()

    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        out.write("# Repository Snapshot\n\n")

        write_section(out, "Repo Intent (author-provided)")
        intent = load_repo_intent()
        out.write((intent if intent else "[No repo intent provided]") + "\n\n")

        write_section(out, "Directory Tree")
        out.write(print_tree(repo, TREE_DEPTH) + "\n\n")

        write_section(out, "Files")

        for file in sorted(repo.rglob("*")):
            if is_excluded(file):
                continue
            if file.name in EXCLUDE_FILES:
                continue

            rel = file.relative_to(repo)

            # Notebook handling
            if file.suffix == ".ipynb":
                summary = NOTEBOOK_SUMMARIES.get(
                    str(rel),
                    "Jupyter notebook (content omitted; JSON format)."
                )
                out.write(f"\n\n=== {rel} (summary) ===\n\n{summary}\n")
                continue

            # Text files
            if is_text_file(file):
                out.write(f"\n\n=== {rel} ===\n\n")
                try:
                    out.write(file.read_text(encoding="utf-8"))
                except UnicodeDecodeError:
                    out.write("[Skipped: encoding error]")

    print(f"Saved snapshot to {OUTPUT_FILE}")


if __name__ == "__main__":
    main()


=== src/__init__.py ===



=== src/database/__init__.py ===



=== src/database/database.py ===

"""
Database module for the Kuramoto Model Simulator.
This module provides functionality to store and retrieve simulation data,
as well as import/export configurations as JSON files.
"""

import os
import numpy as np
import json
import pickle
import pandas as pd
from datetime import datetime
from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, LargeBinary, ForeignKey, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship

# Create the engine and base
DATABASE_URL = "sqlite:///kuramoto_simulations.db"
engine = create_engine(DATABASE_URL)
Base = declarative_base()

# Session factory
Session = sessionmaker(bind=engine)


class Simulation(Base):
    """Model representing a Kuramoto simulation run."""
    __tablename__ = "simulations"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.now)
    n_oscillators = Column(Integer)
    coupling_strength = Column(Float)
    simulation_time = Column(Float)
    time_step = Column(Float)
    random_seed = Column(Integer)
    frequency_distribution = Column(String(50))
    frequency_params = Column(Text)  # JSON string of distribution parameters
    
    # Relationships
    frequencies = relationship("Frequency", back_populates="simulation", cascade="all, delete-orphan")
    phases = relationship("Phase", back_populates="simulation", cascade="all, delete-orphan")
    order_parameters = relationship("OrderParameter", back_populates="simulation", cascade="all, delete-orphan")
    adjacency_matrix = relationship("AdjacencyMatrix", back_populates="simulation", uselist=False, cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Simulation(id={self.id}, oscillators={self.n_oscillators}, coupling={self.coupling_strength})>"


class Frequency(Base):
    """Model representing oscillator natural frequencies."""
    __tablename__ = "frequencies"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"))
    oscillator_index = Column(Integer)
    value = Column(Float)
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="frequencies")

    def __repr__(self):
        return f"<Frequency(oscillator={self.oscillator_index}, value={self.value})>"


class Phase(Base):
    """Model representing phase data for each oscillator over time."""
    __tablename__ = "phases"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"))
    time_index = Column(Integer)
    oscillator_index = Column(Integer)
    value = Column(Float)
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="phases")

    def __repr__(self):
        return f"<Phase(time={self.time_index}, oscillator={self.oscillator_index}, value={self.value})>"


class OrderParameter(Base):
    """Model representing order parameter data over time."""
    __tablename__ = "order_parameters"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"))
    time_index = Column(Integer)
    magnitude = Column(Float)
    phase = Column(Float)
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="order_parameters")

    def __repr__(self):
        return f"<OrderParameter(time={self.time_index}, r={self.magnitude}, psi={self.phase})>"


class AdjacencyMatrix(Base):
    """Model representing the network adjacency matrix."""
    __tablename__ = "adjacency_matrices"

    id = Column(Integer, primary_key=True)
    simulation_id = Column(Integer, ForeignKey("simulations.id"), unique=True)
    data = Column(LargeBinary)  # Serialized numpy array
    network_type = Column(String(50))
    
    # Relationship back to simulation
    simulation = relationship("Simulation", back_populates="adjacency_matrix")

    def __repr__(self):
        return f"<AdjacencyMatrix(sim_id={self.simulation_id}, type={self.network_type})>"


class Configuration(Base):
    """Model for storing and retrieving simulation configurations."""
    __tablename__ = "configurations"
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100))
    timestamp = Column(DateTime, default=datetime.now)
    n_oscillators = Column(Integer)
    coupling_strength = Column(Float)
    simulation_time = Column(Float)
    time_step = Column(Float)
    random_seed = Column(Integer)
    network_type = Column(String(50))
    frequency_distribution = Column(String(50))
    frequency_params = Column(Text)  # JSON string
    adjacency_matrix = Column(LargeBinary, nullable=True)  # Serialized numpy array
    
    def __repr__(self):
        return f"<Configuration(id={self.id}, name={self.name})>"


# Create all tables if they don't exist
Base.metadata.create_all(engine)


def store_simulation(model, times, phases, order_parameter, frequencies, freq_type, freq_params=None, adjacency_matrix=None):
    """
    Store simulation results in the database.
    
    Parameters:
    -----------
    model : KuramotoModel
        The model instance containing simulation parameters
    times : ndarray
        Array of time points
    phases : ndarray
        Array of phase data (shape: time points Ã— oscillators)
    order_parameter : dict
        Dictionary containing 'r' and 'psi' for order parameter magnitude and phase
    frequencies : ndarray
        Array of natural frequencies for each oscillator
    freq_type : str
        Type of frequency distribution (e.g., 'normal', 'uniform', 'custom')
    freq_params : dict, optional
        Parameters for the frequency distribution
    adjacency_matrix : ndarray, optional
        Adjacency matrix defining the network structure
        
    Returns:
    --------
    int
        ID of the stored simulation
    """
    # Create a new session
    session = Session()
    
    try:
        # Convert adjacency matrix to binary if it exists
        adj_matrix_binary = None
        network_type = "All-to-All"
        
        if adjacency_matrix is not None:
            adj_matrix_binary = pickle.dumps(adjacency_matrix)
            network_type = "Custom Adjacency Matrix"
        
        # Convert frequency params to JSON if they exist
        freq_params_json = None
        if freq_params is not None:
            freq_params_json = json.dumps(freq_params)
        
        # Create the simulation record
        simulation = Simulation(
            n_oscillators=model.n_oscillators,
            coupling_strength=model.coupling_strength,
            simulation_time=model.simulation_time,
            time_step=model.time_step,
            random_seed=model.random_seed,
            frequency_distribution=freq_type,
            frequency_params=freq_params_json
        )
        
        # Add to session
        session.add(simulation)
        session.flush()  # Flush to get the ID
        
        # Store the adjacency matrix if it exists
        if adj_matrix_binary is not None:
            adj_matrix_record = AdjacencyMatrix(
                simulation_id=simulation.id,
                data=adj_matrix_binary,
                network_type=network_type
            )
            session.add(adj_matrix_record)
        
        # Store frequencies
        for i, freq in enumerate(frequencies):
            freq_record = Frequency(
                simulation_id=simulation.id,
                oscillator_index=i,
                value=float(freq)
            )
            session.add(freq_record)
        
        # Store phase data (if phases is large, store a subset)
        max_phase_samples = 1000
        if len(times) > max_phase_samples:
            # Sample phases at regular intervals
            sample_indices = np.linspace(0, len(times) - 1, max_phase_samples, dtype=int)
            times_sampled = times[sample_indices]
            phases_sampled = phases[sample_indices]
        else:
            times_sampled = times
            phases_sampled = phases
        
        # Store phases
        for t_idx, t in enumerate(times_sampled):
            for osc_idx in range(model.n_oscillators):
                phase_record = Phase(
                    simulation_id=simulation.id,
                    time_index=t_idx,
                    oscillator_index=osc_idx,
                    value=float(phases_sampled[t_idx, osc_idx])
                )
                session.add(phase_record)
        
        # Store order parameter (if order_parameter is large, store a subset)
        r_values = order_parameter['r']
        psi_values = order_parameter['psi']
        
        if len(r_values) > max_phase_samples:
            # Sample order parameter at regular intervals
            sample_indices = np.linspace(0, len(r_values) - 1, max_phase_samples, dtype=int)
            r_sampled = r_values[sample_indices]
            psi_sampled = psi_values[sample_indices]
        else:
            r_sampled = r_values
            psi_sampled = psi_values
        
        for t_idx, (r, psi) in enumerate(zip(r_sampled, psi_sampled)):
            order_param_record = OrderParameter(
                simulation_id=simulation.id,
                time_index=t_idx,
                magnitude=float(r),
                phase=float(psi)
            )
            session.add(order_param_record)
        
        # Commit the transaction
        session.commit()
        return simulation.id
    
    except Exception as e:
        session.rollback()
        print(f"Error storing simulation: {e}")
        raise
    
    finally:
        session.close()


def get_simulation(simulation_id):
    """
    Retrieve a simulation from the database by ID.
    
    Parameters:
    -----------
    simulation_id : int
        ID of the simulation to retrieve
        
    Returns:
    --------
    dict
        Dictionary containing the simulation data, with keys:
        - 'params': Simulation parameters
        - 'times': Time points
        - 'phases': Phase data
        - 'order_parameter': Order parameter data
        - 'frequencies': Natural frequencies
        - 'adjacency_matrix': Network adjacency matrix (if available)
    """
    # Create a session
    session = Session()
    
    try:
        # Query the simulation
        simulation = session.query(Simulation).get(simulation_id)
        
        if not simulation:
            return None
        
        # Retrieve frequencies
        frequencies = session.query(Frequency).filter_by(simulation_id=simulation_id).order_by(Frequency.oscillator_index).all()
        freq_values = np.array([f.value for f in frequencies])
        
        # Retrieve phases
        phases = session.query(Phase).filter_by(simulation_id=simulation_id).order_by(Phase.time_index, Phase.oscillator_index).all()
        time_indices = sorted(list(set([p.time_index for p in phases])))
        oscillator_indices = sorted(list(set([p.oscillator_index for p in phases])))
        
        # Create a phases array
        phases_array = np.zeros((len(time_indices), len(oscillator_indices)))
        for p in phases:
            phases_array[p.time_index, p.oscillator_index] = p.value
        
        # Retrieve order parameter
        order_params = session.query(OrderParameter).filter_by(simulation_id=simulation_id).order_by(OrderParameter.time_index).all()
        r_values = np.array([op.magnitude for op in order_params])
        psi_values = np.array([op.phase for op in order_params])
        
        # Retrieve adjacency matrix if available
        adj_matrix = session.query(AdjacencyMatrix).filter_by(simulation_id=simulation_id).first()
        adj_matrix_array = None
        network_type = "All-to-All"
        
        if adj_matrix:
            adj_matrix_array = pickle.loads(adj_matrix.data)
            network_type = adj_matrix.network_type
        
        # Parse frequency params if available
        freq_params = None
        if simulation.frequency_params:
            try:
                freq_params = json.loads(simulation.frequency_params)
            except:
                freq_params = simulation.frequency_params
        
        # Create a result dictionary
        result = {
            'params': {
                'id': simulation.id,
                'timestamp': simulation.timestamp,
                'n_oscillators': simulation.n_oscillators,
                'coupling_strength': simulation.coupling_strength,
                'simulation_time': simulation.simulation_time,
                'time_step': simulation.time_step,
                'random_seed': simulation.random_seed,
                'frequency_distribution': simulation.frequency_distribution,
                'frequency_params': freq_params,
                'network_type': network_type
            },
            'frequencies': freq_values,
            'times': np.array(time_indices),
            'phases': phases_array,
            'order_parameter': {
                'r': r_values,
                'psi': psi_values
            },
            'adjacency_matrix': adj_matrix_array
        }
        
        return result
    
    except Exception as e:
        print(f"Error retrieving simulation: {e}")
        return None
    
    finally:
        session.close()


def list_simulations():
    """
    List all simulations in the database.
    
    Returns:
    --------
    list
        List of dictionaries, each containing metadata about a simulation
    """
    # Create a session
    session = Session()
    
    try:
        # Query all simulations
        simulations = session.query(Simulation).order_by(Simulation.timestamp.desc()).all()
        
        result = []
        for sim in simulations:
            # Get the network type
            adj_matrix = session.query(AdjacencyMatrix).filter_by(simulation_id=sim.id).first()
            network_type = adj_matrix.network_type if adj_matrix else "All-to-All"
            
            # Parse frequency params if available
            freq_params = None
            if sim.frequency_params:
                try:
                    freq_params = json.loads(sim.frequency_params)
                except:
                    freq_params = sim.frequency_params
            
            # Add to result
            result.append({
                'id': sim.id,
                'timestamp': sim.timestamp,
                'n_oscillators': sim.n_oscillators,
                'coupling_strength': sim.coupling_strength,
                'simulation_time': sim.simulation_time,
                'time_step': sim.time_step,
                'random_seed': sim.random_seed,
                'frequency_distribution': sim.frequency_distribution,
                'frequency_params': freq_params,
                'network_type': network_type
            })
        
        return result
    
    except Exception as e:
        print(f"Error listing simulations: {e}")
        return []
    
    finally:
        session.close()


def delete_simulation(simulation_id):
    """
    Delete a simulation from the database.
    
    Parameters:
    -----------
    simulation_id : int
        ID of the simulation to delete
        
    Returns:
    --------
    bool
        True if deletion was successful, False otherwise
    """
    # Create a session
    session = Session()
    
    try:
        # Query the simulation
        simulation = session.query(Simulation).get(simulation_id)
        
        if not simulation:
            return False
        
        # Delete the simulation (cascade will delete related records)
        session.delete(simulation)
        session.commit()
        
        return True
    
    except Exception as e:
        session.rollback()
        print(f"Error deleting simulation: {e}")
        return False
    
    finally:
        session.close()


def save_configuration(name, n_oscillators, coupling_strength, simulation_time, time_step, 
                     random_seed, network_type, frequency_distribution, frequency_params, adjacency_matrix=None):
    """
    Save a configuration to the database.
    
    Parameters:
    -----------
    name : str
        Name for the configuration
    n_oscillators : int
        Number of oscillators
    coupling_strength : float
        Coupling strength K
    simulation_time : float
        Total simulation time
    time_step : float
        Time step for simulation
    random_seed : int
        Random seed for reproducibility
    network_type : str
        Type of network connection ('All-to-All', 'Nearest Neighbor', 'Random', 'Custom Adjacency Matrix')
    frequency_distribution : str
        Type of frequency distribution ('Normal', 'Uniform', 'Bimodal', 'Custom')
    frequency_params : str or dict
        Parameters for the frequency distribution (will be converted to JSON if dict)
    adjacency_matrix : ndarray, optional
        Custom adjacency matrix (for 'Custom Adjacency Matrix' network type)
        
    Returns:
    --------
    int
        ID of the saved configuration
    """
    # Create a session
    session = Session()
    
    try:
        # Convert adjacency matrix to binary if it exists
        adj_matrix_binary = None
        if adjacency_matrix is not None:
            adj_matrix_binary = pickle.dumps(adjacency_matrix)
        
        # Convert frequency params to JSON if it's a dict
        if isinstance(frequency_params, dict):
            frequency_params = json.dumps(frequency_params)
        
        # Create the configuration record
        config = Configuration(
            name=name,
            n_oscillators=n_oscillators,
            coupling_strength=coupling_strength,
            simulation_time=simulation_time,
            time_step=time_step,
            random_seed=random_seed,
            network_type=network_type,
            frequency_distribution=frequency_distribution,
            frequency_params=frequency_params,
            adjacency_matrix=adj_matrix_binary
        )
        
        # Add to session and commit
        session.add(config)
        session.commit()
        
        return config.id
    
    except Exception as e:
        session.rollback()
        print(f"Error saving configuration: {e}")
        raise
    
    finally:
        session.close()


def list_configurations():
    """
    List all configurations in the database.
    
    Returns:
    --------
    list
        List of dictionaries, each containing metadata about a configuration
    """
    # Create a session
    session = Session()
    
    try:
        # Query all configurations
        configs = session.query(Configuration).order_by(Configuration.timestamp.desc()).all()
        
        result = []
        for config in configs:
            # Parse frequency params if available
            freq_params = None
            if config.frequency_params:
                try:
                    freq_params = json.loads(config.frequency_params)
                except:
                    freq_params = config.frequency_params
            
            # Add to result
            result.append({
                'id': config.id,
                'name': config.name,
                'timestamp': config.timestamp,
                'n_oscillators': config.n_oscillators,
                'coupling_strength': config.coupling_strength,
                'simulation_time': config.simulation_time,
                'time_step': config.time_step,
                'random_seed': config.random_seed,
                'network_type': config.network_type,
                'frequency_distribution': config.frequency_distribution,
                'frequency_params': freq_params,
                'has_matrix': config.adjacency_matrix is not None
            })
        
        return result
    
    except Exception as e:
        print(f"Error listing configurations: {e}")
        return []
    
    finally:
        session.close()


def get_configuration(config_id):
    """
    Get a configuration from the database by ID.
    
    Parameters:
    -----------
    config_id : int
        ID of the configuration to retrieve
        
    Returns:
    --------
    dict
        Dictionary containing the configuration data
    """
    # Create a session
    session = Session()
    
    try:
        # Query the configuration
        config = session.query(Configuration).get(config_id)
        
        if not config:
            return None
        
        # Parse frequency params if available
        freq_params = None
        if config.frequency_params:
            try:
                freq_params = json.loads(config.frequency_params)
            except:
                freq_params = config.frequency_params
        
        # Get adjacency matrix if available
        adj_matrix = None
        if config.adjacency_matrix:
            adj_matrix = pickle.loads(config.adjacency_matrix)
        
        # Create result dictionary
        result = {
            'id': config.id,
            'name': config.name,
            'timestamp': config.timestamp,
            'n_oscillators': config.n_oscillators,
            'coupling_strength': config.coupling_strength,
            'simulation_time': config.simulation_time,
            'time_step': config.time_step,
            'random_seed': config.random_seed,
            'network_type': config.network_type,
            'frequency_distribution': config.frequency_distribution,
            'frequency_params': freq_params,
            'adjacency_matrix': adj_matrix
        }
        
        return result
    
    except Exception as e:
        print(f"Error retrieving configuration: {e}")
        return None
    
    finally:
        session.close()


def get_configuration_by_name(name):
    """
    Get a configuration from the database by name.
    
    Parameters:
    -----------
    name : str
        Name of the configuration to retrieve
        
    Returns:
    --------
    dict
        Dictionary containing the configuration data
    """
    # Create a session
    session = Session()
    
    try:
        # Query the configuration
        config = session.query(Configuration).filter_by(name=name).first()
        
        if not config:
            return None
        
        # Parse frequency params if available
        freq_params = None
        if config.frequency_params:
            try:
                freq_params = json.loads(config.frequency_params)
            except:
                freq_params = config.frequency_params
        
        # Get adjacency matrix if available
        adj_matrix = None
        if config.adjacency_matrix:
            adj_matrix = pickle.loads(config.adjacency_matrix)
        
        # Create result dictionary
        result = {
            'id': config.id,
            'name': config.name,
            'timestamp': config.timestamp,
            'n_oscillators': config.n_oscillators,
            'coupling_strength': config.coupling_strength,
            'simulation_time': config.simulation_time,
            'time_step': config.time_step,
            'random_seed': config.random_seed,
            'network_type': config.network_type,
            'frequency_distribution': config.frequency_distribution,
            'frequency_params': freq_params,
            'adjacency_matrix': adj_matrix
        }
        
        return result
    
    except Exception as e:
        print(f"Error retrieving configuration: {e}")
        return None
    
    finally:
        session.close()


def delete_configuration(config_id):
    """
    Delete a configuration from the database.
    
    Parameters:
    -----------
    config_id : int
        ID of the configuration to delete
        
    Returns:
    --------
    bool
        True if deletion was successful, False otherwise
    """
    # Create a session
    session = Session()
    
    try:
        # Query the configuration
        config = session.query(Configuration).get(config_id)
        
        if not config:
            return False
        
        # Delete the configuration
        session.delete(config)
        session.commit()
        
        return True
    
    except Exception as e:
        session.rollback()
        print(f"Error deleting configuration: {e}")
        return False
    
    finally:
        session.close()


def export_configuration_to_json(config_id, file_path=None):
    """
    Export a configuration to a JSON file.
    
    Parameters:
    -----------
    config_id : int
        ID of the configuration to export
    file_path : str, optional
        Path where to save the JSON file, if None, returns the JSON string
        
    Returns:
    --------
    str or None
        JSON string if file_path is None, otherwise None
    """
    # Get the configuration
    config = get_configuration(config_id)
    
    if not config:
        return None
    
    # Create a JSON-compatible dictionary
    json_data = {
        'n_oscillators': config['n_oscillators'],
        'coupling_strength': config['coupling_strength'],
        'network_type': config['network_type'],
        'simulation_time': config['simulation_time'],
        'time_step': config['time_step'],
        'random_seed': config['random_seed'],
        'frequency_distribution': config['frequency_distribution'],
        'frequency_parameters': config['frequency_params']
    }
    
    # Add adjacency matrix if available
    if config['adjacency_matrix'] is not None:
        json_data['adjacency_matrix'] = config['adjacency_matrix'].tolist()
    
    # Export to file or return as string
    if file_path:
        with open(file_path, 'w') as f:
            json.dump(json_data, f, indent=2)
        return None
    else:
        return json.dumps(json_data, indent=2)


def import_configuration_from_json(file_path, save_to_db=True):
    """
    Import a configuration from a JSON file.
    
    Parameters:
    -----------
    file_path : str
        Path to the JSON file
    save_to_db : bool, optional
        Whether to save the imported configuration to the database
        
    Returns:
    --------
    dict
        Dictionary containing the imported configuration
    """
    try:
        # Read the JSON file
        with open(file_path, 'r') as f:
            json_data = json.load(f)
        
        # Process adjacency matrix if available
        adj_matrix = None
        if 'adjacency_matrix' in json_data:
            adj_matrix = np.array(json_data['adjacency_matrix'])
        
        # Create a configuration dictionary
        config = {
            'n_oscillators': json_data.get('n_oscillators', 10),
            'coupling_strength': json_data.get('coupling_strength', 1.0),
            'network_type': json_data.get('network_type', 'All-to-All'),
            'simulation_time': json_data.get('simulation_time', 10.0),
            'time_step': json_data.get('time_step', 0.01),
            'random_seed': json_data.get('random_seed', 42),
            'frequency_distribution': json_data.get('frequency_distribution', 'Normal'),
            'frequency_params': json_data.get('frequency_parameters', {'mean': 0.0, 'std': 0.2}),
            'adjacency_matrix': adj_matrix
        }
        
        # Save to database if requested
        if save_to_db:
            name = os.path.splitext(os.path.basename(file_path))[0]
            config_id = save_configuration(
                name=name,
                n_oscillators=config['n_oscillators'],
                coupling_strength=config['coupling_strength'],
                simulation_time=config['simulation_time'],
                time_step=config['time_step'],
                random_seed=config['random_seed'],
                network_type=config['network_type'],
                frequency_distribution=config['frequency_distribution'],
                frequency_params=config['frequency_params'],
                adjacency_matrix=config['adjacency_matrix']
            )
            config['id'] = config_id
        
        return config
    
    except Exception as e:
        print(f"Error importing configuration: {e}")
        return None

=== src/models/__init__.py ===



=== src/models/kuramoto_model.py ===

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

class KuramotoModel:
    """
    Kuramoto model with adaptive RK45 integration and an automatic max_step
    based on the fastest natural frequency.
    """
    def __init__(self,
                n_oscillators=10,
                coupling_strength=1.0,
                frequencies=None,
                adjacency_matrix=None,
                simulation_time=10.0,
                random_seed=None):
        if random_seed is not None:
            np.random.seed(int(random_seed))

        self.N = n_oscillators
        self.K = coupling_strength
        self.T = simulation_time

        # natural frequencies for each oscillator
        if frequencies is None:
            self.natural_frequencies = np.random.normal(0, 1, self.N)
        else:
            self.natural_frequencies = np.array(frequencies, dtype=float)

        # adjacency matrix A (allâ€toâ€all by default)
        if adjacency_matrix is None:
            A = np.ones((self.N, self.N))
            np.fill_diagonal(A, 0)
            self.A = A
        else:
            self.A = np.array(adjacency_matrix, dtype=float)
            if self.A.shape != (self.N, self.N):
                raise ValueError("Adjacency matrix must be NxN")

        # initial random phases for each oscillator
        self.initial_phases = 2*np.pi*np.random.rand(self.N)

        # placeholders
        self.times = None
        self.phases = None
        self.order = None

    def kuramoto_rhs(self, t, phases):
        """
        Vectorized Kuramoto equation: dphase_i/dt = natural_freq_i + (K/N) * sum_j A_ij * sin(phase_j - phase_i)
        """
        # Calculate phase differences between all pairs of oscillators
        phase_diff = phases[:, None] - phases[None, :]
        
        # Calculate coupling term
        coupling = (self.K/self.N) * self.A * np.sin(-phase_diff)
        
        # Rate of change = natural frequency + coupling influence
        dphase_dt = self.natural_frequencies + np.sum(coupling, axis=1)
        
        return dphase_dt
        
    # Alias for backwards compatibility
    _rhs = kuramoto_rhs

    def simulate(self,
         rtol=1e-6,
         atol=1e-9,
         max_step=None,
         steps_per_period=20,
         min_time_points=500):
        """
        Run an adaptive RK45, capping the stepâ€size by the fastest combined Ï‰+coupling timescale.
        
        Parameters
        ----------
        rtol : float
            Relative tolerance for the solver
        atol : float
            Absolute tolerance for the solver
        max_step : float, optional
            Maximum time step, will be calculated if not provided
        steps_per_period : int
            Number of steps desired per fastest naturalâ€frequency period
        min_time_points : int
            Minimum number of time points to generate for visualization
        
        Returns
        --------
        tuple
            (times, phases, order_parameter)
        """
        # 1) Estimate fastest rate: natural frequencies + coupling
        freq_max = np.max(np.abs(self.natural_frequencies))
        # maximum node degree in the adjacency
        max_deg = np.max(np.sum(self.A > 0, axis=1))
        lambda_max = freq_max + self.K * max_deg

        # 2) Convert that rate to an effective period (avoid div 0)
        if lambda_max <= 0:
            T_eff = np.inf
        else:
            T_eff = 2 * np.pi / lambda_max

        # 3) Compute our cap: "steps_per_period" per fastest period
        cap = T_eff / steps_per_period

        # 4) If user didn't supply or supplied a larger cap, use ours
        if max_step is None or max_step > cap:
            max_step = cap
            
        # Scale the number of points based on simulation duration
        # For longer simulations, use more points, but cap at 2000 points to avoid performance issues
        points_per_time_unit = min_time_points / 10.0  # 500 points for a 10-unit simulation is our baseline
        max_points = 2000  # Upper limit to prevent performance issues with very long simulations
        scaled_points = min(max_points, max(min_time_points, int(points_per_time_unit * self.T)))
        
        # Create the t_eval array with scaled number of points
        t_eval = np.linspace(0, self.T, scaled_points)
        
        print(f"Simulating with max_step={max_step:.5f}, freq_max={freq_max:.5f}, lambda_max={lambda_max:.5f}")
        print(f"Using t_eval with {len(t_eval)} points for simulation duration {self.T:.1f}")

        # 5) Call the integrator with this max_step and t_eval for fixed time points
        sol = solve_ivp(
            fun=self._rhs,
            t_span=(0, self.T),
            y0=self.initial_phases,
            method='RK45',
            rtol=rtol,
            atol=atol,
            max_step=max_step,
            t_eval=t_eval
        )

        self.times = sol.t
        self.phases = sol.y
        # order parameter r(t) = |sum of e^{i*phase_j}| / N
        self.order = np.abs(np.sum(np.exp(1j*self.phases), axis=0)) / self.N
        return self.times, self.phases, self.order

    def plot_order_parameter(self, ax=None):
        if self.order is None:
            self.simulate()
        if ax is None:
            fig, ax = plt.subplots()
        ax.plot(self.times, self.order)
        ax.set_xlabel("Time")
        ax.set_ylabel("Order Parameter r(t)")
        ax.set_title("Kuramoto Synchronization")
        ax.grid(True)
        return ax

    def plot_phases(self, ax=None):
        if self.phases is None:
            self.simulate()
        if ax is None:
            fig, ax = plt.subplots()
        for i in range(self.N):
            ax.plot(self.times, self.phases[i,:] % (2*np.pi), lw=0.8)
        ax.set_xlabel("Time")
        ax.set_ylabel("Phase (mod 2*pi)")
        ax.set_title("Oscillator Phases")
        ax.set_ylim(0, 2*np.pi)
        ax.grid(True)
        return ax

# Example usage
if __name__ == "__main__":
    model = KuramotoModel(n_oscillators=50,
                         coupling_strength=2.5,
                         simulation_time=20.0,
                         random_seed=123)
    t, theta, r = model.simulate()
    model.plot_order_parameter()
    plt.show()

=== static/json/default_config.json ===

{
  "id": 1,
  "name": "\"Steady State\" Order Parameter",
  "timestamp": 

=== static/json/kuramoto_config.json ===

{
  "id": 1,
  "name": "\"Steady State\" Order Parameter",
  "timestamp": 